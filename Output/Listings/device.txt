; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\device.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\device.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\device.crf ..\rtthread\src\device.c]
                          THUMB

                          AREA ||i.rt_device_close||, CODE, READONLY, ALIGN=1

                  rt_device_close PROC
;;;291     */
;;;292    rt_err_t rt_device_close(rt_device_t dev)
000000  b570              PUSH     {r4-r6,lr}
;;;293    {
000002  4604              MOV      r4,r0
;;;294        rt_err_t result = RT_EOK;
000004  2500              MOVS     r5,#0
;;;295    
;;;296        RT_ASSERT(dev != RT_NULL);
;;;297    
;;;298        if (dev->ref_count == 0)
000006  7ea0              LDRB     r0,[r4,#0x1a]
000008  b908              CBNZ     r0,|L1.14|
;;;299            return -RT_ERROR;
00000a  1e68              SUBS     r0,r5,#1
                  |L1.12|
;;;300    
;;;301        dev->ref_count--;
;;;302    
;;;303        if (dev->ref_count != 0)
;;;304            return RT_EOK;
;;;305    
;;;306        /* call device close interface */
;;;307        if (dev->close != RT_NULL)
;;;308        {
;;;309            result = dev->close(dev);
;;;310        }
;;;311    
;;;312        /* set open flag */
;;;313        if (result == RT_EOK || result == -RT_ENOSYS)
;;;314            dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
;;;315    
;;;316        return result;
;;;317    }
00000c  bd70              POP      {r4-r6,pc}
                  |L1.14|
00000e  7ea0              LDRB     r0,[r4,#0x1a]         ;301
000010  1e40              SUBS     r0,r0,#1              ;301
000012  76a0              STRB     r0,[r4,#0x1a]         ;301
000014  7ea0              LDRB     r0,[r4,#0x1a]         ;303
000016  b108              CBZ      r0,|L1.28|
000018  2000              MOVS     r0,#0                 ;304
00001a  e7f7              B        |L1.12|
                  |L1.28|
00001c  6ae0              LDR      r0,[r4,#0x2c]         ;307
00001e  b118              CBZ      r0,|L1.40|
000020  4620              MOV      r0,r4                 ;309
000022  6ae1              LDR      r1,[r4,#0x2c]         ;309
000024  4788              BLX      r1                    ;309
000026  4605              MOV      r5,r0                 ;309
                  |L1.40|
000028  b10d              CBZ      r5,|L1.46|
00002a  1da8              ADDS     r0,r5,#6              ;313
00002c  b908              CBNZ     r0,|L1.50|
                  |L1.46|
00002e  2000              MOVS     r0,#0                 ;314
000030  8320              STRH     r0,[r4,#0x18]         ;314
                  |L1.50|
000032  4628              MOV      r0,r5                 ;316
000034  e7ea              B        |L1.12|
;;;318    RTM_EXPORT(rt_device_close);
                          ENDP


                          AREA ||i.rt_device_control||, CODE, READONLY, ALIGN=1

                  rt_device_control PROC
;;;404     */
;;;405    rt_err_t rt_device_control(rt_device_t dev, int cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;406    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;407        RT_ASSERT(dev != RT_NULL);
;;;408    
;;;409        /* call device write interface */
;;;410        if (dev->control != RT_NULL)
000008  6ba0              LDR      r0,[r4,#0x38]
00000a  b128              CBZ      r0,|L2.24|
;;;411        {
;;;412            return dev->control(dev, cmd, arg);
00000c  4632              MOV      r2,r6
00000e  4629              MOV      r1,r5
000010  4620              MOV      r0,r4
000012  6ba3              LDR      r3,[r4,#0x38]
000014  4798              BLX      r3
                  |L2.22|
;;;413        }
;;;414    
;;;415        return -RT_ENOSYS;
;;;416    }
000016  bd70              POP      {r4-r6,pc}
                  |L2.24|
000018  f06f0005          MVN      r0,#5                 ;415
00001c  e7fb              B        |L2.22|
;;;417    RTM_EXPORT(rt_device_control);
                          ENDP


                          AREA ||i.rt_device_create||, CODE, READONLY, ALIGN=1

                  rt_device_create PROC
;;;150     */
;;;151    rt_device_t rt_device_create(int type, int attach_size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;152    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;153        int size;
;;;154        rt_device_t device;
;;;155    
;;;156        size = RT_ALIGN(sizeof(struct rt_device), RT_ALIGN_SIZE);
000008  2740              MOVS     r7,#0x40
;;;157        size += attach_size;
00000a  4437              ADD      r7,r7,r6
;;;158    
;;;159        device = (rt_device_t)rt_malloc(size);
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       rt_malloc
000012  4604              MOV      r4,r0
;;;160        if (device)
000014  b12c              CBZ      r4,|L3.34|
;;;161        {
;;;162            rt_memset(device, 0x0, sizeof(struct rt_device));
000016  2240              MOVS     r2,#0x40
000018  2100              MOVS     r1,#0
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_memset
;;;163            device->type = (enum rt_device_class_type)type;
000020  7525              STRB     r5,[r4,#0x14]
                  |L3.34|
;;;164        }
;;;165    
;;;166        return device;
000022  4620              MOV      r0,r4
;;;167    }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;168    RTM_EXPORT(rt_device_create);
                          ENDP


                          AREA ||i.rt_device_destroy||, CODE, READONLY, ALIGN=1

                  rt_device_destroy PROC
;;;174     */
;;;175    void rt_device_destroy(rt_device_t device)
000000  b510              PUSH     {r4,lr}
;;;176    {
000002  4604              MOV      r4,r0
;;;177        /* unregister device firstly */
;;;178        rt_device_unregister(device);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_device_unregister
;;;179    
;;;180        /* release this device object */
;;;181        rt_free(device);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_free
;;;182    }
000010  bd10              POP      {r4,pc}
;;;183    RTM_EXPORT(rt_device_destroy);
                          ENDP


                          AREA ||i.rt_device_find||, CODE, READONLY, ALIGN=1

                  rt_device_find PROC
;;;104     */
;;;105    rt_device_t rt_device_find(const char *name)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;106    {
000004  4606              MOV      r6,r0
;;;107        struct rt_object *object;
;;;108        struct rt_list_node *node;
;;;109        struct rt_object_information *information;
;;;110    
;;;111        /* enter critical */
;;;112        if (rt_thread_self() != RT_NULL)
000006  f7fffffe          BL       rt_thread_self
00000a  b108              CBZ      r0,|L5.16|
;;;113            rt_enter_critical();
00000c  f7fffffe          BL       rt_enter_critical
                  |L5.16|
;;;114    
;;;115        /* try to find device object */
;;;116        information = rt_object_get_information(RT_Object_Class_Device);
000010  2008              MOVS     r0,#8
000012  f7fffffe          BL       rt_object_get_information
000016  4605              MOV      r5,r0
;;;117        RT_ASSERT(information != RT_NULL);
;;;118        for (node  = information->object_list.next;
000018  686c              LDR      r4,[r5,#4]
00001a  e010              B        |L5.62|
                  |L5.28|
;;;119             node != &(information->object_list);
;;;120             node  = node->next)
;;;121        {
;;;122            object = rt_list_entry(node, struct rt_object, list);
00001c  f1a4070c          SUB      r7,r4,#0xc
;;;123            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
000020  2208              MOVS     r2,#8
000022  4631              MOV      r1,r6
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       rt_strncmp
00002a  b938              CBNZ     r0,|L5.60|
;;;124            {
;;;125                /* leave critical */
;;;126                if (rt_thread_self() != RT_NULL)
00002c  f7fffffe          BL       rt_thread_self
000030  b108              CBZ      r0,|L5.54|
;;;127                    rt_exit_critical();
000032  f7fffffe          BL       rt_exit_critical
                  |L5.54|
;;;128    
;;;129                return (rt_device_t)object;
000036  4638              MOV      r0,r7
                  |L5.56|
;;;130            }
;;;131        }
;;;132    
;;;133        /* leave critical */
;;;134        if (rt_thread_self() != RT_NULL)
;;;135            rt_exit_critical();
;;;136    
;;;137        /* not found */
;;;138        return RT_NULL;
;;;139    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L5.60|
00003c  6824              LDR      r4,[r4,#0]            ;120
                  |L5.62|
00003e  1d28              ADDS     r0,r5,#4              ;119
000040  4284              CMP      r4,r0                 ;119
000042  d1eb              BNE      |L5.28|
000044  f7fffffe          BL       rt_thread_self
000048  b108              CBZ      r0,|L5.78|
00004a  f7fffffe          BL       rt_exit_critical
                  |L5.78|
00004e  2000              MOVS     r0,#0                 ;138
000050  e7f2              B        |L5.56|
;;;140    RTM_EXPORT(rt_device_find);
                          ENDP


                          AREA ||i.rt_device_init||, CODE, READONLY, ALIGN=2

                  rt_device_init PROC
;;;192     */
;;;193    rt_err_t rt_device_init(rt_device_t dev)
000000  b570              PUSH     {r4-r6,lr}
;;;194    {
000002  4604              MOV      r4,r0
;;;195        rt_err_t result = RT_EOK;
000004  2500              MOVS     r5,#0
;;;196    
;;;197        RT_ASSERT(dev != RT_NULL);
;;;198    
;;;199        /* get device init handler */
;;;200        if (dev->init != RT_NULL)
000006  6a60              LDR      r0,[r4,#0x24]
000008  b190              CBZ      r0,|L6.48|
;;;201        {
;;;202            if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
00000a  7da0              LDRB     r0,[r4,#0x16]
00000c  f0000010          AND      r0,r0,#0x10
000010  b970              CBNZ     r0,|L6.48|
;;;203            {
;;;204                result = dev->init(dev);
000012  4620              MOV      r0,r4
000014  6a61              LDR      r1,[r4,#0x24]
000016  4788              BLX      r1
000018  4605              MOV      r5,r0
;;;205                if (result != RT_EOK)
00001a  b12d              CBZ      r5,|L6.40|
;;;206                {
;;;207                    rt_kprintf("To initialize device:%s failed. The error code is %d\n",
00001c  462a              MOV      r2,r5
00001e  4621              MOV      r1,r4
000020  a004              ADR      r0,|L6.52|
000022  f7fffffe          BL       rt_kprintf
000026  e003              B        |L6.48|
                  |L6.40|
;;;208                               dev->parent.name, result);
;;;209                }
;;;210                else
;;;211                {
;;;212                    dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
000028  8ae0              LDRH     r0,[r4,#0x16]
00002a  f0400010          ORR      r0,r0,#0x10
00002e  82e0              STRH     r0,[r4,#0x16]
                  |L6.48|
;;;213                }
;;;214            }
;;;215        }
;;;216    
;;;217        return result;
000030  4628              MOV      r0,r5
;;;218    }
000032  bd70              POP      {r4-r6,pc}
;;;219    
                          ENDP

                  |L6.52|
000034  546f2069          DCB      "To initialize device:%s failed. The error code is %d\n",0
000038  6e697469
00003c  616c697a
000040  65206465
000044  76696365
000048  3a257320
00004c  6661696c
000050  65642e20
000054  54686520
000058  6572726f
00005c  7220636f
000060  64652069
000064  73202564
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.rt_device_init_all||, CODE, READONLY, ALIGN=1

                  rt_device_init_all PROC
;;;92      */
;;;93     rt_err_t rt_device_init_all(void)
000000  2000              MOVS     r0,#0
;;;94     {
;;;95         return RT_EOK;
;;;96     }
000002  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.rt_device_open||, CODE, READONLY, ALIGN=2

                  rt_device_open PROC
;;;227     */
;;;228    rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
000000  b570              PUSH     {r4-r6,lr}
;;;229    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;230        rt_err_t result = RT_EOK;
000006  2500              MOVS     r5,#0
;;;231    
;;;232        RT_ASSERT(dev != RT_NULL);
;;;233    
;;;234        /* if device is not initialized, initialize it. */
;;;235        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
000008  7da0              LDRB     r0,[r4,#0x16]
00000a  f0000010          AND      r0,r0,#0x10
00000e  b988              CBNZ     r0,|L8.52|
;;;236        {
;;;237            if (dev->init != RT_NULL)
000010  6a60              LDR      r0,[r4,#0x24]
000012  b158              CBZ      r0,|L8.44|
;;;238            {
;;;239                result = dev->init(dev);
000014  4620              MOV      r0,r4
000016  6a61              LDR      r1,[r4,#0x24]
000018  4788              BLX      r1
00001a  4605              MOV      r5,r0
;;;240                if (result != RT_EOK)
00001c  b135              CBZ      r5,|L8.44|
;;;241                {
;;;242                    rt_kprintf("To initialize device:%s failed. The error code is %d\n",
00001e  462a              MOV      r2,r5
000020  4621              MOV      r1,r4
000022  a016              ADR      r0,|L8.124|
000024  f7fffffe          BL       rt_kprintf
;;;243                               dev->parent.name, result);
;;;244    
;;;245                    return result;
000028  4628              MOV      r0,r5
                  |L8.42|
;;;246                }
;;;247            }
;;;248    
;;;249            dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
;;;250        }
;;;251    
;;;252        /* device is a stand alone device and opened */
;;;253        if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
;;;254            (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
;;;255        {
;;;256            return -RT_EBUSY;
;;;257        }
;;;258    
;;;259        /* call device open interface */
;;;260        if (dev->open != RT_NULL)
;;;261        {
;;;262            result = dev->open(dev, oflag);
;;;263        }
;;;264        else
;;;265        {
;;;266            /* set open flag */
;;;267            dev->open_flag = (oflag & RT_DEVICE_OFLAG_MASK);
;;;268        }
;;;269    
;;;270        /* set open flag */
;;;271        if (result == RT_EOK || result == -RT_ENOSYS)
;;;272        {
;;;273            dev->open_flag |= RT_DEVICE_OFLAG_OPEN;
;;;274    
;;;275            dev->ref_count++;
;;;276            /* don't let bad things happen silently. If you are bitten by this assert,
;;;277             * please set the ref_count to a bigger type. */
;;;278            RT_ASSERT(dev->ref_count != 0);
;;;279        }
;;;280    
;;;281        return result;
;;;282    }
00002a  bd70              POP      {r4-r6,pc}
                  |L8.44|
00002c  8ae0              LDRH     r0,[r4,#0x16]         ;249
00002e  f0400010          ORR      r0,r0,#0x10           ;249
000032  82e0              STRH     r0,[r4,#0x16]         ;249
                  |L8.52|
000034  7da0              LDRB     r0,[r4,#0x16]         ;253
000036  f0000008          AND      r0,r0,#8              ;253
00003a  b130              CBZ      r0,|L8.74|
00003c  7e20              LDRB     r0,[r4,#0x18]         ;254
00003e  f0000008          AND      r0,r0,#8              ;254
000042  b110              CBZ      r0,|L8.74|
000044  f06f0006          MVN      r0,#6                 ;256
000048  e7ef              B        |L8.42|
                  |L8.74|
00004a  6aa0              LDR      r0,[r4,#0x28]         ;260
00004c  b128              CBZ      r0,|L8.90|
00004e  4631              MOV      r1,r6                 ;262
000050  4620              MOV      r0,r4                 ;262
000052  6aa2              LDR      r2,[r4,#0x28]         ;262
000054  4790              BLX      r2                    ;262
000056  4605              MOV      r5,r0                 ;262
000058  e003              B        |L8.98|
                  |L8.90|
00005a  f640700f          MOV      r0,#0xf0f             ;267
00005e  4030              ANDS     r0,r0,r6              ;267
000060  8320              STRH     r0,[r4,#0x18]         ;267
                  |L8.98|
000062  b10d              CBZ      r5,|L8.104|
000064  1da8              ADDS     r0,r5,#6              ;271
000066  b930              CBNZ     r0,|L8.118|
                  |L8.104|
000068  8b20              LDRH     r0,[r4,#0x18]         ;273
00006a  f0400008          ORR      r0,r0,#8              ;273
00006e  8320              STRH     r0,[r4,#0x18]         ;273
000070  7ea0              LDRB     r0,[r4,#0x1a]         ;275
000072  1c40              ADDS     r0,r0,#1              ;275
000074  76a0              STRB     r0,[r4,#0x1a]         ;275
                  |L8.118|
000076  4628              MOV      r0,r5                 ;281
000078  e7d7              B        |L8.42|
;;;283    RTM_EXPORT(rt_device_open);
                          ENDP

00007a  0000              DCW      0x0000
                  |L8.124|
00007c  546f2069          DCB      "To initialize device:%s failed. The error code is %d\n",0
000080  6e697469
000084  616c697a
000088  65206465
00008c  76696365
000090  3a257320
000094  6661696c
000098  65642e20
00009c  54686520
0000a0  6572726f
0000a4  7220636f
0000a8  64652069
0000ac  73202564
0000b0  0a00    
0000b2  00                DCB      0
0000b3  00                DCB      0

                          AREA ||i.rt_device_read||, CODE, READONLY, ALIGN=1

                  rt_device_read PROC
;;;331     */
;;;332    rt_size_t rt_device_read(rt_device_t dev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;333                             rt_off_t    pos,
;;;334                             void       *buffer,
;;;335                             rt_size_t   size)
;;;336    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;337        RT_ASSERT(dev != RT_NULL);
;;;338    
;;;339        if (dev->ref_count == 0)
00000c  7ea0              LDRB     r0,[r4,#0x1a]
00000e  b930              CBNZ     r0,|L9.30|
;;;340        {
;;;341            rt_set_errno(-RT_ERROR);
000010  f04f30ff          MOV      r0,#0xffffffff
000014  f7fffffe          BL       rt_set_errno
;;;342            return 0;
000018  2000              MOVS     r0,#0
                  |L9.26|
;;;343        }
;;;344    
;;;345        /* call device read interface */
;;;346        if (dev->read != RT_NULL)
;;;347        {
;;;348            return dev->read(dev, pos, buffer, size);
;;;349        }
;;;350    
;;;351        /* set error code */
;;;352        rt_set_errno(-RT_ENOSYS);
;;;353    
;;;354        return 0;
;;;355    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L9.30|
00001e  6b20              LDR      r0,[r4,#0x30]         ;346
000020  b138              CBZ      r0,|L9.50|
000022  463b              MOV      r3,r7                 ;348
000024  4632              MOV      r2,r6                 ;348
000026  4629              MOV      r1,r5                 ;348
000028  4620              MOV      r0,r4                 ;348
00002a  f8d4c030          LDR      r12,[r4,#0x30]        ;348
00002e  47e0              BLX      r12                   ;348
000030  e7f3              B        |L9.26|
                  |L9.50|
000032  f06f0005          MVN      r0,#5                 ;352
000036  f7fffffe          BL       rt_set_errno
00003a  2000              MOVS     r0,#0                 ;354
00003c  e7ed              B        |L9.26|
;;;356    RTM_EXPORT(rt_device_read);
                          ENDP


                          AREA ||i.rt_device_register||, CODE, READONLY, ALIGN=1

                  rt_device_register PROC
;;;43      */
;;;44     rt_err_t rt_device_register(rt_device_t dev,
000000  b570              PUSH     {r4-r6,lr}
;;;45                                 const char *name,
;;;46                                 rt_uint16_t flags)
;;;47     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;48         if (dev == RT_NULL)
000008  b914              CBNZ     r4,|L10.16|
;;;49             return -RT_ERROR;
00000a  f04f30ff          MOV      r0,#0xffffffff
                  |L10.14|
;;;50     
;;;51         if (rt_device_find(name) != RT_NULL)
;;;52             return -RT_ERROR;
;;;53     
;;;54         rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
;;;55         dev->flag = flags;
;;;56         dev->ref_count = 0;
;;;57         dev->open_flag = 0;
;;;58     
;;;59     #if defined(RT_USING_POSIX)
;;;60         dev->fops = RT_NULL;
;;;61         rt_list_init(&(dev->wait_queue));
;;;62     #endif
;;;63     
;;;64         return RT_EOK;
;;;65     }
00000e  bd70              POP      {r4-r6,pc}
                  |L10.16|
000010  4628              MOV      r0,r5                 ;51
000012  f7fffffe          BL       rt_device_find
000016  b110              CBZ      r0,|L10.30|
000018  f04f30ff          MOV      r0,#0xffffffff        ;52
00001c  e7f7              B        |L10.14|
                  |L10.30|
00001e  462a              MOV      r2,r5                 ;54
000020  2108              MOVS     r1,#8                 ;54
000022  4620              MOV      r0,r4                 ;54
000024  f7fffffe          BL       rt_object_init
000028  82e6              STRH     r6,[r4,#0x16]         ;55
00002a  2000              MOVS     r0,#0                 ;56
00002c  76a0              STRB     r0,[r4,#0x1a]         ;56
00002e  8320              STRH     r0,[r4,#0x18]         ;57
000030  bf00              NOP                            ;64
000032  e7ec              B        |L10.14|
;;;66     RTM_EXPORT(rt_device_register);
                          ENDP


                          AREA ||i.rt_device_set_rx_indicate||, CODE, READONLY, ALIGN=1

                  rt_device_set_rx_indicate PROC
;;;428    rt_err_t
;;;429    rt_device_set_rx_indicate(rt_device_t dev,
000000  4602              MOV      r2,r0
;;;430                              rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
;;;431    {
;;;432        RT_ASSERT(dev != RT_NULL);
;;;433    
;;;434        dev->rx_indicate = rx_ind;
000002  61d1              STR      r1,[r2,#0x1c]
;;;435    
;;;436        return RT_EOK;
000004  2000              MOVS     r0,#0
;;;437    }
000006  4770              BX       lr
;;;438    RTM_EXPORT(rt_device_set_rx_indicate);
                          ENDP


                          AREA ||i.rt_device_set_tx_complete||, CODE, READONLY, ALIGN=1

                  rt_device_set_tx_complete PROC
;;;449    rt_err_t
;;;450    rt_device_set_tx_complete(rt_device_t dev,
000000  4602              MOV      r2,r0
;;;451                              rt_err_t (*tx_done)(rt_device_t dev, void *buffer))
;;;452    {
;;;453        RT_ASSERT(dev != RT_NULL);
;;;454    
;;;455        dev->tx_complete = tx_done;
000002  6211              STR      r1,[r2,#0x20]
;;;456    
;;;457        return RT_EOK;
000004  2000              MOVS     r0,#0
;;;458    }
000006  4770              BX       lr
;;;459    RTM_EXPORT(rt_device_set_tx_complete);
                          ENDP


                          AREA ||i.rt_device_unregister||, CODE, READONLY, ALIGN=1

                  rt_device_unregister PROC
;;;74      */
;;;75     rt_err_t rt_device_unregister(rt_device_t dev)
000000  b510              PUSH     {r4,lr}
;;;76     {
000002  4604              MOV      r4,r0
;;;77         RT_ASSERT(dev != RT_NULL);
;;;78     
;;;79         rt_object_detach(&(dev->parent));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_object_detach
;;;80     
;;;81         return RT_EOK;
00000a  2000              MOVS     r0,#0
;;;82     }
00000c  bd10              POP      {r4,pc}
;;;83     RTM_EXPORT(rt_device_unregister);
                          ENDP


                          AREA ||i.rt_device_write||, CODE, READONLY, ALIGN=1

                  rt_device_write PROC
;;;369     */
;;;370    rt_size_t rt_device_write(rt_device_t dev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;371                              rt_off_t    pos,
;;;372                              const void *buffer,
;;;373                              rt_size_t   size)
;;;374    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;375        RT_ASSERT(dev != RT_NULL);
;;;376    
;;;377        if (dev->ref_count == 0)
00000c  7ea0              LDRB     r0,[r4,#0x1a]
00000e  b930              CBNZ     r0,|L14.30|
;;;378        {
;;;379            rt_set_errno(-RT_ERROR);
000010  f04f30ff          MOV      r0,#0xffffffff
000014  f7fffffe          BL       rt_set_errno
;;;380            return 0;
000018  2000              MOVS     r0,#0
                  |L14.26|
;;;381        }
;;;382    
;;;383        /* call device write interface */
;;;384        if (dev->write != RT_NULL)
;;;385        {
;;;386            return dev->write(dev, pos, buffer, size);
;;;387        }
;;;388    
;;;389        /* set error code */
;;;390        rt_set_errno(-RT_ENOSYS);
;;;391    
;;;392        return 0;
;;;393    }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L14.30|
00001e  6b60              LDR      r0,[r4,#0x34]         ;384
000020  b138              CBZ      r0,|L14.50|
000022  463b              MOV      r3,r7                 ;386
000024  4632              MOV      r2,r6                 ;386
000026  4629              MOV      r1,r5                 ;386
000028  4620              MOV      r0,r4                 ;386
00002a  f8d4c034          LDR      r12,[r4,#0x34]        ;386
00002e  47e0              BLX      r12                   ;386
000030  e7f3              B        |L14.26|
                  |L14.50|
000032  f06f0005          MVN      r0,#5                 ;390
000036  f7fffffe          BL       rt_set_errno
00003a  2000              MOVS     r0,#0                 ;392
00003c  e7ed              B        |L14.26|
;;;394    RTM_EXPORT(rt_device_write);
                          ENDP


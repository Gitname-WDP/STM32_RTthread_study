; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\mem.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\mem.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\mem.crf ..\rtthread\src\mem.c]
                          THUMB

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;156    
;;;157    static void plug_holes(struct heap_mem *mem)
000000  b530              PUSH     {r4,r5,lr}
;;;158    {
;;;159        struct heap_mem *nmem;
;;;160        struct heap_mem *pmem;
;;;161    
;;;162        RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
;;;163        RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
;;;164        RT_ASSERT(mem->used == 0);
;;;165    
;;;166        /* plug hole forward */
;;;167        nmem = (struct heap_mem *)&heap_ptr[mem->next];
000002  4c1a              LDR      r4,|L1.108|
000004  6843              LDR      r3,[r0,#4]
000006  6824              LDR      r4,[r4,#0]  ; heap_ptr
000008  1919              ADDS     r1,r3,r4
;;;168        if (mem != nmem &&
00000a  4288              CMP      r0,r1
00000c  d015              BEQ      |L1.58|
;;;169            nmem->used == 0 &&
00000e  884b              LDRH     r3,[r1,#2]
000010  b99b              CBNZ     r3,|L1.58|
;;;170            (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
000012  4b17              LDR      r3,|L1.112|
000014  681b              LDR      r3,[r3,#0]  ; heap_end
000016  4299              CMP      r1,r3
000018  d00f              BEQ      |L1.58|
;;;171        {
;;;172            /* if mem->next is unused and not end of heap_ptr,
;;;173             * combine mem and mem->next
;;;174             */
;;;175            if (lfree == nmem)
00001a  4b16              LDR      r3,|L1.116|
00001c  681b              LDR      r3,[r3,#0]  ; lfree
00001e  428b              CMP      r3,r1
000020  d101              BNE      |L1.38|
;;;176            {
;;;177                lfree = mem;
000022  4b14              LDR      r3,|L1.116|
000024  6018              STR      r0,[r3,#0]  ; lfree
                  |L1.38|
;;;178            }
;;;179            mem->next = nmem->next;
000026  684b              LDR      r3,[r1,#4]
000028  6043              STR      r3,[r0,#4]
;;;180            ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
00002a  4b10              LDR      r3,|L1.108|
00002c  681b              LDR      r3,[r3,#0]  ; heap_ptr
00002e  1ac3              SUBS     r3,r0,r3
000030  4d0e              LDR      r5,|L1.108|
000032  684c              LDR      r4,[r1,#4]
000034  682d              LDR      r5,[r5,#0]  ; heap_ptr
000036  442c              ADD      r4,r4,r5
000038  60a3              STR      r3,[r4,#8]
                  |L1.58|
;;;181        }
;;;182    
;;;183        /* plug hole backward */
;;;184        pmem = (struct heap_mem *)&heap_ptr[mem->prev];
00003a  4c0c              LDR      r4,|L1.108|
00003c  6883              LDR      r3,[r0,#8]
00003e  6824              LDR      r4,[r4,#0]  ; heap_ptr
000040  191a              ADDS     r2,r3,r4
;;;185        if (pmem != mem && pmem->used == 0)
000042  4282              CMP      r2,r0
000044  d011              BEQ      |L1.106|
000046  8853              LDRH     r3,[r2,#2]
000048  b97b              CBNZ     r3,|L1.106|
;;;186        {
;;;187            /* if mem->prev is unused, combine mem and mem->prev */
;;;188            if (lfree == mem)
00004a  4b0a              LDR      r3,|L1.116|
00004c  681b              LDR      r3,[r3,#0]  ; lfree
00004e  4283              CMP      r3,r0
000050  d101              BNE      |L1.86|
;;;189            {
;;;190                lfree = pmem;
000052  4b08              LDR      r3,|L1.116|
000054  601a              STR      r2,[r3,#0]  ; lfree
                  |L1.86|
;;;191            }
;;;192            pmem->next = mem->next;
000056  6843              LDR      r3,[r0,#4]
000058  6053              STR      r3,[r2,#4]
;;;193            ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
00005a  4b04              LDR      r3,|L1.108|
00005c  681b              LDR      r3,[r3,#0]  ; heap_ptr
00005e  1ad3              SUBS     r3,r2,r3
000060  4d02              LDR      r5,|L1.108|
000062  6844              LDR      r4,[r0,#4]
000064  682d              LDR      r5,[r5,#0]  ; heap_ptr
000066  442c              ADD      r4,r4,r5
000068  60a3              STR      r3,[r4,#8]
                  |L1.106|
;;;194        }
;;;195    }
00006a  bd30              POP      {r4,r5,pc}
;;;196    
                          ENDP

                  |L1.108|
                          DCD      heap_ptr
                  |L1.112|
                          DCD      heap_end
                  |L1.116|
                          DCD      lfree

                          AREA ||i.rt_calloc||, CODE, READONLY, ALIGN=1

                  rt_calloc PROC
;;;525     */
;;;526    void *rt_calloc(rt_size_t count, rt_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;527    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;528        void *p;
;;;529    
;;;530        RT_DEBUG_NOT_IN_INTERRUPT;
;;;531    
;;;532        /* allocate 'count' objects of size 'size' */
;;;533        p = rt_malloc(count * size);
000006  fb04f005          MUL      r0,r4,r5
00000a  f7fffffe          BL       rt_malloc
00000e  4606              MOV      r6,r0
;;;534    
;;;535        /* zero the memory */
;;;536        if (p)
000010  b12e              CBZ      r6,|L2.30|
;;;537            rt_memset(p, 0, count * size);
000012  fb04f205          MUL      r2,r4,r5
000016  2100              MOVS     r1,#0
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       rt_memset
                  |L2.30|
;;;538    
;;;539        return p;
00001e  4630              MOV      r0,r6
;;;540    }
000020  bd70              POP      {r4-r6,pc}
;;;541    RTM_EXPORT(rt_calloc);
                          ENDP


                          AREA ||i.rt_free||, CODE, READONLY, ALIGN=2

                  rt_free PROC
;;;548     */
;;;549    void rt_free(void *rmem)
000000  b570              PUSH     {r4-r6,lr}
;;;550    {
000002  4605              MOV      r5,r0
;;;551        struct heap_mem *mem;
;;;552    
;;;553        RT_DEBUG_NOT_IN_INTERRUPT;
;;;554    
;;;555        if (rmem == RT_NULL)
000004  b905              CBNZ     r5,|L3.8|
                  |L3.6|
;;;556            return;
;;;557        RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE - 1)) == 0);
;;;558        RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
;;;559                  (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);
;;;560    
;;;561        RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
;;;562    
;;;563        if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
;;;564            (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
;;;565        {
;;;566            RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));
;;;567    
;;;568            return;
;;;569        }
;;;570    
;;;571        /* Get the corresponding struct heap_mem ... */
;;;572        mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;573    
;;;574        RT_DEBUG_LOG(RT_DEBUG_MEM,
;;;575                     ("release memory 0x%x, size: %d\n",
;;;576                      (rt_uint32_t)rmem,
;;;577                      (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
;;;578    
;;;579    
;;;580        /* protect the heap from concurrent access */
;;;581        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;582    
;;;583        /* ... which has to be in a used state ... */
;;;584        if (!mem->used || mem->magic != HEAP_MAGIC)
;;;585        {
;;;586            rt_kprintf("to free a bad data block:\n");
;;;587            rt_kprintf("mem: 0x%08x, used flag: %d, magic code: 0x%04x\n", mem, mem->used, mem->magic);
;;;588        }
;;;589        RT_ASSERT(mem->used);
;;;590        RT_ASSERT(mem->magic == HEAP_MAGIC);
;;;591        /* ... and is now unused. */
;;;592        mem->used  = 0;
;;;593        mem->magic = HEAP_MAGIC;
;;;594    #ifdef RT_USING_MEMTRACE
;;;595        rt_mem_setname(mem, "    ");
;;;596    #endif
;;;597    
;;;598        if (mem < lfree)
;;;599        {
;;;600            /* the newly freed struct is now the lowest */
;;;601            lfree = mem;
;;;602        }
;;;603    
;;;604    #ifdef RT_MEM_STATS
;;;605        used_mem -= (mem->next - ((rt_uint8_t *)mem - heap_ptr));
;;;606    #endif
;;;607    
;;;608        /* finally, see if prev or next are free also */
;;;609        plug_holes(mem);
;;;610        rt_sem_release(&heap_sem);
;;;611    }
000006  bd70              POP      {r4-r6,pc}
                  |L3.8|
000008  481d              LDR      r0,|L3.128|
00000a  6800              LDR      r0,[r0,#0]            ;563  ; heap_ptr
00000c  4285              CMP      r5,r0                 ;563
00000e  d303              BCC      |L3.24|
000010  481c              LDR      r0,|L3.132|
000012  6800              LDR      r0,[r0,#0]            ;564  ; heap_end
000014  4285              CMP      r5,r0                 ;564
000016  d300              BCC      |L3.26|
                  |L3.24|
000018  e7f5              B        |L3.6|
                  |L3.26|
00001a  f1a5040c          SUB      r4,r5,#0xc            ;572
00001e  f04f31ff          MOV      r1,#0xffffffff        ;581
000022  4819              LDR      r0,|L3.136|
000024  f7fffffe          BL       rt_sem_take
000028  8860              LDRH     r0,[r4,#2]            ;584
00002a  b118              CBZ      r0,|L3.52|
00002c  8820              LDRH     r0,[r4,#0]            ;584
00002e  f5b05ff5          CMP      r0,#0x1ea0            ;584
000032  d008              BEQ      |L3.70|
                  |L3.52|
000034  a015              ADR      r0,|L3.140|
000036  f7fffffe          BL       rt_kprintf
00003a  8823              LDRH     r3,[r4,#0]            ;587
00003c  8862              LDRH     r2,[r4,#2]            ;587
00003e  4621              MOV      r1,r4                 ;587
000040  a019              ADR      r0,|L3.168|
000042  f7fffffe          BL       rt_kprintf
                  |L3.70|
000046  2000              MOVS     r0,#0                 ;592
000048  8060              STRH     r0,[r4,#2]            ;592
00004a  f44f50f5          MOV      r0,#0x1ea0            ;593
00004e  8020              STRH     r0,[r4,#0]            ;593
000050  4821              LDR      r0,|L3.216|
000052  6800              LDR      r0,[r0,#0]            ;598  ; lfree
000054  4284              CMP      r4,r0                 ;598
000056  d201              BCS      |L3.92|
000058  481f              LDR      r0,|L3.216|
00005a  6004              STR      r4,[r0,#0]            ;601  ; lfree
                  |L3.92|
00005c  4908              LDR      r1,|L3.128|
00005e  6860              LDR      r0,[r4,#4]            ;605
000060  6809              LDR      r1,[r1,#0]            ;605  ; heap_ptr
000062  1a61              SUBS     r1,r4,r1              ;605
000064  1a40              SUBS     r0,r0,r1              ;605
000066  491d              LDR      r1,|L3.220|
000068  6809              LDR      r1,[r1,#0]            ;605  ; used_mem
00006a  1a08              SUBS     r0,r1,r0              ;605
00006c  491b              LDR      r1,|L3.220|
00006e  6008              STR      r0,[r1,#0]            ;605  ; used_mem
000070  4620              MOV      r0,r4                 ;609
000072  f7fffffe          BL       plug_holes
000076  4804              LDR      r0,|L3.136|
000078  f7fffffe          BL       rt_sem_release
00007c  bf00              NOP      
00007e  e7c2              B        |L3.6|
;;;612    RTM_EXPORT(rt_free);
                          ENDP

                  |L3.128|
                          DCD      heap_ptr
                  |L3.132|
                          DCD      heap_end
                  |L3.136|
                          DCD      heap_sem
                  |L3.140|
00008c  746f2066          DCB      "to free a bad data block:\n",0
000090  72656520
000094  61206261
000098  64206461
00009c  74612062
0000a0  6c6f636b
0000a4  3a0a00  
0000a7  00                DCB      0
                  |L3.168|
0000a8  6d656d3a          DCB      "mem: 0x%08x, used flag: %d, magic code: 0x%04x\n",0
0000ac  20307825
0000b0  3038782c
0000b4  20757365
0000b8  6420666c
0000bc  61673a20
0000c0  25642c20
0000c4  6d616769
0000c8  6320636f
0000cc  64653a20
0000d0  30782530
0000d4  34780a00
                  |L3.216|
                          DCD      lfree
                  |L3.220|
                          DCD      used_mem

                          AREA ||i.rt_malloc||, CODE, READONLY, ALIGN=2

                  rt_malloc PROC
;;;272     */
;;;273    void *rt_malloc(rt_size_t size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;274    {
000004  4605              MOV      r5,r0
;;;275        rt_size_t ptr, ptr2;
;;;276        struct heap_mem *mem, *mem2;
;;;277    
;;;278        RT_DEBUG_NOT_IN_INTERRUPT;
;;;279    
;;;280        if (size == 0)
000006  b915              CBNZ     r5,|L4.14|
;;;281            return RT_NULL;
000008  2000              MOVS     r0,#0
                  |L4.10|
;;;282    
;;;283        if (size != RT_ALIGN(size, RT_ALIGN_SIZE))
;;;284            RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d, but align to %d\n",
;;;285                                        size, RT_ALIGN(size, RT_ALIGN_SIZE)));
;;;286        else
;;;287            RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));
;;;288    
;;;289        /* alignment size */
;;;290        size = RT_ALIGN(size, RT_ALIGN_SIZE);
;;;291    
;;;292        if (size > mem_size_aligned)
;;;293        {
;;;294            RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));
;;;295    
;;;296            return RT_NULL;
;;;297        }
;;;298    
;;;299        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;300        if (size < MIN_SIZE_ALIGNED)
;;;301            size = MIN_SIZE_ALIGNED;
;;;302    
;;;303        /* take memory semaphore */
;;;304        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;305    
;;;306        for (ptr = (rt_uint8_t *)lfree - heap_ptr;
;;;307             ptr < mem_size_aligned - size;
;;;308             ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
;;;309        {
;;;310            mem = (struct heap_mem *)&heap_ptr[ptr];
;;;311    
;;;312            if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
;;;313            {
;;;314                /* mem is not used and at least perfect fit is possible:
;;;315                 * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;316    
;;;317                if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
;;;318                    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
;;;319                {
;;;320                    /* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing
;;;321                     * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;322                     * -> split large block, create empty remainder,
;;;323                     * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;324                     * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;325                     * struct heap_mem would fit in but no data between mem2 and mem2->next
;;;326                     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;327                     *       region that couldn't hold data, but when mem->next gets freed,
;;;328                     *       the 2 regions would be combined, resulting in more free memory
;;;329                     */
;;;330                    ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;331    
;;;332                    /* create mem2 struct */
;;;333                    mem2       = (struct heap_mem *)&heap_ptr[ptr2];
;;;334                    mem2->magic = HEAP_MAGIC;
;;;335                    mem2->used = 0;
;;;336                    mem2->next = mem->next;
;;;337                    mem2->prev = ptr;
;;;338    #ifdef RT_USING_MEMTRACE
;;;339                    rt_mem_setname(mem2, "    ");
;;;340    #endif
;;;341    
;;;342                    /* and insert it between mem and mem->next */
;;;343                    mem->next = ptr2;
;;;344                    mem->used = 1;
;;;345    
;;;346                    if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
;;;347                    {
;;;348                        ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
;;;349                    }
;;;350    #ifdef RT_MEM_STATS
;;;351                    used_mem += (size + SIZEOF_STRUCT_MEM);
;;;352                    if (max_mem < used_mem)
;;;353                        max_mem = used_mem;
;;;354    #endif
;;;355                }
;;;356                else
;;;357                {
;;;358                    /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;359                     * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;360                     * take care of this).
;;;361                     * -> near fit or excact fit: do not split, no mem2 creation
;;;362                     * also can't move mem->next directly behind mem, since mem->next
;;;363                     * will always be used at this point!
;;;364                     */
;;;365                    mem->used = 1;
;;;366    #ifdef RT_MEM_STATS
;;;367                    used_mem += mem->next - ((rt_uint8_t *)mem - heap_ptr);
;;;368                    if (max_mem < used_mem)
;;;369                        max_mem = used_mem;
;;;370    #endif
;;;371                }
;;;372                /* set memory block magic */
;;;373                mem->magic = HEAP_MAGIC;
;;;374    #ifdef RT_USING_MEMTRACE
;;;375                if (rt_thread_self())
;;;376                    rt_mem_setname(mem, rt_thread_self()->name);
;;;377                else
;;;378                    rt_mem_setname(mem, "NONE");
;;;379    #endif
;;;380    
;;;381                if (mem == lfree)
;;;382                {
;;;383                    /* Find next free block after mem and update lowest free pointer */
;;;384                    while (lfree->used && lfree != heap_end)
;;;385                        lfree = (struct heap_mem *)&heap_ptr[lfree->next];
;;;386    
;;;387                    RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
;;;388                }
;;;389    
;;;390                rt_sem_release(&heap_sem);
;;;391                RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
;;;392                RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
;;;393                RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE - 1)) == 0);
;;;394    
;;;395                RT_DEBUG_LOG(RT_DEBUG_MEM,
;;;396                             ("allocate memory at 0x%x, size: %d\n",
;;;397                              (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
;;;398                              (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
;;;399    
;;;400                RT_OBJECT_HOOK_CALL(rt_malloc_hook,
;;;401                                    (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));
;;;402    
;;;403                /* return the memory data except mem struct */
;;;404                return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
;;;405            }
;;;406        }
;;;407    
;;;408        rt_sem_release(&heap_sem);
;;;409    
;;;410        return RT_NULL;
;;;411    }
00000a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.14|
00000e  1ce8              ADDS     r0,r5,#3              ;290
000010  f0200503          BIC      r5,r0,#3              ;290
000014  484e              LDR      r0,|L4.336|
000016  6800              LDR      r0,[r0,#0]            ;292  ; mem_size_aligned
000018  4285              CMP      r5,r0                 ;292
00001a  d901              BLS      |L4.32|
00001c  2000              MOVS     r0,#0                 ;296
00001e  e7f4              B        |L4.10|
                  |L4.32|
000020  2d0c              CMP      r5,#0xc               ;300
000022  d200              BCS      |L4.38|
000024  250c              MOVS     r5,#0xc               ;301
                  |L4.38|
000026  f04f31ff          MOV      r1,#0xffffffff        ;304
00002a  484a              LDR      r0,|L4.340|
00002c  f7fffffe          BL       rt_sem_take
000030  4849              LDR      r0,|L4.344|
000032  6800              LDR      r0,[r0,#0]            ;306  ; lfree
000034  4949              LDR      r1,|L4.348|
000036  6809              LDR      r1,[r1,#0]            ;306  ; heap_ptr
000038  1a46              SUBS     r6,r0,r1              ;306
00003a  e07e              B        |L4.314|
                  |L4.60|
00003c  4847              LDR      r0,|L4.348|
00003e  6800              LDR      r0,[r0,#0]            ;310  ; heap_ptr
000040  1984              ADDS     r4,r0,r6              ;310
000042  8860              LDRH     r0,[r4,#2]            ;312
000044  2800              CMP      r0,#0                 ;312
000046  d174              BNE      |L4.306|
000048  f106000c          ADD      r0,r6,#0xc            ;312
00004c  6861              LDR      r1,[r4,#4]            ;312
00004e  1a08              SUBS     r0,r1,r0              ;312
000050  42a8              CMP      r0,r5                 ;312
000052  d36e              BCC      |L4.306|
000054  f106000c          ADD      r0,r6,#0xc            ;317
000058  6861              LDR      r1,[r4,#4]            ;317
00005a  1a09              SUBS     r1,r1,r0              ;317
00005c  f1050018          ADD      r0,r5,#0x18           ;317
000060  4281              CMP      r1,r0                 ;317
000062  d330              BCC      |L4.198|
000064  f106000c          ADD      r0,r6,#0xc            ;330
000068  eb000805          ADD      r8,r0,r5              ;330
00006c  483b              LDR      r0,|L4.348|
00006e  6800              LDR      r0,[r0,#0]            ;333  ; heap_ptr
000070  eb000708          ADD      r7,r0,r8              ;333
000074  f44f50f5          MOV      r0,#0x1ea0            ;334
000078  8038              STRH     r0,[r7,#0]            ;334
00007a  2000              MOVS     r0,#0                 ;335
00007c  8078              STRH     r0,[r7,#2]            ;335
00007e  6860              LDR      r0,[r4,#4]            ;336
000080  6078              STR      r0,[r7,#4]            ;336
000082  60be              STR      r6,[r7,#8]            ;337
000084  f8c48004          STR      r8,[r4,#4]            ;343
000088  2001              MOVS     r0,#1                 ;344
00008a  8060              STRH     r0,[r4,#2]            ;344
00008c  4830              LDR      r0,|L4.336|
00008e  6879              LDR      r1,[r7,#4]            ;346
000090  6800              LDR      r0,[r0,#0]            ;346  ; mem_size_aligned
000092  300c              ADDS     r0,r0,#0xc            ;346
000094  4281              CMP      r1,r0                 ;346
000096  d005              BEQ      |L4.164|
000098  4930              LDR      r1,|L4.348|
00009a  6878              LDR      r0,[r7,#4]            ;348
00009c  6809              LDR      r1,[r1,#0]            ;348  ; heap_ptr
00009e  4408              ADD      r0,r0,r1              ;348
0000a0  f8c08008          STR      r8,[r0,#8]            ;348
                  |L4.164|
0000a4  482e              LDR      r0,|L4.352|
0000a6  6801              LDR      r1,[r0,#0]            ;351  ; used_mem
0000a8  f105000c          ADD      r0,r5,#0xc            ;351
0000ac  4408              ADD      r0,r0,r1              ;351
0000ae  492c              LDR      r1,|L4.352|
0000b0  6008              STR      r0,[r1,#0]            ;351  ; used_mem
0000b2  482c              LDR      r0,|L4.356|
0000b4  6800              LDR      r0,[r0,#0]            ;352  ; max_mem
0000b6  6809              LDR      r1,[r1,#0]            ;352  ; used_mem
0000b8  4288              CMP      r0,r1                 ;352
0000ba  d219              BCS      |L4.240|
0000bc  4828              LDR      r0,|L4.352|
0000be  6800              LDR      r0,[r0,#0]            ;353  ; used_mem
0000c0  4928              LDR      r1,|L4.356|
0000c2  6008              STR      r0,[r1,#0]            ;353  ; max_mem
0000c4  e014              B        |L4.240|
                  |L4.198|
0000c6  2001              MOVS     r0,#1                 ;365
0000c8  8060              STRH     r0,[r4,#2]            ;365
0000ca  4924              LDR      r1,|L4.348|
0000cc  6860              LDR      r0,[r4,#4]            ;367
0000ce  6809              LDR      r1,[r1,#0]            ;367  ; heap_ptr
0000d0  1a61              SUBS     r1,r4,r1              ;367
0000d2  1a40              SUBS     r0,r0,r1              ;367
0000d4  4922              LDR      r1,|L4.352|
0000d6  6809              LDR      r1,[r1,#0]            ;367  ; used_mem
0000d8  4408              ADD      r0,r0,r1              ;367
0000da  4921              LDR      r1,|L4.352|
0000dc  6008              STR      r0,[r1,#0]            ;367  ; used_mem
0000de  4821              LDR      r0,|L4.356|
0000e0  6800              LDR      r0,[r0,#0]            ;368  ; max_mem
0000e2  6809              LDR      r1,[r1,#0]            ;368  ; used_mem
0000e4  4288              CMP      r0,r1                 ;368
0000e6  d203              BCS      |L4.240|
0000e8  481d              LDR      r0,|L4.352|
0000ea  6800              LDR      r0,[r0,#0]            ;369  ; used_mem
0000ec  491d              LDR      r1,|L4.356|
0000ee  6008              STR      r0,[r1,#0]            ;369  ; max_mem
                  |L4.240|
0000f0  f44f50f5          MOV      r0,#0x1ea0            ;373
0000f4  8020              STRH     r0,[r4,#0]            ;373
0000f6  4818              LDR      r0,|L4.344|
0000f8  6800              LDR      r0,[r0,#0]            ;381  ; lfree
0000fa  4284              CMP      r4,r0                 ;381
0000fc  d112              BNE      |L4.292|
0000fe  e007              B        |L4.272|
                  |L4.256|
000100  4815              LDR      r0,|L4.344|
000102  6800              LDR      r0,[r0,#0]            ;385  ; lfree
000104  6840              LDR      r0,[r0,#4]            ;385
000106  4915              LDR      r1,|L4.348|
000108  6809              LDR      r1,[r1,#0]            ;385  ; heap_ptr
00010a  4408              ADD      r0,r0,r1              ;385
00010c  4912              LDR      r1,|L4.344|
00010e  6008              STR      r0,[r1,#0]            ;385  ; lfree
                  |L4.272|
000110  4811              LDR      r0,|L4.344|
000112  6800              LDR      r0,[r0,#0]            ;384  ; lfree
000114  8840              LDRH     r0,[r0,#2]            ;384
000116  b128              CBZ      r0,|L4.292|
000118  480f              LDR      r0,|L4.344|
00011a  6800              LDR      r0,[r0,#0]            ;384  ; lfree
00011c  4912              LDR      r1,|L4.360|
00011e  6809              LDR      r1,[r1,#0]            ;384  ; heap_end
000120  4288              CMP      r0,r1                 ;384
000122  d1ed              BNE      |L4.256|
                  |L4.292|
000124  480b              LDR      r0,|L4.340|
000126  f7fffffe          BL       rt_sem_release
00012a  f104000c          ADD      r0,r4,#0xc            ;404
00012e  e76c              B        |L4.10|
000130  e7ff              B        |L4.306|
                  |L4.306|
000132  480a              LDR      r0,|L4.348|
000134  6800              LDR      r0,[r0,#0]            ;308  ; heap_ptr
000136  4430              ADD      r0,r0,r6              ;308
000138  6846              LDR      r6,[r0,#4]            ;308
                  |L4.314|
00013a  4805              LDR      r0,|L4.336|
00013c  6800              LDR      r0,[r0,#0]            ;307  ; mem_size_aligned
00013e  1b40              SUBS     r0,r0,r5              ;307
000140  42b0              CMP      r0,r6                 ;307
000142  f63faf7b          BHI      |L4.60|
000146  4803              LDR      r0,|L4.340|
000148  f7fffffe          BL       rt_sem_release
00014c  2000              MOVS     r0,#0                 ;410
00014e  e75c              B        |L4.10|
;;;412    RTM_EXPORT(rt_malloc);
                          ENDP

                  |L4.336|
                          DCD      mem_size_aligned
                  |L4.340|
                          DCD      heap_sem
                  |L4.344|
                          DCD      lfree
                  |L4.348|
                          DCD      heap_ptr
                  |L4.352|
                          DCD      used_mem
                  |L4.356|
                          DCD      max_mem
                  |L4.360|
                          DCD      heap_end

                          AREA ||i.rt_memory_info||, CODE, READONLY, ALIGN=2

                  rt_memory_info PROC
;;;614    #ifdef RT_MEM_STATS
;;;615    void rt_memory_info(rt_uint32_t *total,
000000  b110              CBZ      r0,|L5.8|
;;;616                        rt_uint32_t *used,
;;;617                        rt_uint32_t *max_used)
;;;618    {
;;;619        if (total != RT_NULL)
;;;620            *total = mem_size_aligned;
000002  4b06              LDR      r3,|L5.28|
000004  681b              LDR      r3,[r3,#0]  ; mem_size_aligned
000006  6003              STR      r3,[r0,#0]
                  |L5.8|
;;;621        if (used  != RT_NULL)
000008  b111              CBZ      r1,|L5.16|
;;;622            *used = used_mem;
00000a  4b05              LDR      r3,|L5.32|
00000c  681b              LDR      r3,[r3,#0]  ; used_mem
00000e  600b              STR      r3,[r1,#0]
                  |L5.16|
;;;623        if (max_used != RT_NULL)
000010  b112              CBZ      r2,|L5.24|
;;;624            *max_used = max_mem;
000012  4b04              LDR      r3,|L5.36|
000014  681b              LDR      r3,[r3,#0]  ; max_mem
000016  6013              STR      r3,[r2,#0]
                  |L5.24|
;;;625    }
000018  4770              BX       lr
;;;626    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      mem_size_aligned
                  |L5.32|
                          DCD      used_mem
                  |L5.36|
                          DCD      max_mem

                          AREA ||i.rt_realloc||, CODE, READONLY, ALIGN=2

                  rt_realloc PROC
;;;421     */
;;;422    void *rt_realloc(void *rmem, rt_size_t newsize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;423    {
000004  4606              MOV      r6,r0
000006  460c              MOV      r4,r1
;;;424        rt_size_t size;
;;;425        rt_size_t ptr, ptr2;
;;;426        struct heap_mem *mem, *mem2;
;;;427        void *nmem;
;;;428    
;;;429        RT_DEBUG_NOT_IN_INTERRUPT;
;;;430    
;;;431        /* alignment size */
;;;432        newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
000008  1ce0              ADDS     r0,r4,#3
00000a  f0200403          BIC      r4,r0,#3
;;;433        if (newsize > mem_size_aligned)
00000e  4841              LDR      r0,|L6.276|
000010  6800              LDR      r0,[r0,#0]  ; mem_size_aligned
000012  4284              CMP      r4,r0
000014  d902              BLS      |L6.28|
;;;434        {
;;;435            RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));
;;;436    
;;;437            return RT_NULL;
000016  2000              MOVS     r0,#0
                  |L6.24|
;;;438        }
;;;439        else if (newsize == 0)
;;;440        {
;;;441            rt_free(rmem);
;;;442            return RT_NULL;
;;;443        }
;;;444    
;;;445        /* allocate a new memory block */
;;;446        if (rmem == RT_NULL)
;;;447            return rt_malloc(newsize);
;;;448    
;;;449        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;450    
;;;451        if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
;;;452            (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
;;;453        {
;;;454            /* illegal memory */
;;;455            rt_sem_release(&heap_sem);
;;;456    
;;;457            return rmem;
;;;458        }
;;;459    
;;;460        mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;461    
;;;462        ptr = (rt_uint8_t *)mem - heap_ptr;
;;;463        size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;464        if (size == newsize)
;;;465        {
;;;466            /* the size is the same as */
;;;467            rt_sem_release(&heap_sem);
;;;468    
;;;469            return rmem;
;;;470        }
;;;471    
;;;472        if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
;;;473        {
;;;474            /* split memory block */
;;;475    #ifdef RT_MEM_STATS
;;;476            used_mem -= (size - newsize);
;;;477    #endif
;;;478    
;;;479            ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;480            mem2 = (struct heap_mem *)&heap_ptr[ptr2];
;;;481            mem2->magic = HEAP_MAGIC;
;;;482            mem2->used = 0;
;;;483            mem2->next = mem->next;
;;;484            mem2->prev = ptr;
;;;485    #ifdef RT_USING_MEMTRACE
;;;486            rt_mem_setname(mem2, "    ");
;;;487    #endif
;;;488            mem->next = ptr2;
;;;489            if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
;;;490            {
;;;491                ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
;;;492            }
;;;493    
;;;494            plug_holes(mem2);
;;;495    
;;;496            rt_sem_release(&heap_sem);
;;;497    
;;;498            return rmem;
;;;499        }
;;;500        rt_sem_release(&heap_sem);
;;;501    
;;;502        /* expand memory */
;;;503        nmem = rt_malloc(newsize);
;;;504        if (nmem != RT_NULL) /* check memory */
;;;505        {
;;;506            rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
;;;507            rt_free(rmem);
;;;508        }
;;;509    
;;;510        return nmem;
;;;511    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L6.28|
00001c  b924              CBNZ     r4,|L6.40|
00001e  4630              MOV      r0,r6                 ;441
000020  f7fffffe          BL       rt_free
000024  2000              MOVS     r0,#0                 ;442
000026  e7f7              B        |L6.24|
                  |L6.40|
000028  b91e              CBNZ     r6,|L6.50|
00002a  4620              MOV      r0,r4                 ;447
00002c  f7fffffe          BL       rt_malloc
000030  e7f2              B        |L6.24|
                  |L6.50|
000032  f04f31ff          MOV      r1,#0xffffffff        ;449
000036  4838              LDR      r0,|L6.280|
000038  f7fffffe          BL       rt_sem_take
00003c  4837              LDR      r0,|L6.284|
00003e  6800              LDR      r0,[r0,#0]            ;451  ; heap_ptr
000040  4286              CMP      r6,r0                 ;451
000042  d303              BCC      |L6.76|
000044  4836              LDR      r0,|L6.288|
000046  6800              LDR      r0,[r0,#0]            ;452  ; heap_end
000048  4286              CMP      r6,r0                 ;452
00004a  d304              BCC      |L6.86|
                  |L6.76|
00004c  4832              LDR      r0,|L6.280|
00004e  f7fffffe          BL       rt_sem_release
000052  4630              MOV      r0,r6                 ;457
000054  e7e0              B        |L6.24|
                  |L6.86|
000056  f1a6080c          SUB      r8,r6,#0xc            ;460
00005a  4830              LDR      r0,|L6.284|
00005c  6800              LDR      r0,[r0,#0]            ;462  ; heap_ptr
00005e  eba80900          SUB      r9,r8,r0              ;462
000062  f8d80004          LDR      r0,[r8,#4]            ;463
000066  eba00009          SUB      r0,r0,r9              ;463
00006a  f1a0070c          SUB      r7,r0,#0xc            ;463
00006e  42a7              CMP      r7,r4                 ;464
000070  d104              BNE      |L6.124|
000072  4829              LDR      r0,|L6.280|
000074  f7fffffe          BL       rt_sem_release
000078  4630              MOV      r0,r6                 ;469
00007a  e7cd              B        |L6.24|
                  |L6.124|
00007c  f1040018          ADD      r0,r4,#0x18           ;472
000080  42b8              CMP      r0,r7                 ;472
000082  d22d              BCS      |L6.224|
000084  1b38              SUBS     r0,r7,r4              ;476
000086  4927              LDR      r1,|L6.292|
000088  6809              LDR      r1,[r1,#0]            ;476  ; used_mem
00008a  1a08              SUBS     r0,r1,r0              ;476
00008c  4925              LDR      r1,|L6.292|
00008e  6008              STR      r0,[r1,#0]            ;476  ; used_mem
000090  f109000c          ADD      r0,r9,#0xc            ;479
000094  eb000a04          ADD      r10,r0,r4             ;479
000098  4820              LDR      r0,|L6.284|
00009a  6800              LDR      r0,[r0,#0]            ;480  ; heap_ptr
00009c  eb00050a          ADD      r5,r0,r10             ;480
0000a0  f44f50f5          MOV      r0,#0x1ea0            ;481
0000a4  8028              STRH     r0,[r5,#0]            ;481
0000a6  2000              MOVS     r0,#0                 ;482
0000a8  8068              STRH     r0,[r5,#2]            ;482
0000aa  f8d80004          LDR      r0,[r8,#4]            ;483
0000ae  6068              STR      r0,[r5,#4]            ;483
0000b0  f8c59008          STR      r9,[r5,#8]            ;484
0000b4  f8c8a004          STR      r10,[r8,#4]           ;488
0000b8  4816              LDR      r0,|L6.276|
0000ba  6869              LDR      r1,[r5,#4]            ;489
0000bc  6800              LDR      r0,[r0,#0]            ;489  ; mem_size_aligned
0000be  300c              ADDS     r0,r0,#0xc            ;489
0000c0  4281              CMP      r1,r0                 ;489
0000c2  d005              BEQ      |L6.208|
0000c4  4915              LDR      r1,|L6.284|
0000c6  6868              LDR      r0,[r5,#4]            ;491
0000c8  6809              LDR      r1,[r1,#0]            ;491  ; heap_ptr
0000ca  4408              ADD      r0,r0,r1              ;491
0000cc  f8c0a008          STR      r10,[r0,#8]           ;491
                  |L6.208|
0000d0  4628              MOV      r0,r5                 ;494
0000d2  f7fffffe          BL       plug_holes
0000d6  4810              LDR      r0,|L6.280|
0000d8  f7fffffe          BL       rt_sem_release
0000dc  4630              MOV      r0,r6                 ;498
0000de  e79b              B        |L6.24|
                  |L6.224|
0000e0  480d              LDR      r0,|L6.280|
0000e2  f7fffffe          BL       rt_sem_release
0000e6  4620              MOV      r0,r4                 ;503
0000e8  f7fffffe          BL       rt_malloc
0000ec  4683              MOV      r11,r0                ;503
0000ee  f1bb0f00          CMP      r11,#0                ;504
0000f2  d00c              BEQ      |L6.270|
0000f4  42a7              CMP      r7,r4                 ;506
0000f6  d201              BCS      |L6.252|
0000f8  4638              MOV      r0,r7                 ;506
0000fa  e000              B        |L6.254|
                  |L6.252|
0000fc  4620              MOV      r0,r4                 ;506
                  |L6.254|
0000fe  4602              MOV      r2,r0                 ;506
000100  4631              MOV      r1,r6                 ;506
000102  4658              MOV      r0,r11                ;506
000104  f7fffffe          BL       rt_memcpy
000108  4630              MOV      r0,r6                 ;507
00010a  f7fffffe          BL       rt_free
                  |L6.270|
00010e  4658              MOV      r0,r11                ;510
000110  e782              B        |L6.24|
;;;512    RTM_EXPORT(rt_realloc);
                          ENDP

000112  0000              DCW      0x0000
                  |L6.276|
                          DCD      mem_size_aligned
                  |L6.280|
                          DCD      heap_sem
                  |L6.284|
                          DCD      heap_ptr
                  |L6.288|
                          DCD      heap_end
                  |L6.292|
                          DCD      used_mem

                          AREA ||i.rt_system_heap_init||, CODE, READONLY, ALIGN=2

                  rt_system_heap_init PROC
;;;204     */
;;;205    void rt_system_heap_init(void *begin_addr, void *end_addr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;206    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;207        struct heap_mem *mem;
;;;208        rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
000008  1ce8              ADDS     r0,r5,#3
00000a  f0200703          BIC      r7,r0,#3
;;;209        rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
00000e  f0260803          BIC      r8,r6,#3
;;;210    
;;;211        RT_DEBUG_NOT_IN_INTERRUPT;
;;;212    
;;;213        /* alignment addr */
;;;214        if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
000012  f1b80f18          CMP      r8,#0x18
000016  d909              BLS      |L7.44|
;;;215            ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
000018  f1a80018          SUB      r0,r8,#0x18
00001c  42b8              CMP      r0,r7
00001e  d305              BCC      |L7.44|
;;;216        {
;;;217            /* calculate the aligned memory size */
;;;218            mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
000020  eba80007          SUB      r0,r8,r7
000024  3818              SUBS     r0,r0,#0x18
000026  491e              LDR      r1,|L7.160|
000028  6008              STR      r0,[r1,#0]  ; mem_size_aligned
00002a  e006              B        |L7.58|
                  |L7.44|
;;;219        }
;;;220        else
;;;221        {
;;;222            rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
00002c  4632              MOV      r2,r6
00002e  4629              MOV      r1,r5
000030  a01c              ADR      r0,|L7.164|
000032  f7fffffe          BL       rt_kprintf
                  |L7.54|
;;;223                       (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);
;;;224    
;;;225            return;
;;;226        }
;;;227    
;;;228        /* point to begin address of heap */
;;;229        heap_ptr = (rt_uint8_t *)begin_align;
;;;230    
;;;231        RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
;;;232                                    (rt_uint32_t)heap_ptr, mem_size_aligned));
;;;233    
;;;234        /* initialize the start of the heap */
;;;235        mem        = (struct heap_mem *)heap_ptr;
;;;236        mem->magic = HEAP_MAGIC;
;;;237        mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;238        mem->prev  = 0;
;;;239        mem->used  = 0;
;;;240    #ifdef RT_USING_MEMTRACE
;;;241        rt_mem_setname(mem, "INIT");
;;;242    #endif
;;;243    
;;;244        /* initialize the end of the heap */
;;;245        heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
;;;246        heap_end->magic = HEAP_MAGIC;
;;;247        heap_end->used  = 1;
;;;248        heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;249        heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;250    #ifdef RT_USING_MEMTRACE
;;;251        rt_mem_setname(heap_end, "INIT");
;;;252    #endif
;;;253    
;;;254        rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
;;;255    
;;;256        /* initialize the lowest-free pointer to the start of the heap */
;;;257        lfree = (struct heap_mem *)heap_ptr;
;;;258    }
000036  e8bd81f0          POP      {r4-r8,pc}
                  |L7.58|
00003a  4829              LDR      r0,|L7.224|
00003c  6007              STR      r7,[r0,#0]            ;229  ; heap_ptr
00003e  6804              LDR      r4,[r0,#0]            ;235  ; heap_ptr
000040  f44f50f5          MOV      r0,#0x1ea0            ;236
000044  8020              STRH     r0,[r4,#0]            ;236
000046  4816              LDR      r0,|L7.160|
000048  6800              LDR      r0,[r0,#0]            ;237  ; mem_size_aligned
00004a  300c              ADDS     r0,r0,#0xc            ;237
00004c  6060              STR      r0,[r4,#4]            ;237
00004e  2000              MOVS     r0,#0                 ;238
000050  60a0              STR      r0,[r4,#8]            ;238
000052  8060              STRH     r0,[r4,#2]            ;239
000054  4922              LDR      r1,|L7.224|
000056  6860              LDR      r0,[r4,#4]            ;245
000058  6809              LDR      r1,[r1,#0]            ;245  ; heap_ptr
00005a  4408              ADD      r0,r0,r1              ;245
00005c  4921              LDR      r1,|L7.228|
00005e  6008              STR      r0,[r1,#0]            ;245  ; heap_end
000060  f44f50f5          MOV      r0,#0x1ea0            ;246
000064  6809              LDR      r1,[r1,#0]            ;246  ; heap_end
000066  8008              STRH     r0,[r1,#0]            ;246
000068  2001              MOVS     r0,#1                 ;247
00006a  491e              LDR      r1,|L7.228|
00006c  6809              LDR      r1,[r1,#0]            ;247  ; heap_end
00006e  8048              STRH     r0,[r1,#2]            ;247
000070  480b              LDR      r0,|L7.160|
000072  6800              LDR      r0,[r0,#0]            ;248  ; mem_size_aligned
000074  300c              ADDS     r0,r0,#0xc            ;248
000076  491b              LDR      r1,|L7.228|
000078  6809              LDR      r1,[r1,#0]            ;248  ; heap_end
00007a  6048              STR      r0,[r1,#4]            ;248
00007c  4808              LDR      r0,|L7.160|
00007e  6800              LDR      r0,[r0,#0]            ;249  ; mem_size_aligned
000080  300c              ADDS     r0,r0,#0xc            ;249
000082  4918              LDR      r1,|L7.228|
000084  6809              LDR      r1,[r1,#0]            ;249  ; heap_end
000086  6088              STR      r0,[r1,#8]            ;249
000088  2300              MOVS     r3,#0                 ;254
00008a  2201              MOVS     r2,#1                 ;254
00008c  a116              ADR      r1,|L7.232|
00008e  4818              LDR      r0,|L7.240|
000090  f7fffffe          BL       rt_sem_init
000094  4812              LDR      r0,|L7.224|
000096  6800              LDR      r0,[r0,#0]            ;257  ; heap_ptr
000098  4916              LDR      r1,|L7.244|
00009a  6008              STR      r0,[r1,#0]            ;257  ; lfree
00009c  bf00              NOP      
00009e  e7ca              B        |L7.54|
;;;259    
                          ENDP

                  |L7.160|
                          DCD      mem_size_aligned
                  |L7.164|
0000a4  6d656d20          DCB      "mem init, error begin address 0x%x, and end address 0x%"
0000a8  696e6974
0000ac  2c206572
0000b0  726f7220
0000b4  62656769
0000b8  6e206164
0000bc  64726573
0000c0  73203078
0000c4  25782c20
0000c8  616e6420
0000cc  656e6420
0000d0  61646472
0000d4  65737320
0000d8  307825  
0000db  780a00            DCB      "x\n",0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L7.224|
                          DCD      heap_ptr
                  |L7.228|
                          DCD      heap_end
                  |L7.232|
0000e8  68656170          DCB      "heap",0
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L7.240|
                          DCD      heap_sem
                  |L7.244|
                          DCD      lfree

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  heap_sem
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  heap_ptr
                          DCD      0x00000000
                  heap_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
                  mem_size_aligned
                          DCD      0x00000000
                  used_mem
                          DCD      0x00000000
                  max_mem
                          DCD      0x00000000

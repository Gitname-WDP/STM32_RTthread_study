; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\thread.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\thread.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\thread.crf ..\rtthread\src\thread.c]
                          THUMB

                          AREA ||i._rt_thread_init||, CODE, READONLY, ALIGN=2

                  _rt_thread_init PROC
;;;131    
;;;132    static rt_err_t _rt_thread_init(struct rt_thread *thread,
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;133                                    const char       *name,
;;;134                                    void (*entry)(void *parameter),
;;;135                                    void             *parameter,
;;;136                                    void             *stack_start,
;;;137                                    rt_uint32_t       stack_size,
;;;138                                    rt_uint8_t        priority,
;;;139                                    rt_uint32_t       tick)
;;;140    {
000004  4604              MOV      r4,r0
000006  468b              MOV      r11,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9dd9a0c          LDRD     r9,r10,[sp,#0x30]
000010  e9dd780e          LDRD     r7,r8,[sp,#0x38]
;;;141        /* init thread list */
;;;142        rt_list_init(&(thread->tlist));
000014  f1040014          ADD      r0,r4,#0x14
000018  6040              STR      r0,[r0,#4]
00001a  6000              STR      r0,[r0,#0]
00001c  bf00              NOP      
;;;143    
;;;144        thread->entry = (void *)entry;
00001e  341c              ADDS     r4,r4,#0x1c
000020  6065              STR      r5,[r4,#4]
;;;145        thread->parameter = parameter;
000022  60a6              STR      r6,[r4,#8]
;;;146    
;;;147        /* stack init */
;;;148        thread->stack_addr = stack_start;
000024  f8c4900c          STR      r9,[r4,#0xc]
;;;149        thread->stack_size = stack_size;
000028  f8c4a010          STR      r10,[r4,#0x10]
;;;150    
;;;151        /* init thread stack */
;;;152        rt_memset(thread->stack_addr, '#', thread->stack_size);
00002c  2123              MOVS     r1,#0x23
00002e  e9d40203          LDRD     r0,r2,[r4,#0xc]
000032  f7fffffe          BL       rt_memset
;;;153        thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
000036  e9d43c03          LDRD     r3,r12,[r4,#0xc]
00003a  4463              ADD      r3,r3,r12
00003c  1f1a              SUBS     r2,r3,#4
00003e  4b0f              LDR      r3,|L1.124|
000040  e9d40101          LDRD     r0,r1,[r4,#4]
000044  f7fffffe          BL       rt_hw_stack_init
000048  6020              STR      r0,[r4,#0]
;;;154                                              (void *)((char *)thread->stack_addr + thread->stack_size - 4),
;;;155                                              (void *)rt_thread_exit);
;;;156    
;;;157        /* priority init */
;;;158        RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
;;;159        thread->init_priority    = priority;
00004a  76a7              STRB     r7,[r4,#0x1a]
;;;160        thread->current_priority = priority;
00004c  7667              STRB     r7,[r4,#0x19]
;;;161    
;;;162        thread->number_mask = 0;
00004e  2000              MOVS     r0,#0
000050  61e0              STR      r0,[r4,#0x1c]
;;;163    #if RT_THREAD_PRIORITY_MAX > 32
;;;164        thread->number = 0;
;;;165        thread->high_mask = 0;
;;;166    #endif
;;;167    
;;;168        /* tick init */
;;;169        thread->init_tick      = tick;
000052  f8c48020          STR      r8,[r4,#0x20]
;;;170        thread->remaining_tick = tick;
000056  f8c48024          STR      r8,[r4,#0x24]
;;;171    
;;;172        /* error and flags */
;;;173        thread->error = RT_EOK;
00005a  6160              STR      r0,[r4,#0x14]
;;;174        thread->stat  = RT_THREAD_INIT;
00005c  7620              STRB     r0,[r4,#0x18]
;;;175    
;;;176        /* initialize cleanup function and user data */
;;;177        thread->cleanup   = 0;
00005e  6560              STR      r0,[r4,#0x54]
;;;178        thread->user_data = 0;
000060  65a0              STR      r0,[r4,#0x58]
000062  3c1c              SUBS     r4,r4,#0x1c
;;;179    
;;;180        /* init thread timer */
;;;181        rt_timer_init(&(thread->thread_timer),
000064  9000              STR      r0,[sp,#0]
000066  4623              MOV      r3,r4
000068  4a05              LDR      r2,|L1.128|
00006a  4621              MOV      r1,r4
00006c  9001              STR      r0,[sp,#4]
00006e  f1040044          ADD      r0,r4,#0x44
000072  f7fffffe          BL       rt_timer_init
;;;182                      thread->name,
;;;183                      rt_thread_timeout,
;;;184                      thread,
;;;185                      0,
;;;186                      RT_TIMER_FLAG_ONE_SHOT);
;;;187    
;;;188    #ifdef RT_USING_MODULE
;;;189        thread->module_id = RT_NULL;
;;;190    #endif
;;;191    
;;;192        /* initialize signal */
;;;193    #ifdef RT_USING_SIGNALS
;;;194        thread->sig_mask    = 0x00;
;;;195        thread->sig_pending = 0x00;
;;;196    
;;;197        thread->sig_ret     = RT_NULL;
;;;198        thread->sig_vectors = RT_NULL;
;;;199        thread->si_list     = RT_NULL;
;;;200    #endif
;;;201    
;;;202        RT_OBJECT_HOOK_CALL(rt_thread_inited_hook, (thread));
;;;203    
;;;204        return RT_EOK;
000076  2000              MOVS     r0,#0
;;;205    }
000078  e8bd9ffc          POP      {r2-r12,pc}
;;;206    
                          ENDP

                  |L1.124|
                          DCD      rt_thread_exit
                  |L1.128|
                          DCD      rt_thread_timeout

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;71      */
;;;72     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;73     {
;;;74         l->next->prev = n;
000002  6051              STR      r1,[r2,#4]
;;;75         n->next = l->next;
000004  6802              LDR      r2,[r0,#0]
000006  600a              STR      r2,[r1,#0]
;;;76     
;;;77         l->next = n;
000008  6001              STR      r1,[r0,#0]
;;;78         n->prev = l;
00000a  6048              STR      r0,[r1,#4]
;;;79     }
00000c  4770              BX       lr
;;;80     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;99      */
;;;100    rt_inline void rt_list_remove(rt_list_t *n)
000000  e9d02100          LDRD     r2,r1,[r0,#0]
;;;101    {
;;;102        n->next->prev = n->prev;
000004  6051              STR      r1,[r2,#4]
;;;103        n->prev->next = n->next;
000006  e9d01200          LDRD     r1,r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;104    
;;;105        n->next = n->prev = n;
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;106    }
000010  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.rt_thread_control||, CODE, READONLY, ALIGN=1

                  rt_thread_control PROC
;;;551     */
;;;552    rt_err_t rt_thread_control(rt_thread_t thread, int cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;553    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;554        register rt_base_t temp;
;;;555    
;;;556        /* thread check */
;;;557        RT_ASSERT(thread != RT_NULL);
;;;558    
;;;559        switch (cmd)
00000a  b33e              CBZ      r6,|L4.92|
00000c  2e01              CMP      r6,#1
00000e  d02a              BEQ      |L4.102|
000010  2e02              CMP      r6,#2
000012  d12c              BNE      |L4.110|
;;;560        {
;;;561        case RT_THREAD_CTRL_CHANGE_PRIORITY:
;;;562            /* disable interrupt */
;;;563            temp = rt_hw_interrupt_disable();
000014  f7fffffe          BL       rt_hw_interrupt_disable
000018  4607              MOV      r7,r0
;;;564    
;;;565            /* for ready thread, change queue */
;;;566            if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY)
00001a  f8940034          LDRB     r0,[r4,#0x34]
00001e  f000000f          AND      r0,r0,#0xf
000022  2801              CMP      r0,#1
000024  d10e              BNE      |L4.68|
;;;567            {
;;;568                /* remove thread from schedule queue first */
;;;569                rt_schedule_remove_thread(thread);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       rt_schedule_remove_thread
;;;570    
;;;571                /* change thread priority */
;;;572                thread->current_priority = *(rt_uint8_t *)arg;
00002c  7828              LDRB     r0,[r5,#0]
00002e  f8840035          STRB     r0,[r4,#0x35]
;;;573    
;;;574                /* recalculate priority attribute */
;;;575    #if RT_THREAD_PRIORITY_MAX > 32
;;;576                thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;577                thread->number_mask = 1 << thread->number;
;;;578                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
;;;579    #else
;;;580                thread->number_mask = 1 << thread->current_priority;
000032  f8941035          LDRB     r1,[r4,#0x35]
000036  2001              MOVS     r0,#1
000038  4088              LSLS     r0,r0,r1
00003a  63a0              STR      r0,[r4,#0x38]
;;;581    #endif
;;;582    
;;;583                /* insert thread to schedule queue again */
;;;584                rt_schedule_insert_thread(thread);
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       rt_schedule_insert_thread
000042  e007              B        |L4.84|
                  |L4.68|
;;;585            }
;;;586            else
;;;587            {
;;;588                thread->current_priority = *(rt_uint8_t *)arg;
000044  7828              LDRB     r0,[r5,#0]
000046  f8840035          STRB     r0,[r4,#0x35]
;;;589    
;;;590                /* recalculate priority attribute */
;;;591    #if RT_THREAD_PRIORITY_MAX > 32
;;;592                thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;593                thread->number_mask = 1 << thread->number;
;;;594                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
;;;595    #else
;;;596                thread->number_mask = 1 << thread->current_priority;
00004a  f8941035          LDRB     r1,[r4,#0x35]
00004e  2001              MOVS     r0,#1
000050  4088              LSLS     r0,r0,r1
000052  63a0              STR      r0,[r4,#0x38]
                  |L4.84|
;;;597    #endif
;;;598            }
;;;599    
;;;600            /* enable interrupt */
;;;601            rt_hw_interrupt_enable(temp);
000054  4638              MOV      r0,r7
000056  f7fffffe          BL       rt_hw_interrupt_enable
;;;602            break;
00005a  e009              B        |L4.112|
                  |L4.92|
;;;603    
;;;604        case RT_THREAD_CTRL_STARTUP:
;;;605            return rt_thread_startup(thread);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       rt_thread_startup
                  |L4.98|
;;;606    
;;;607    #ifdef RT_USING_HEAP
;;;608        case RT_THREAD_CTRL_CLOSE:
;;;609            return rt_thread_delete(thread);
;;;610    #endif
;;;611    
;;;612        default:
;;;613            break;
;;;614        }
;;;615    
;;;616        return RT_EOK;
;;;617    }
000062  e8bd81f0          POP      {r4-r8,pc}
                  |L4.102|
000066  4620              MOV      r0,r4                 ;609
000068  f7fffffe          BL       rt_thread_delete
00006c  e7f9              B        |L4.98|
                  |L4.110|
00006e  bf00              NOP                            ;613
                  |L4.112|
000070  bf00              NOP                            ;602
000072  2000              MOVS     r0,#0                 ;616
000074  e7f5              B        |L4.98|
;;;618    RTM_EXPORT(rt_thread_control);
                          ENDP


                          AREA ||i.rt_thread_create||, CODE, READONLY, ALIGN=1

                  rt_thread_create PROC
;;;367     */
;;;368    rt_thread_t rt_thread_create(const char *name,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;369                                 void (*entry)(void *parameter),
;;;370                                 void       *parameter,
;;;371                                 rt_uint32_t stack_size,
;;;372                                 rt_uint8_t  priority,
;;;373                                 rt_uint32_t tick)
;;;374    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
00000a  461d              MOV      r5,r3
00000c  e9ddab0e          LDRD     r10,r11,[sp,#0x38]
;;;375        struct rt_thread *thread;
;;;376        void *stack_start;
;;;377    
;;;378        thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
000010  4631              MOV      r1,r6
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       rt_object_allocate
000018  4681              MOV      r9,r0
;;;379                                                        name);
;;;380        if (thread == RT_NULL)
00001a  f1b90f00          CMP      r9,#0
00001e  d103              BNE      |L5.40|
;;;381            return RT_NULL;
000020  2000              MOVS     r0,#0
                  |L5.34|
;;;382    
;;;383        stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
;;;384        if (stack_start == RT_NULL)
;;;385        {
;;;386            /* allocate stack failure */
;;;387            rt_object_delete((rt_object_t)thread);
;;;388    
;;;389            return RT_NULL;
;;;390        }
;;;391    
;;;392        _rt_thread_init(thread,
;;;393                        name,
;;;394                        entry,
;;;395                        parameter,
;;;396                        stack_start,
;;;397                        stack_size,
;;;398                        priority,
;;;399                        tick);
;;;400    
;;;401        return thread;
;;;402    }
000022  b004              ADD      sp,sp,#0x10
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L5.40|
000028  4628              MOV      r0,r5                 ;383
00002a  f7fffffe          BL       rt_malloc
00002e  4604              MOV      r4,r0                 ;383
000030  b924              CBNZ     r4,|L5.60|
000032  4648              MOV      r0,r9                 ;387
000034  f7fffffe          BL       rt_object_delete
000038  2000              MOVS     r0,#0                 ;389
00003a  e7f2              B        |L5.34|
                  |L5.60|
00003c  4643              MOV      r3,r8                 ;392
00003e  463a              MOV      r2,r7                 ;392
000040  4631              MOV      r1,r6                 ;392
000042  4648              MOV      r0,r9                 ;392
000044  e88d0c30          STM      sp,{r4,r5,r10,r11}    ;392
000048  f7fffffe          BL       _rt_thread_init
00004c  4648              MOV      r0,r9                 ;401
00004e  e7e8              B        |L5.34|
;;;403    RTM_EXPORT(rt_thread_create);
                          ENDP


                          AREA ||i.rt_thread_delay||, CODE, READONLY, ALIGN=1

                  rt_thread_delay PROC
;;;533     */
;;;534    rt_err_t rt_thread_delay(rt_tick_t tick)
000000  b510              PUSH     {r4,lr}
;;;535    {
000002  4604              MOV      r4,r0
;;;536        return rt_thread_sleep(tick);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_thread_sleep
;;;537    }
00000a  bd10              POP      {r4,pc}
;;;538    RTM_EXPORT(rt_thread_delay);
                          ENDP


                          AREA ||i.rt_thread_delete||, CODE, READONLY, ALIGN=2

                  rt_thread_delete PROC
;;;412     */
;;;413    rt_err_t rt_thread_delete(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;414    {
000002  4604              MOV      r4,r0
;;;415        rt_base_t lock;
;;;416    
;;;417        /* thread check */
;;;418        RT_ASSERT(thread != RT_NULL);
;;;419    
;;;420        if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
000004  f8940034          LDRB     r0,[r4,#0x34]
000008  f000000f          AND      r0,r0,#0xf
00000c  b110              CBZ      r0,|L7.20|
;;;421        {
;;;422            /* remove from schedule */
;;;423            rt_schedule_remove_thread(thread);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       rt_schedule_remove_thread
                  |L7.20|
;;;424        }
;;;425    
;;;426        /* release thread timer */
;;;427        rt_timer_detach(&(thread->thread_timer));
000014  f1040044          ADD      r0,r4,#0x44
000018  f7fffffe          BL       rt_timer_detach
;;;428    
;;;429        /* change stat */
;;;430        thread->stat = RT_THREAD_CLOSE;
00001c  2004              MOVS     r0,#4
00001e  f8840034          STRB     r0,[r4,#0x34]
;;;431    
;;;432        /* disable interrupt */
;;;433        lock = rt_hw_interrupt_disable();
000022  f7fffffe          BL       rt_hw_interrupt_disable
000026  4605              MOV      r5,r0
;;;434    
;;;435        /* insert to defunct thread list */
;;;436        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000028  f1040114          ADD      r1,r4,#0x14
00002c  4803              LDR      r0,|L7.60|
00002e  f7fffffe          BL       rt_list_insert_after
;;;437    
;;;438        /* enable interrupt */
;;;439        rt_hw_interrupt_enable(lock);
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       rt_hw_interrupt_enable
;;;440    
;;;441        return RT_EOK;
000038  2000              MOVS     r0,#0
;;;442    }
00003a  bd70              POP      {r4-r6,pc}
;;;443    RTM_EXPORT(rt_thread_delete);
                          ENDP

                  |L7.60|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_detach||, CODE, READONLY, ALIGN=2

                  rt_thread_detach PROC
;;;314     */
;;;315    rt_err_t rt_thread_detach(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;316    {
000002  4604              MOV      r4,r0
;;;317        rt_base_t lock;
;;;318    
;;;319        /* thread check */
;;;320        RT_ASSERT(thread != RT_NULL);
;;;321    
;;;322        if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_INIT)
000004  f8940034          LDRB     r0,[r4,#0x34]
000008  f000000f          AND      r0,r0,#0xf
00000c  b110              CBZ      r0,|L8.20|
;;;323        {
;;;324            /* remove from schedule */
;;;325            rt_schedule_remove_thread(thread);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       rt_schedule_remove_thread
                  |L8.20|
;;;326        }
;;;327    
;;;328        /* release thread timer */
;;;329        rt_timer_detach(&(thread->thread_timer));
000014  f1040044          ADD      r0,r4,#0x44
000018  f7fffffe          BL       rt_timer_detach
;;;330    
;;;331        /* change stat */
;;;332        thread->stat = RT_THREAD_CLOSE;
00001c  2004              MOVS     r0,#4
00001e  f8840034          STRB     r0,[r4,#0x34]
;;;333    
;;;334        /* detach object */
;;;335        rt_object_detach((rt_object_t)thread);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_object_detach
;;;336    
;;;337        if (thread->cleanup != RT_NULL)
000028  6f20              LDR      r0,[r4,#0x70]
00002a  b150              CBZ      r0,|L8.66|
;;;338        {
;;;339            /* disable interrupt */
;;;340            lock = rt_hw_interrupt_disable();
00002c  f7fffffe          BL       rt_hw_interrupt_disable
000030  4605              MOV      r5,r0
;;;341    
;;;342            /* insert to defunct thread list */
;;;343            rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000032  f1040114          ADD      r1,r4,#0x14
000036  4804              LDR      r0,|L8.72|
000038  f7fffffe          BL       rt_list_insert_after
;;;344    
;;;345            /* enable interrupt */
;;;346            rt_hw_interrupt_enable(lock);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       rt_hw_interrupt_enable
                  |L8.66|
;;;347        }
;;;348    
;;;349        return RT_EOK;
000042  2000              MOVS     r0,#0
;;;350    }
000044  bd70              POP      {r4-r6,pc}
;;;351    RTM_EXPORT(rt_thread_detach);
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_exit||, CODE, READONLY, ALIGN=2

                  rt_thread_exit PROC
;;;94     
;;;95     void rt_thread_exit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
;;;97         struct rt_thread *thread;
;;;98         register rt_base_t level;
;;;99     
;;;100        /* get current thread */
;;;101        thread = rt_current_thread;
000002  4812              LDR      r0,|L9.76|
000004  6804              LDR      r4,[r0,#0]  ; rt_current_thread
;;;102    
;;;103        /* disable interrupt */
;;;104        level = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
;;;105    
;;;106        /* remove from schedule */
;;;107        rt_schedule_remove_thread(thread);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       rt_schedule_remove_thread
;;;108        /* change stat */
;;;109        thread->stat = RT_THREAD_CLOSE;
000012  2004              MOVS     r0,#4
000014  f8840034          STRB     r0,[r4,#0x34]
;;;110    
;;;111        /* remove it from timer list */
;;;112        rt_timer_detach(&thread->thread_timer);
000018  f1040044          ADD      r0,r4,#0x44
00001c  f7fffffe          BL       rt_timer_detach
;;;113    
;;;114        if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       rt_object_is_systemobject
000026  2801              CMP      r0,#1
000028  d105              BNE      |L9.54|
;;;115            thread->cleanup == RT_NULL)
00002a  6f20              LDR      r0,[r4,#0x70]
00002c  b918              CBNZ     r0,|L9.54|
;;;116        {
;;;117            rt_object_detach((rt_object_t)thread);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       rt_object_detach
000034  e004              B        |L9.64|
                  |L9.54|
;;;118        }
;;;119        else
;;;120        {
;;;121            /* insert to defunct thread list */
;;;122            rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000036  f1040114          ADD      r1,r4,#0x14
00003a  4805              LDR      r0,|L9.80|
00003c  f7fffffe          BL       rt_list_insert_after
                  |L9.64|
;;;123        }
;;;124    
;;;125        /* enable interrupt */
;;;126        rt_hw_interrupt_enable(level);
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       rt_hw_interrupt_enable
;;;127    
;;;128        /* switch to next task */
;;;129        rt_schedule();
000046  f7fffffe          BL       rt_schedule
;;;130    }
00004a  bd70              POP      {r4-r6,pc}
;;;131    
                          ENDP

                  |L9.76|
                          DCD      rt_current_thread
                  |L9.80|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_find||, CODE, READONLY, ALIGN=1

                  rt_thread_find PROC
;;;746     */
;;;747    rt_thread_t rt_thread_find(char *name)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;748    {
000004  4606              MOV      r6,r0
;;;749        struct rt_object_information *information;
;;;750        struct rt_object *object;
;;;751        struct rt_list_node *node;
;;;752    
;;;753        /* enter critical */
;;;754        if (rt_thread_self() != RT_NULL)
000006  f7fffffe          BL       rt_thread_self
00000a  b108              CBZ      r0,|L10.16|
;;;755            rt_enter_critical();
00000c  f7fffffe          BL       rt_enter_critical
                  |L10.16|
;;;756    
;;;757        /* try to find device object */
;;;758        information = rt_object_get_information(RT_Object_Class_Thread);
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       rt_object_get_information
000016  4604              MOV      r4,r0
;;;759        RT_ASSERT(information != RT_NULL);
;;;760        for (node  = information->object_list.next;
000018  6865              LDR      r5,[r4,#4]
00001a  e010              B        |L10.62|
                  |L10.28|
;;;761             node != &(information->object_list);
;;;762             node  = node->next)
;;;763        {
;;;764            object = rt_list_entry(node, struct rt_object, list);
00001c  f1a5070c          SUB      r7,r5,#0xc
;;;765            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
000020  2208              MOVS     r2,#8
000022  4631              MOV      r1,r6
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       rt_strncmp
00002a  b938              CBNZ     r0,|L10.60|
;;;766            {
;;;767                /* leave critical */
;;;768                if (rt_thread_self() != RT_NULL)
00002c  f7fffffe          BL       rt_thread_self
000030  b108              CBZ      r0,|L10.54|
;;;769                    rt_exit_critical();
000032  f7fffffe          BL       rt_exit_critical
                  |L10.54|
;;;770    
;;;771                return (rt_thread_t)object;
000036  4638              MOV      r0,r7
                  |L10.56|
;;;772            }
;;;773        }
;;;774    
;;;775        /* leave critical */
;;;776        if (rt_thread_self() != RT_NULL)
;;;777            rt_exit_critical();
;;;778    
;;;779        /* not found */
;;;780        return RT_NULL;
;;;781    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L10.60|
00003c  682d              LDR      r5,[r5,#0]            ;762
                  |L10.62|
00003e  1d20              ADDS     r0,r4,#4              ;761
000040  4285              CMP      r5,r0                 ;761
000042  d1eb              BNE      |L10.28|
000044  f7fffffe          BL       rt_thread_self
000048  b108              CBZ      r0,|L10.78|
00004a  f7fffffe          BL       rt_exit_critical
                  |L10.78|
00004e  2000              MOVS     r0,#0                 ;780
000050  e7f2              B        |L10.56|
;;;782    RTM_EXPORT(rt_thread_find);
                          ENDP


                          AREA ||i.rt_thread_init||, CODE, READONLY, ALIGN=1

                  rt_thread_init PROC
;;;227     */
;;;228    rt_err_t rt_thread_init(struct rt_thread *thread,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;229                            const char       *name,
;;;230                            void (*entry)(void *parameter),
;;;231                            void             *parameter,
;;;232                            void             *stack_start,
;;;233                            rt_uint32_t       stack_size,
;;;234                            rt_uint8_t        priority,
;;;235                            rt_uint32_t       tick)
;;;236    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  e9ddab10          LDRD     r10,r11,[sp,#0x40]
000010  e9dd890e          LDRD     r8,r9,[sp,#0x38]
;;;237        /* thread check */
;;;238        RT_ASSERT(thread != RT_NULL);
;;;239        RT_ASSERT(stack_start != RT_NULL);
;;;240    
;;;241        /* init thread object */
;;;242        rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
000014  4622              MOV      r2,r4
000016  2100              MOVS     r1,#0
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       rt_object_init
;;;243    
;;;244        return _rt_thread_init(thread,
00001e  463b              MOV      r3,r7
000020  4632              MOV      r2,r6
000022  4621              MOV      r1,r4
000024  4628              MOV      r0,r5
000026  e88d0f00          STM      sp,{r8-r11}
00002a  f7fffffe          BL       _rt_thread_init
;;;245                               name,
;;;246                               entry,
;;;247                               parameter,
;;;248                               stack_start,
;;;249                               stack_size,
;;;250                               priority,
;;;251                               tick);
;;;252    }
00002e  b004              ADD      sp,sp,#0x10
000030  e8bd9ff0          POP      {r4-r12,pc}
;;;253    RTM_EXPORT(rt_thread_init);
                          ENDP


                          AREA ||i.rt_thread_resume||, CODE, READONLY, ALIGN=1

                  rt_thread_resume PROC
;;;671     */
;;;672    rt_err_t rt_thread_resume(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;673    {
000002  4604              MOV      r4,r0
;;;674        register rt_base_t temp;
;;;675    
;;;676        /* thread check */
;;;677        RT_ASSERT(thread != RT_NULL);
;;;678    
;;;679        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));
;;;680    
;;;681        if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_SUSPEND)
000004  f8940034          LDRB     r0,[r4,#0x34]
000008  f000000f          AND      r0,r0,#0xf
00000c  2802              CMP      r0,#2
00000e  d002              BEQ      |L12.22|
;;;682        {
;;;683            RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
;;;684                                           thread->stat));
;;;685    
;;;686            return -RT_ERROR;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L12.20|
;;;687        }
;;;688    
;;;689        /* disable interrupt */
;;;690        temp = rt_hw_interrupt_disable();
;;;691    
;;;692        /* remove from suspend list */
;;;693        rt_list_remove(&(thread->tlist));
;;;694    
;;;695        rt_timer_stop(&thread->thread_timer);
;;;696    
;;;697        /* enable interrupt */
;;;698        rt_hw_interrupt_enable(temp);
;;;699    
;;;700        /* insert to schedule ready list */
;;;701        rt_schedule_insert_thread(thread);
;;;702    
;;;703        RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread));
;;;704        return RT_EOK;
;;;705    }
000014  bd70              POP      {r4-r6,pc}
                  |L12.22|
000016  f7fffffe          BL       rt_hw_interrupt_disable
00001a  4605              MOV      r5,r0                 ;690
00001c  f1040014          ADD      r0,r4,#0x14           ;693
000020  f7fffffe          BL       rt_list_remove
000024  f1040044          ADD      r0,r4,#0x44           ;695
000028  f7fffffe          BL       rt_timer_stop
00002c  4628              MOV      r0,r5                 ;698
00002e  f7fffffe          BL       rt_hw_interrupt_enable
000032  4620              MOV      r0,r4                 ;701
000034  f7fffffe          BL       rt_schedule_insert_thread
000038  2000              MOVS     r0,#0                 ;704
00003a  e7eb              B        |L12.20|
;;;706    RTM_EXPORT(rt_thread_resume);
                          ENDP


                          AREA ||i.rt_thread_self||, CODE, READONLY, ALIGN=2

                  rt_thread_self PROC
;;;259     */
;;;260    rt_thread_t rt_thread_self(void)
000000  4801              LDR      r0,|L13.8|
;;;261    {
;;;262        return rt_current_thread;
000002  6800              LDR      r0,[r0,#0]  ; rt_current_thread
;;;263    }
000004  4770              BX       lr
;;;264    RTM_EXPORT(rt_thread_self);
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      rt_current_thread

                          AREA ||i.rt_thread_sleep||, CODE, READONLY, ALIGN=2

                  rt_thread_sleep PROC
;;;496     */
;;;497    rt_err_t rt_thread_sleep(rt_tick_t tick)
000000  b531              PUSH     {r0,r4,r5,lr}
;;;498    {
;;;499        register rt_base_t temp;
;;;500        struct rt_thread *thread;
;;;501    
;;;502        /* disable interrupt */
;;;503        temp = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4605              MOV      r5,r0
;;;504        /* set to current thread */
;;;505        thread = rt_current_thread;
000008  480d              LDR      r0,|L14.64|
00000a  6804              LDR      r4,[r0,#0]  ; rt_current_thread
;;;506        RT_ASSERT(thread != RT_NULL);
;;;507    
;;;508        /* suspend thread */
;;;509        rt_thread_suspend(thread);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       rt_thread_suspend
;;;510    
;;;511        /* reset the timeout of thread timer and start it */
;;;512        rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
000012  466a              MOV      r2,sp
000014  2100              MOVS     r1,#0
000016  f1040044          ADD      r0,r4,#0x44
00001a  f7fffffe          BL       rt_timer_control
;;;513        rt_timer_start(&(thread->thread_timer));
00001e  f1040044          ADD      r0,r4,#0x44
000022  f7fffffe          BL       rt_timer_start
;;;514    
;;;515        /* enable interrupt */
;;;516        rt_hw_interrupt_enable(temp);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
;;;517    
;;;518        rt_schedule();
00002c  f7fffffe          BL       rt_schedule
;;;519    
;;;520        /* clear error number of this thread to RT_EOK */
;;;521        if (thread->error == -RT_ETIMEOUT)
000030  6b20              LDR      r0,[r4,#0x30]
000032  1c80              ADDS     r0,r0,#2
000034  b908              CBNZ     r0,|L14.58|
;;;522            thread->error = RT_EOK;
000036  2000              MOVS     r0,#0
000038  6320              STR      r0,[r4,#0x30]
                  |L14.58|
;;;523    
;;;524        return RT_EOK;
00003a  2000              MOVS     r0,#0
;;;525    }
00003c  bd38              POP      {r3-r5,pc}
;;;526    
                          ENDP

00003e  0000              DCW      0x0000
                  |L14.64|
                          DCD      rt_current_thread

                          AREA ||i.rt_thread_startup||, CODE, READONLY, ALIGN=1

                  rt_thread_startup PROC
;;;272     */
;;;273    rt_err_t rt_thread_startup(rt_thread_t thread)
000000  b510              PUSH     {r4,lr}
;;;274    {
000002  4604              MOV      r4,r0
;;;275        /* thread check */
;;;276        RT_ASSERT(thread != RT_NULL);
;;;277        RT_ASSERT((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_INIT);
;;;278    
;;;279        /* set current priority to init priority */
;;;280        thread->current_priority = thread->init_priority;
000004  3434              ADDS     r4,r4,#0x34
000006  78a0              LDRB     r0,[r4,#2]
000008  7060              STRB     r0,[r4,#1]
;;;281    
;;;282        /* calculate priority attribute */
;;;283    #if RT_THREAD_PRIORITY_MAX > 32
;;;284        thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;285        thread->number_mask = 1L << thread->number;
;;;286        thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
;;;287    #else
;;;288        thread->number_mask = 1L << thread->current_priority;
00000a  7861              LDRB     r1,[r4,#1]
00000c  2001              MOVS     r0,#1
00000e  4088              LSLS     r0,r0,r1
000010  6060              STR      r0,[r4,#4]
;;;289    #endif
;;;290    
;;;291        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
;;;292                                       thread->name, thread->init_priority));
;;;293        /* change thread stat */
;;;294        thread->stat = RT_THREAD_SUSPEND;
000012  2002              MOVS     r0,#2
000014  f8040934          STRB     r0,[r4],#-0x34
;;;295        /* then resume it */
;;;296        rt_thread_resume(thread);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_thread_resume
;;;297        if (rt_thread_self() != RT_NULL)
00001e  f7fffffe          BL       rt_thread_self
000022  b108              CBZ      r0,|L15.40|
;;;298        {
;;;299            /* do a scheduling */
;;;300            rt_schedule();
000024  f7fffffe          BL       rt_schedule
                  |L15.40|
;;;301        }
;;;302    
;;;303        return RT_EOK;
000028  2000              MOVS     r0,#0
;;;304    }
00002a  bd10              POP      {r4,pc}
;;;305    RTM_EXPORT(rt_thread_startup);
                          ENDP


                          AREA ||i.rt_thread_suspend||, CODE, READONLY, ALIGN=1

                  rt_thread_suspend PROC
;;;629     */
;;;630    rt_err_t rt_thread_suspend(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;631    {
000002  4604              MOV      r4,r0
;;;632        register rt_base_t temp;
;;;633    
;;;634        /* thread check */
;;;635        RT_ASSERT(thread != RT_NULL);
;;;636    
;;;637        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));
;;;638    
;;;639        if ((thread->stat & RT_THREAD_STAT_MASK) != RT_THREAD_READY)
000004  f8940034          LDRB     r0,[r4,#0x34]
000008  f000000f          AND      r0,r0,#0xf
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L16.22|
;;;640        {
;;;641            RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, 0x%2x\n",
;;;642                                           thread->stat));
;;;643    
;;;644            return -RT_ERROR;
000010  f04f30ff          MOV      r0,#0xffffffff
                  |L16.20|
;;;645        }
;;;646    
;;;647        /* disable interrupt */
;;;648        temp = rt_hw_interrupt_disable();
;;;649    
;;;650        /* change thread stat */
;;;651        thread->stat = RT_THREAD_SUSPEND | (thread->stat & ~RT_THREAD_STAT_MASK);
;;;652        rt_schedule_remove_thread(thread);
;;;653    
;;;654        /* stop thread timer anyway */
;;;655        rt_timer_stop(&(thread->thread_timer));
;;;656    
;;;657        /* enable interrupt */
;;;658        rt_hw_interrupt_enable(temp);
;;;659    
;;;660        RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook, (thread));
;;;661        return RT_EOK;
;;;662    }
000014  bd70              POP      {r4-r6,pc}
                  |L16.22|
000016  f7fffffe          BL       rt_hw_interrupt_disable
00001a  4605              MOV      r5,r0                 ;648
00001c  f8940034          LDRB     r0,[r4,#0x34]         ;651
000020  f020000f          BIC      r0,r0,#0xf            ;651
000024  f0400002          ORR      r0,r0,#2              ;651
000028  f8840034          STRB     r0,[r4,#0x34]         ;651
00002c  4620              MOV      r0,r4                 ;652
00002e  f7fffffe          BL       rt_schedule_remove_thread
000032  f1040044          ADD      r0,r4,#0x44           ;655
000036  f7fffffe          BL       rt_timer_stop
00003a  4628              MOV      r0,r5                 ;658
00003c  f7fffffe          BL       rt_hw_interrupt_enable
000040  2000              MOVS     r0,#0                 ;661
000042  e7e7              B        |L16.20|
;;;663    RTM_EXPORT(rt_thread_suspend);
                          ENDP


                          AREA ||i.rt_thread_timeout||, CODE, READONLY, ALIGN=1

                  rt_thread_timeout PROC
;;;713     */
;;;714    void rt_thread_timeout(void *parameter)
000000  b570              PUSH     {r4-r6,lr}
;;;715    {
000002  4604              MOV      r4,r0
;;;716        struct rt_thread *thread;
;;;717    
;;;718        thread = (struct rt_thread *)parameter;
000004  4625              MOV      r5,r4
;;;719    
;;;720        /* thread check */
;;;721        RT_ASSERT(thread != RT_NULL);
;;;722        RT_ASSERT((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_SUSPEND);
;;;723    
;;;724        /* set error number */
;;;725        thread->error = -RT_ETIMEOUT;
000006  f06f0001          MVN      r0,#1
00000a  6328              STR      r0,[r5,#0x30]
;;;726    
;;;727        /* remove from suspend list */
;;;728        rt_list_remove(&(thread->tlist));
00000c  f1050014          ADD      r0,r5,#0x14
000010  f7fffffe          BL       rt_list_remove
;;;729    
;;;730        /* insert to schedule ready list */
;;;731        rt_schedule_insert_thread(thread);
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       rt_schedule_insert_thread
;;;732    
;;;733        /* do schedule */
;;;734        rt_schedule();
00001a  f7fffffe          BL       rt_schedule
;;;735    }
00001e  bd70              POP      {r4-r6,pc}
;;;736    RTM_EXPORT(rt_thread_timeout);
                          ENDP


                          AREA ||i.rt_thread_yield||, CODE, READONLY, ALIGN=2

                  rt_thread_yield PROC
;;;452     */
;;;453    rt_err_t rt_thread_yield(void)
000000  b570              PUSH     {r4-r6,lr}
;;;454    {
;;;455        register rt_base_t level;
;;;456        struct rt_thread *thread;
;;;457    
;;;458        /* disable interrupt */
;;;459        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4605              MOV      r5,r0
;;;460    
;;;461        /* set to current thread */
;;;462        thread = rt_current_thread;
000008  4814              LDR      r0,|L18.92|
00000a  6804              LDR      r4,[r0,#0]  ; rt_current_thread
;;;463    
;;;464        /* if the thread stat is READY and on ready queue list */
;;;465        if ((thread->stat & RT_THREAD_STAT_MASK) == RT_THREAD_READY &&
00000c  f8940034          LDRB     r0,[r4,#0x34]
000010  f000000f          AND      r0,r0,#0xf
000014  2801              CMP      r0,#1
000016  d11c              BNE      |L18.82|
;;;466            thread->tlist.next != thread->tlist.prev)
000018  e9d41005          LDRD     r1,r0,[r4,#0x14]
00001c  4281              CMP      r1,r0
00001e  d018              BEQ      |L18.82|
;;;467        {
;;;468            /* remove thread from thread list */
;;;469            rt_list_remove(&(thread->tlist));
000020  f1040014          ADD      r0,r4,#0x14
000024  f7fffffe          BL       rt_list_remove
;;;470    
;;;471            /* put thread to end of ready queue */
;;;472            rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
000028  f8942035          LDRB     r2,[r4,#0x35]
00002c  4b0c              LDR      r3,|L18.96|
00002e  eb0300c2          ADD      r0,r3,r2,LSL #3
000032  f1040114          ADD      r1,r4,#0x14
000036  6842              LDR      r2,[r0,#4]
000038  6011              STR      r1,[r2,#0]
00003a  6842              LDR      r2,[r0,#4]
00003c  604a              STR      r2,[r1,#4]
00003e  6041              STR      r1,[r0,#4]
000040  6008              STR      r0,[r1,#0]
000042  bf00              NOP      
;;;473                                  &(thread->tlist));
;;;474    
;;;475            /* enable interrupt */
;;;476            rt_hw_interrupt_enable(level);
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       rt_hw_interrupt_enable
;;;477    
;;;478            rt_schedule();
00004a  f7fffffe          BL       rt_schedule
;;;479    
;;;480            return RT_EOK;
00004e  2000              MOVS     r0,#0
                  |L18.80|
;;;481        }
;;;482    
;;;483        /* enable interrupt */
;;;484        rt_hw_interrupt_enable(level);
;;;485    
;;;486        return RT_EOK;
;;;487    }
000050  bd70              POP      {r4-r6,pc}
                  |L18.82|
000052  4628              MOV      r0,r5                 ;484
000054  f7fffffe          BL       rt_hw_interrupt_enable
000058  2000              MOVS     r0,#0                 ;486
00005a  e7f9              B        |L18.80|
;;;488    RTM_EXPORT(rt_thread_yield);
                          ENDP

                  |L18.92|
                          DCD      rt_current_thread
                  |L18.96|
                          DCD      rt_thread_priority_table

; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\object.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\object.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\object.crf ..\rtthread\src\object.c]
                          THUMB

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;71      */
;;;72     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;73     {
;;;74         l->next->prev = n;
000002  6051              STR      r1,[r2,#4]
;;;75         n->next = l->next;
000004  6802              LDR      r2,[r0,#0]
000006  600a              STR      r2,[r1,#0]
;;;76     
;;;77         l->next = n;
000008  6001              STR      r1,[r0,#0]
;;;78         n->prev = l;
00000a  6048              STR      r0,[r1,#4]
;;;79     }
00000c  4770              BX       lr
;;;80     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;99      */
;;;100    rt_inline void rt_list_remove(rt_list_t *n)
000000  e9d02100          LDRD     r2,r1,[r0,#0]
;;;101    {
;;;102        n->next->prev = n->prev;
000004  6051              STR      r1,[r2,#4]
;;;103        n->prev->next = n->next;
000006  e9d01200          LDRD     r1,r2,[r0,#0]
00000a  6011              STR      r1,[r2,#0]
;;;104    
;;;105        n->next = n->prev = n;
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;106    }
000010  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.rt_object_allocate||, CODE, READONLY, ALIGN=1

                  rt_object_allocate PROC
;;;318     */
;;;319    rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;320    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;321        struct rt_object *object;
;;;322        register rt_base_t temp;
;;;323        struct rt_object_information *information;
;;;324    
;;;325        RT_DEBUG_NOT_IN_INTERRUPT;
;;;326    
;;;327    #ifdef RT_USING_MODULE
;;;328        /*
;;;329         * get module object information,
;;;330         * module object should be managed by kernel object container
;;;331         */
;;;332        information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
;;;333                      &rt_module_self()->module_object[type] : rt_object_get_information(type);
;;;334    #else
;;;335        /* get object information */
;;;336        information = rt_object_get_information(type);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       rt_object_get_information
00000e  4606              MOV      r6,r0
;;;337        RT_ASSERT(information != RT_NULL);
;;;338    #endif
;;;339    
;;;340        object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
000010  68f0              LDR      r0,[r6,#0xc]
000012  f7fffffe          BL       rt_malloc
000016  4604              MOV      r4,r0
;;;341        if (object == RT_NULL)
000018  b914              CBNZ     r4,|L3.32|
;;;342        {
;;;343            /* no memory can be allocated */
;;;344            return RT_NULL;
00001a  2000              MOVS     r0,#0
                  |L3.28|
;;;345        }
;;;346    
;;;347        /* initialize object's parameters */
;;;348    
;;;349        /* set object type */
;;;350        object->type = type;
;;;351    
;;;352        /* set object flag */
;;;353        object->flag = 0;
;;;354    
;;;355    #ifdef RT_USING_MODULE
;;;356        if (rt_module_self() != RT_NULL)
;;;357        {
;;;358            object->flag |= RT_OBJECT_FLAG_MODULE;
;;;359        }
;;;360        object->module_id = (void *)rt_module_self();
;;;361    #endif
;;;362    
;;;363        /* copy name */
;;;364        rt_strncpy(object->name, name, RT_NAME_MAX);
;;;365    
;;;366        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
;;;367    
;;;368        /* lock interrupt */
;;;369        temp = rt_hw_interrupt_disable();
;;;370    
;;;371        /* insert object into information object list */
;;;372        rt_list_insert_after(&(information->object_list), &(object->list));
;;;373    
;;;374        /* unlock interrupt */
;;;375        rt_hw_interrupt_enable(temp);
;;;376    
;;;377        /* return object */
;;;378        return object;
;;;379    }
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L3.32|
000020  7225              STRB     r5,[r4,#8]            ;350
000022  2000              MOVS     r0,#0                 ;353
000024  7260              STRB     r0,[r4,#9]            ;353
000026  2208              MOVS     r2,#8                 ;364
000028  4639              MOV      r1,r7                 ;364
00002a  4620              MOV      r0,r4                 ;364
00002c  f7fffffe          BL       rt_strncpy
000030  f7fffffe          BL       rt_hw_interrupt_disable
000034  4680              MOV      r8,r0                 ;369
000036  f104010c          ADD      r1,r4,#0xc            ;372
00003a  1d30              ADDS     r0,r6,#4              ;372
00003c  f7fffffe          BL       rt_list_insert_after
000040  4640              MOV      r0,r8                 ;375
000042  f7fffffe          BL       rt_hw_interrupt_enable
000046  4620              MOV      r0,r4                 ;378
000048  e7e8              B        |L3.28|
;;;380    
                          ENDP


                          AREA ||i.rt_object_delete||, CODE, READONLY, ALIGN=1

                  rt_object_delete PROC
;;;385     */
;;;386    void rt_object_delete(rt_object_t object)
000000  b570              PUSH     {r4-r6,lr}
;;;387    {
000002  4604              MOV      r4,r0
;;;388        register rt_base_t temp;
;;;389    
;;;390        /* object check */
;;;391        RT_ASSERT(object != RT_NULL);
;;;392        RT_ASSERT(!(object->type & RT_Object_Class_Static));
;;;393    
;;;394        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
;;;395    
;;;396        /* lock interrupt */
;;;397        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;398    
;;;399        /* remove from old list */
;;;400        rt_list_remove(&(object->list));
00000a  f104000c          ADD      r0,r4,#0xc
00000e  f7fffffe          BL       rt_list_remove
;;;401    
;;;402        /* unlock interrupt */
;;;403        rt_hw_interrupt_enable(temp);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       rt_hw_interrupt_enable
;;;404    
;;;405    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;406        if (object->flag & RT_OBJECT_FLAG_MODULE)
;;;407            rt_module_free((rt_module_t)object->module_id, object);
;;;408        else
;;;409    #endif
;;;410    
;;;411            /* free the memory of object */
;;;412            RT_KERNEL_FREE(object);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_free
;;;413    }
00001e  bd70              POP      {r4-r6,pc}
;;;414    #endif
                          ENDP


                          AREA ||i.rt_object_detach||, CODE, READONLY, ALIGN=1

                  rt_object_detach PROC
;;;290     */
;;;291    void rt_object_detach(rt_object_t object)
000000  b570              PUSH     {r4-r6,lr}
;;;292    {
000002  4604              MOV      r4,r0
;;;293        register rt_base_t temp;
;;;294    
;;;295        /* object check */
;;;296        RT_ASSERT(object != RT_NULL);
;;;297    
;;;298        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
;;;299    
;;;300        /* lock interrupt */
;;;301        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;302    
;;;303        /* remove from old list */
;;;304        rt_list_remove(&(object->list));
00000a  f104000c          ADD      r0,r4,#0xc
00000e  f7fffffe          BL       rt_list_remove
;;;305    
;;;306        /* unlock interrupt */
;;;307        rt_hw_interrupt_enable(temp);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       rt_hw_interrupt_enable
;;;308    }
000018  bd70              POP      {r4-r6,pc}
;;;309    
                          ENDP


                          AREA ||i.rt_object_find||, CODE, READONLY, ALIGN=1

                  rt_object_find PROC
;;;447     */
;;;448    rt_object_t rt_object_find(const char *name, rt_uint8_t type)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;449    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;450        struct rt_object *object = RT_NULL;
000008  f04f0800          MOV      r8,#0
;;;451        struct rt_list_node *node = RT_NULL;
00000c  2600              MOVS     r6,#0
;;;452        struct rt_object_information *information = RT_NULL;
00000e  2700              MOVS     r7,#0
;;;453    
;;;454        /* parameter check */
;;;455        if ((name == RT_NULL) || (type > RT_Object_Class_Unknown))
000010  b10c              CBZ      r4,|L6.22|
000012  2d0b              CMP      r5,#0xb
000014  dd02              BLE      |L6.28|
                  |L6.22|
;;;456            return RT_NULL;
000016  2000              MOVS     r0,#0
                  |L6.24|
;;;457    
;;;458        /* which is invoke in interrupt status */
;;;459        RT_DEBUG_NOT_IN_INTERRUPT;
;;;460    
;;;461    #ifdef RT_USING_MODULE
;;;462        /* check whether to find a object inside a module. */
;;;463        {
;;;464            const char *name_ptr;
;;;465            int module_name_length;
;;;466    
;;;467            name_ptr = name;
;;;468            while ((*name_ptr != '\0') && (*name_ptr != '/'))
;;;469                name_ptr ++;
;;;470    
;;;471            if (*name_ptr == '/')
;;;472            {
;;;473                struct rt_module *module = RT_NULL;
;;;474    
;;;475                /* get the name length of module */
;;;476                module_name_length = name_ptr - name;
;;;477    
;;;478                /* enter critical */
;;;479                rt_enter_critical();
;;;480    
;;;481                /* find module */
;;;482                information = rt_object_get_information(RT_Object_Class_Module);
;;;483                RT_ASSERT(information != RT_NULL);
;;;484    
;;;485                for (node = information->object_list.next;
;;;486                        node != &(information->object_list);
;;;487                        node  = node->next)
;;;488                {
;;;489                    object = rt_list_entry(node, struct rt_object, list);
;;;490                    if ((rt_strncmp(object->name, name, module_name_length) == 0) &&
;;;491                            (module_name_length == RT_NAME_MAX || object->name[module_name_length] == '\0'))
;;;492                    {
;;;493                        /* get module */
;;;494                        module = (struct rt_module *)object;
;;;495                        break;
;;;496                    }
;;;497                }
;;;498                rt_exit_critical();
;;;499    
;;;500                /* there is no this module inside the system */
;;;501                if (module == RT_NULL) return RT_NULL;
;;;502    
;;;503                /* get the object pool of module */
;;;504                information = &(module->module_object[type]);
;;;505    
;;;506                /* get object name */
;;;507                while ((*name_ptr == '/') && (*name_ptr != '\0')) name_ptr ++;
;;;508                if (*name_ptr == '\0')
;;;509                {
;;;510                    if (type == RT_Object_Class_Module) return object;
;;;511                    return RT_NULL;
;;;512                }
;;;513    
;;;514                /* point to the object name */
;;;515                name = name_ptr;
;;;516            }
;;;517        }
;;;518    #endif
;;;519    
;;;520        /* enter critical */
;;;521        rt_enter_critical();
;;;522    
;;;523        /* try to find object */
;;;524        if (information == RT_NULL)
;;;525        {
;;;526            information = rt_object_get_information((enum rt_object_class_type)type);
;;;527            RT_ASSERT(information != RT_NULL);
;;;528        }
;;;529        for (node  = information->object_list.next;
;;;530                node != &(information->object_list);
;;;531                node  = node->next)
;;;532        {
;;;533            object = rt_list_entry(node, struct rt_object, list);
;;;534            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
;;;535            {
;;;536                /* leave critical */
;;;537                rt_exit_critical();
;;;538    
;;;539                return object;
;;;540            }
;;;541        }
;;;542    
;;;543        /* leave critical */
;;;544        rt_exit_critical();
;;;545    
;;;546        return RT_NULL;
;;;547    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L6.28|
00001c  f7fffffe          BL       rt_enter_critical
000020  b91f              CBNZ     r7,|L6.42|
000022  4628              MOV      r0,r5                 ;526
000024  f7fffffe          BL       rt_object_get_information
000028  4607              MOV      r7,r0                 ;526
                  |L6.42|
00002a  687e              LDR      r6,[r7,#4]            ;529
00002c  e00c              B        |L6.72|
                  |L6.46|
00002e  f1a6080c          SUB      r8,r6,#0xc            ;533
000032  2208              MOVS     r2,#8                 ;534
000034  4621              MOV      r1,r4                 ;534
000036  4640              MOV      r0,r8                 ;534
000038  f7fffffe          BL       rt_strncmp
00003c  b918              CBNZ     r0,|L6.70|
00003e  f7fffffe          BL       rt_exit_critical
000042  4640              MOV      r0,r8                 ;539
000044  e7e8              B        |L6.24|
                  |L6.70|
000046  6836              LDR      r6,[r6,#0]            ;531
                  |L6.72|
000048  1d38              ADDS     r0,r7,#4              ;530
00004a  4286              CMP      r6,r0                 ;530
00004c  d1ef              BNE      |L6.46|
00004e  f7fffffe          BL       rt_exit_critical
000052  2000              MOVS     r0,#0                 ;546
000054  e7e0              B        |L6.24|
;;;548    
                          ENDP


                          AREA ||i.rt_object_get_information||, CODE, READONLY, ALIGN=2

                  rt_object_get_information PROC
;;;228    struct rt_object_information *
;;;229    rt_object_get_information(enum rt_object_class_type type)
000000  4602              MOV      r2,r0
;;;230    {
;;;231        int index;
;;;232    
;;;233        for (index = 0; index < RT_Object_Info_Unknown; index ++)
000002  2100              MOVS     r1,#0
000004  e00a              B        |L7.28|
                  |L7.6|
;;;234            if (rt_object_container[index].type == type) return &rt_object_container[index];
000006  4807              LDR      r0,|L7.36|
000008  eb001001          ADD      r0,r0,r1,LSL #4
00000c  7800              LDRB     r0,[r0,#0]
00000e  4290              CMP      r0,r2
000010  d103              BNE      |L7.26|
000012  4804              LDR      r0,|L7.36|
000014  eb001001          ADD      r0,r0,r1,LSL #4
                  |L7.24|
;;;235    
;;;236        return RT_NULL;
;;;237    }
000018  4770              BX       lr
                  |L7.26|
00001a  1c49              ADDS     r1,r1,#1              ;233
                  |L7.28|
00001c  2905              CMP      r1,#5                 ;233
00001e  dbf2              BLT      |L7.6|
000020  2000              MOVS     r0,#0                 ;236
000022  e7f9              B        |L7.24|
;;;238    RTM_EXPORT(rt_object_get_information);
                          ENDP

                  |L7.36|
                          DCD      rt_object_container

                          AREA ||i.rt_object_init||, CODE, READONLY, ALIGN=1

                  rt_object_init PROC
;;;247     */
;;;248    void rt_object_init(struct rt_object         *object,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;249                        enum rt_object_class_type type,
;;;250                        const char               *name)
;;;251    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;252        register rt_base_t temp;
;;;253        struct rt_object_information *information;
;;;254    
;;;255    #ifdef RT_USING_MODULE
;;;256        /* get module object information */
;;;257        information = (rt_module_self() != RT_NULL) ?
;;;258                      &rt_module_self()->module_object[type] : rt_object_get_information(type);
;;;259    #else
;;;260        /* get object information */
;;;261        information = rt_object_get_information(type);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       rt_object_get_information
000010  4607              MOV      r7,r0
;;;262        RT_ASSERT(information != RT_NULL);
;;;263    #endif
;;;264    
;;;265        /* initialize object's parameters */
;;;266    
;;;267        /* set object type to static */
;;;268        object->type = type | RT_Object_Class_Static;
000012  f0450080          ORR      r0,r5,#0x80
000016  7220              STRB     r0,[r4,#8]
;;;269    
;;;270        /* copy name */
;;;271        rt_strncpy(object->name, name, RT_NAME_MAX);
000018  2208              MOVS     r2,#8
00001a  4631              MOV      r1,r6
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       rt_strncpy
;;;272    
;;;273        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
;;;274    
;;;275        /* lock interrupt */
;;;276        temp = rt_hw_interrupt_disable();
000022  f7fffffe          BL       rt_hw_interrupt_disable
000026  4680              MOV      r8,r0
;;;277    
;;;278        /* insert object into information object list */
;;;279        rt_list_insert_after(&(information->object_list), &(object->list));
000028  f104010c          ADD      r1,r4,#0xc
00002c  1d38              ADDS     r0,r7,#4
00002e  f7fffffe          BL       rt_list_insert_after
;;;280    
;;;281        /* unlock interrupt */
;;;282        rt_hw_interrupt_enable(temp);
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       rt_hw_interrupt_enable
;;;283    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;284    
                          ENDP


                          AREA ||i.rt_object_is_systemobject||, CODE, READONLY, ALIGN=1

                  rt_object_is_systemobject PROC
;;;424     */
;;;425    rt_bool_t rt_object_is_systemobject(rt_object_t object)
000000  4601              MOV      r1,r0
;;;426    {
;;;427        /* object check */
;;;428        RT_ASSERT(object != RT_NULL);
;;;429    
;;;430        if (object->type & RT_Object_Class_Static)
000002  7a08              LDRB     r0,[r1,#8]
000004  f0000080          AND      r0,r0,#0x80
000008  b108              CBZ      r0,|L9.14|
;;;431            return RT_TRUE;
00000a  2001              MOVS     r0,#1
                  |L9.12|
;;;432    
;;;433        return RT_FALSE;
;;;434    }
00000c  4770              BX       lr
                  |L9.14|
00000e  2000              MOVS     r0,#0                 ;433
000010  e7fc              B        |L9.12|
;;;435    
                          ENDP


                          AREA ||i.rt_system_object_init||, CODE, READONLY, ALIGN=1

                  rt_system_object_init PROC
;;;211     */
;;;212    void rt_system_object_init(void)
000000  4770              BX       lr
;;;213    {
;;;214    }
;;;215    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  rt_object_container
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      rt_object_container+0x4
                          DCD      rt_object_container+0x4
                          DCD      0x00000078
000010  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      rt_object_container+0x14
                          DCD      rt_object_container+0x14
                          DCD      0x00000020
000020  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      rt_object_container+0x24
                          DCD      rt_object_container+0x24
                          DCD      0x00000030
000030  08000000          DCB      0x08,0x00,0x00,0x00
                          DCD      rt_object_container+0x34
                          DCD      rt_object_container+0x34
                          DCD      0x00000040
000040  09000000          DCB      0x09,0x00,0x00,0x00
                          DCD      rt_object_container+0x44
                          DCD      rt_object_container+0x44
                          DCD      0x0000002c

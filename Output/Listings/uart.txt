; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\uart.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\uart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\uart.crf ..\Driver\Src\uart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;177    
;;;178    void USART1_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;179    {
;;;180         // 接收中断
;;;181        if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  4821              LDR      r0,|L1.140|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b1c0              CBZ      r0,|L1.64|
;;;182        {
;;;183            uint8_t data = USART_ReceiveData(USART1);
00000e  481f              LDR      r0,|L1.140|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c5              UXTB     r5,r0
;;;184            uint16_t nextWriteIndex = (rxWriteIndex + 1) % BUFFER_SIZE;
000016  491e              LDR      r1,|L1.144|
000018  8809              LDRH     r1,[r1,#0]  ; rxWriteIndex
00001a  1c48              ADDS     r0,r1,#1
00001c  17c1              ASRS     r1,r0,#31
00001e  eb005191          ADD      r1,r0,r1,LSR #22
000022  1289              ASRS     r1,r1,#10
000024  eba02181          SUB      r1,r0,r1,LSL #10
000028  b28c              UXTH     r4,r1
;;;185            
;;;186            if (nextWriteIndex != rxReadIndex)
00002a  481a              LDR      r0,|L1.148|
00002c  8800              LDRH     r0,[r0,#0]  ; rxReadIndex
00002e  4284              CMP      r4,r0
000030  d005              BEQ      |L1.62|
;;;187            {
;;;188                rxBuffer[rxWriteIndex] = data;
000032  4819              LDR      r0,|L1.152|
000034  4916              LDR      r1,|L1.144|
000036  8809              LDRH     r1,[r1,#0]  ; rxWriteIndex
000038  5445              STRB     r5,[r0,r1]
;;;189                rxWriteIndex = nextWriteIndex;
00003a  4815              LDR      r0,|L1.144|
00003c  8004              STRH     r4,[r0,#0]
                  |L1.62|
;;;190            }
;;;191            // 否则，接收缓冲区满，丢弃数据或处理溢出情况
;;;192        }
00003e  bf00              NOP      
                  |L1.64|
;;;193    
;;;194        // 发送中断
;;;195        if (USART_GetITStatus(USART1, USART_IT_TXE) != RESET)
000040  f2407127          MOV      r1,#0x727
000044  4811              LDR      r0,|L1.140|
000046  f7fffffe          BL       USART_GetITStatus
00004a  b1f0              CBZ      r0,|L1.138|
;;;196        {
;;;197            if (txReadIndex != txWriteIndex)
00004c  4813              LDR      r0,|L1.156|
00004e  8800              LDRH     r0,[r0,#0]  ; txReadIndex
000050  4913              LDR      r1,|L1.160|
000052  8809              LDRH     r1,[r1,#0]  ; txWriteIndex
000054  4288              CMP      r0,r1
000056  d012              BEQ      |L1.126|
;;;198            {
;;;199                USART_SendData(USART1, txBuffer[txReadIndex]);
000058  4812              LDR      r0,|L1.164|
00005a  4a10              LDR      r2,|L1.156|
00005c  8812              LDRH     r2,[r2,#0]  ; txReadIndex
00005e  5c81              LDRB     r1,[r0,r2]
000060  480a              LDR      r0,|L1.140|
000062  f7fffffe          BL       USART_SendData
;;;200                txReadIndex = (txReadIndex + 1) % BUFFER_SIZE;
000066  490d              LDR      r1,|L1.156|
000068  8809              LDRH     r1,[r1,#0]  ; txReadIndex
00006a  1c48              ADDS     r0,r1,#1
00006c  17c1              ASRS     r1,r0,#31
00006e  eb005191          ADD      r1,r0,r1,LSR #22
000072  1289              ASRS     r1,r1,#10
000074  eba02181          SUB      r1,r0,r1,LSL #10
000078  4a08              LDR      r2,|L1.156|
00007a  8011              STRH     r1,[r2,#0]
00007c  e005              B        |L1.138|
                  |L1.126|
;;;201            }
;;;202            else
;;;203            {
;;;204                // 禁用发送中断
;;;205                USART_ITConfig(USART1, USART_IT_TXE, DISABLE);
00007e  2200              MOVS     r2,#0
000080  f2407127          MOV      r1,#0x727
000084  4801              LDR      r0,|L1.140|
000086  f7fffffe          BL       USART_ITConfig
                  |L1.138|
;;;206            }
;;;207        }
;;;208    }
00008a  bd70              POP      {r4-r6,pc}
;;;209    
                          ENDP

                  |L1.140|
                          DCD      0x40013800
                  |L1.144|
                          DCD      rxWriteIndex
                  |L1.148|
                          DCD      rxReadIndex
                  |L1.152|
                          DCD      rxBuffer
                  |L1.156|
                          DCD      txReadIndex
                  |L1.160|
                          DCD      txWriteIndex
                  |L1.164|
                          DCD      txBuffer

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;210    
;;;211    void USART2_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;212    {
;;;213    	 // 接收中断
;;;214        if (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  4821              LDR      r0,|L2.140|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b1c0              CBZ      r0,|L2.64|
;;;215        {
;;;216            uint8_t data = USART_ReceiveData(USART2);
00000e  481f              LDR      r0,|L2.140|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c5              UXTB     r5,r0
;;;217            uint16_t nextWriteIndex = (rxWriteIndex + 1) % BUFFER_SIZE;
000016  491e              LDR      r1,|L2.144|
000018  8809              LDRH     r1,[r1,#0]  ; rxWriteIndex
00001a  1c48              ADDS     r0,r1,#1
00001c  17c1              ASRS     r1,r0,#31
00001e  eb005191          ADD      r1,r0,r1,LSR #22
000022  1289              ASRS     r1,r1,#10
000024  eba02181          SUB      r1,r0,r1,LSL #10
000028  b28c              UXTH     r4,r1
;;;218            
;;;219            if (nextWriteIndex != rxReadIndex)
00002a  481a              LDR      r0,|L2.148|
00002c  8800              LDRH     r0,[r0,#0]  ; rxReadIndex
00002e  4284              CMP      r4,r0
000030  d005              BEQ      |L2.62|
;;;220            {
;;;221                rxBuffer[rxWriteIndex] = data;
000032  4819              LDR      r0,|L2.152|
000034  4916              LDR      r1,|L2.144|
000036  8809              LDRH     r1,[r1,#0]  ; rxWriteIndex
000038  5445              STRB     r5,[r0,r1]
;;;222                rxWriteIndex = nextWriteIndex;
00003a  4815              LDR      r0,|L2.144|
00003c  8004              STRH     r4,[r0,#0]
                  |L2.62|
;;;223            }
;;;224            // 否则，接收缓冲区满，丢弃数据或处理溢出情况
;;;225        }
00003e  bf00              NOP      
                  |L2.64|
;;;226    
;;;227        // 发送中断
;;;228        if (USART_GetITStatus(USART2, USART_IT_TXE) != RESET)
000040  f2407127          MOV      r1,#0x727
000044  4811              LDR      r0,|L2.140|
000046  f7fffffe          BL       USART_GetITStatus
00004a  b1f0              CBZ      r0,|L2.138|
;;;229        {
;;;230            if (txReadIndex != txWriteIndex)
00004c  4813              LDR      r0,|L2.156|
00004e  8800              LDRH     r0,[r0,#0]  ; txReadIndex
000050  4913              LDR      r1,|L2.160|
000052  8809              LDRH     r1,[r1,#0]  ; txWriteIndex
000054  4288              CMP      r0,r1
000056  d012              BEQ      |L2.126|
;;;231            {
;;;232                USART_SendData(USART2, txBuffer[txReadIndex]);
000058  4812              LDR      r0,|L2.164|
00005a  4a10              LDR      r2,|L2.156|
00005c  8812              LDRH     r2,[r2,#0]  ; txReadIndex
00005e  5c81              LDRB     r1,[r0,r2]
000060  480a              LDR      r0,|L2.140|
000062  f7fffffe          BL       USART_SendData
;;;233                txReadIndex = (txReadIndex + 1) % BUFFER_SIZE;
000066  490d              LDR      r1,|L2.156|
000068  8809              LDRH     r1,[r1,#0]  ; txReadIndex
00006a  1c48              ADDS     r0,r1,#1
00006c  17c1              ASRS     r1,r0,#31
00006e  eb005191          ADD      r1,r0,r1,LSR #22
000072  1289              ASRS     r1,r1,#10
000074  eba02181          SUB      r1,r0,r1,LSL #10
000078  4a08              LDR      r2,|L2.156|
00007a  8011              STRH     r1,[r2,#0]
00007c  e005              B        |L2.138|
                  |L2.126|
;;;234            }
;;;235            else
;;;236            {
;;;237                // 禁用发送中断
;;;238                USART_ITConfig(USART2, USART_IT_TXE, DISABLE);
00007e  2200              MOVS     r2,#0
000080  f2407127          MOV      r1,#0x727
000084  4801              LDR      r0,|L2.140|
000086  f7fffffe          BL       USART_ITConfig
                  |L2.138|
;;;239            }
;;;240        }
;;;241    
;;;242    }
00008a  bd70              POP      {r4-r6,pc}
;;;243    
                          ENDP

                  |L2.140|
                          DCD      0x40004400
                  |L2.144|
                          DCD      rxWriteIndex
                  |L2.148|
                          DCD      rxReadIndex
                  |L2.152|
                          DCD      rxBuffer
                  |L2.156|
                          DCD      txReadIndex
                  |L2.160|
                          DCD      txWriteIndex
                  |L2.164|
                          DCD      txBuffer

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;243    
;;;244    void USART3_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;245    {
;;;246    		// 接收中断
;;;247    	   if (USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
000002  f2405125          MOV      r1,#0x525
000006  4821              LDR      r0,|L3.140|
000008  f7fffffe          BL       USART_GetITStatus
00000c  b1c0              CBZ      r0,|L3.64|
;;;248    	   {
;;;249    		   uint8_t data = USART_ReceiveData(USART3);
00000e  481f              LDR      r0,|L3.140|
000010  f7fffffe          BL       USART_ReceiveData
000014  b2c5              UXTB     r5,r0
;;;250    		   uint16_t nextWriteIndex = (rxWriteIndex + 1) % BUFFER_SIZE;
000016  491e              LDR      r1,|L3.144|
000018  8809              LDRH     r1,[r1,#0]  ; rxWriteIndex
00001a  1c48              ADDS     r0,r1,#1
00001c  17c1              ASRS     r1,r0,#31
00001e  eb005191          ADD      r1,r0,r1,LSR #22
000022  1289              ASRS     r1,r1,#10
000024  eba02181          SUB      r1,r0,r1,LSL #10
000028  b28c              UXTH     r4,r1
;;;251    		   
;;;252    		   if (nextWriteIndex != rxReadIndex)
00002a  481a              LDR      r0,|L3.148|
00002c  8800              LDRH     r0,[r0,#0]  ; rxReadIndex
00002e  4284              CMP      r4,r0
000030  d005              BEQ      |L3.62|
;;;253    		   {
;;;254    			   rxBuffer[rxWriteIndex] = data;
000032  4819              LDR      r0,|L3.152|
000034  4916              LDR      r1,|L3.144|
000036  8809              LDRH     r1,[r1,#0]  ; rxWriteIndex
000038  5445              STRB     r5,[r0,r1]
;;;255    			   rxWriteIndex = nextWriteIndex;
00003a  4815              LDR      r0,|L3.144|
00003c  8004              STRH     r4,[r0,#0]
                  |L3.62|
;;;256    		   }
;;;257    		   // 否则，接收缓冲区满，丢弃数据或处理溢出情况
;;;258    	   }
00003e  bf00              NOP      
                  |L3.64|
;;;259    	
;;;260    	   // 发送中断
;;;261    	   if (USART_GetITStatus(USART3, USART_IT_TXE) != RESET)
000040  f2407127          MOV      r1,#0x727
000044  4811              LDR      r0,|L3.140|
000046  f7fffffe          BL       USART_GetITStatus
00004a  b1f0              CBZ      r0,|L3.138|
;;;262    	   {
;;;263    		   if (txReadIndex != txWriteIndex)
00004c  4813              LDR      r0,|L3.156|
00004e  8800              LDRH     r0,[r0,#0]  ; txReadIndex
000050  4913              LDR      r1,|L3.160|
000052  8809              LDRH     r1,[r1,#0]  ; txWriteIndex
000054  4288              CMP      r0,r1
000056  d012              BEQ      |L3.126|
;;;264    		   {
;;;265    			   USART_SendData(USART3, txBuffer[txReadIndex]);
000058  4812              LDR      r0,|L3.164|
00005a  4a10              LDR      r2,|L3.156|
00005c  8812              LDRH     r2,[r2,#0]  ; txReadIndex
00005e  5c81              LDRB     r1,[r0,r2]
000060  480a              LDR      r0,|L3.140|
000062  f7fffffe          BL       USART_SendData
;;;266    			   txReadIndex = (txReadIndex + 1) % BUFFER_SIZE;
000066  490d              LDR      r1,|L3.156|
000068  8809              LDRH     r1,[r1,#0]  ; txReadIndex
00006a  1c48              ADDS     r0,r1,#1
00006c  17c1              ASRS     r1,r0,#31
00006e  eb005191          ADD      r1,r0,r1,LSR #22
000072  1289              ASRS     r1,r1,#10
000074  eba02181          SUB      r1,r0,r1,LSL #10
000078  4a08              LDR      r2,|L3.156|
00007a  8011              STRH     r1,[r2,#0]
00007c  e005              B        |L3.138|
                  |L3.126|
;;;267    		   }
;;;268    		   else
;;;269    		   {
;;;270    			   // 禁用发送中断
;;;271    			   USART_ITConfig(USART3, USART_IT_TXE, DISABLE);
00007e  2200              MOVS     r2,#0
000080  f2407127          MOV      r1,#0x727
000084  4801              LDR      r0,|L3.140|
000086  f7fffffe          BL       USART_ITConfig
                  |L3.138|
;;;272    		   }
;;;273    	   }
;;;274    
;;;275    
;;;276    }
00008a  bd70              POP      {r4-r6,pc}
;;;277    
                          ENDP

                  |L3.140|
                          DCD      0x40004800
                  |L3.144|
                          DCD      rxWriteIndex
                  |L3.148|
                          DCD      rxReadIndex
                  |L3.152|
                          DCD      rxBuffer
                  |L3.156|
                          DCD      txReadIndex
                  |L3.160|
                          DCD      txWriteIndex
                  |L3.164|
                          DCD      txBuffer

                          AREA ||i.USART4_IRQHandler||, CODE, READONLY, ALIGN=1

                  USART4_IRQHandler PROC
;;;277    
;;;278    void USART4_IRQHandler(void)
000000  4770              BX       lr
;;;279    {
;;;280    
;;;281    }
;;;282    
                          ENDP


                          AREA ||i.USART5_IRQHandler||, CODE, READONLY, ALIGN=1

                  USART5_IRQHandler PROC
;;;282    
;;;283    void USART5_IRQHandler(void)
000000  4770              BX       lr
;;;284    {
;;;285    
;;;286    }
;;;287    
                          ENDP


                          AREA ||i.myprintf||, CODE, READONLY, ALIGN=1

                  myprintf PROC
;;;288    
;;;289    void myprintf(const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;290    {
000002  b500              PUSH     {lr}
000004  f2ad4d04          SUB      sp,sp,#0x404
;;;291    	// 声明一个字符数组作为缓冲区，用于存储格式化后的字符串
;;;292        char buffer[BUFFER_SIZE];
;;;293        
;;;294        // 声明一个 va_list 类型的变量 args，用于存储可变参数列表
;;;295        va_list args;
;;;296        
;;;297        // 初始化 args，使其指向可变参数列表的起始位置
;;;298        va_start(args, format);
000008  f20d400c          ADD      r0,sp,#0x40c
00000c  9000              STR      r0,[sp,#0]
;;;299        
;;;300        // 将格式化后的字符串写入缓冲区 buffer 中，最多写入 BUFFER_SIZE-1 个字符
;;;301        // vsnprintf 函数按照 format 中的格式化指令，格式化可变参数列表 args，并将结果存储在 buffer 中
;;;302        vsnprintf(buffer, BUFFER_SIZE, format, args);
00000e  f44f6180          MOV      r1,#0x400
000012  a801              ADD      r0,sp,#4
000014  9b00              LDR      r3,[sp,#0]
000016  f8dd2408          LDR      r2,[sp,#0x408]
00001a  f7fffffe          BL       vsnprintf
;;;303        
;;;304        // 结束 args 的使用
;;;305        va_end(args);
00001e  2000              MOVS     r0,#0
000020  9000              STR      r0,[sp,#0]
;;;306        
;;;307        // 调用 usart1SendString 函数，将 buffer 中的内容通过 USART1 发送出去
;;;308        usart1SendString(buffer);
000022  a801              ADD      r0,sp,#4
000024  f7fffffe          BL       usart1SendString
;;;309    }
000028  f20d4d04          ADD      sp,sp,#0x404
00002c  f85dfb14          LDR      pc,[sp],#0x14
;;;310    
                          ENDP


                          AREA ||i.usart1Init||, CODE, READONLY, ALIGN=2

                  usart1Init PROC
;;;22     */
;;;23     bool usart1Init(void)
000000  b500              PUSH     {lr}
;;;24     {
000002  b087              SUB      sp,sp,#0x1c
;;;25         GPIO_InitTypeDef GPIO_InitStructure;	
;;;26         USART_InitTypeDef USART_InitStructure;
;;;27     
;;;28         // 时钟GPIOA, AFIO, USART1使能
;;;29         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO | RCC_APB2Periph_USART1, ENABLE);
000004  2101              MOVS     r1,#1
000006  f2440005          MOV      r0,#0x4005
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;30     
;;;31         // 配置USART1 Tx (PA.9)
;;;32         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
00000e  f44f7000          MOV      r0,#0x200
000012  f8ad0018          STRH     r0,[sp,#0x18]
;;;33         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d001a          STRB     r0,[sp,#0x1a]
;;;34         GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d001b          STRB     r0,[sp,#0x1b]
;;;35         GPIO_Init(GPIOA, &GPIO_InitStructure);
000022  a906              ADD      r1,sp,#0x18
000024  481d              LDR      r0,|L7.156|
000026  f7fffffe          BL       GPIO_Init
;;;36     
;;;37         // 配置USART1 Rx (PA.10)
;;;38         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00002a  f44f6080          MOV      r0,#0x400
00002e  f8ad0018          STRH     r0,[sp,#0x18]
;;;39         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; // 浮空输入
000032  2004              MOVS     r0,#4
000034  f88d001b          STRB     r0,[sp,#0x1b]
;;;40         GPIO_Init(GPIOA, &GPIO_InitStructure);
000038  a906              ADD      r1,sp,#0x18
00003a  4818              LDR      r0,|L7.156|
00003c  f7fffffe          BL       GPIO_Init
;;;41     
;;;42         // 配置USART1
;;;43         USART_InitStructure.USART_BaudRate = 115200;
000040  f44f30e1          MOV      r0,#0x1c200
000044  9002              STR      r0,[sp,#8]
;;;44         USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000046  2000              MOVS     r0,#0
000048  f8ad000c          STRH     r0,[sp,#0xc]
;;;45         USART_InitStructure.USART_StopBits = USART_StopBits_1;
00004c  f8ad000e          STRH     r0,[sp,#0xe]
;;;46         USART_InitStructure.USART_Parity = USART_Parity_No;
000050  f8ad0010          STRH     r0,[sp,#0x10]
;;;47         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000054  f8ad0014          STRH     r0,[sp,#0x14]
;;;48         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000058  200c              MOVS     r0,#0xc
00005a  f8ad0012          STRH     r0,[sp,#0x12]
;;;49         USART_Init(USART1, &USART_InitStructure);
00005e  a902              ADD      r1,sp,#8
000060  480f              LDR      r0,|L7.160|
000062  f7fffffe          BL       USART_Init
;;;50     
;;;51         // 使能USART1
;;;52         USART_Cmd(USART1, ENABLE);
000066  2101              MOVS     r1,#1
000068  480d              LDR      r0,|L7.160|
00006a  f7fffffe          BL       USART_Cmd
;;;53     
;;;54         // 使能USART1中断
;;;55         USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
00006e  2201              MOVS     r2,#1
000070  f2405125          MOV      r1,#0x525
000074  480a              LDR      r0,|L7.160|
000076  f7fffffe          BL       USART_ITConfig
;;;56     
;;;57         // 配置NVIC
;;;58         NVIC_InitTypeDef NVIC_InitStructure;
;;;59         NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
00007a  2025              MOVS     r0,#0x25
00007c  f88d0004          STRB     r0,[sp,#4]
;;;60         NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000080  2000              MOVS     r0,#0
000082  f88d0005          STRB     r0,[sp,#5]
;;;61         NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000086  f88d0006          STRB     r0,[sp,#6]
;;;62         NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00008a  2001              MOVS     r0,#1
00008c  f88d0007          STRB     r0,[sp,#7]
;;;63         NVIC_Init(&NVIC_InitStructure);
000090  a801              ADD      r0,sp,#4
000092  f7fffffe          BL       NVIC_Init
;;;64     
;;;65         return true;
000096  2001              MOVS     r0,#1
;;;66     }
000098  b007              ADD      sp,sp,#0x1c
00009a  bd00              POP      {pc}
;;;67     
                          ENDP

                  |L7.156|
                          DCD      0x40010800
                  |L7.160|
                          DCD      0x40013800

                          AREA ||i.usart1SendData||, CODE, READONLY, ALIGN=2

                  usart1SendData PROC
;;;151    
;;;152    void usart1SendData(uint8_t data)
000000  b570              PUSH     {r4-r6,lr}
;;;153    {
000002  4604              MOV      r4,r0
;;;154        uint16_t nextWriteIndex = (txWriteIndex + 1) % BUFFER_SIZE;
000004  490e              LDR      r1,|L8.64|
000006  8809              LDRH     r1,[r1,#0]  ; txWriteIndex
000008  1c48              ADDS     r0,r1,#1
00000a  17c1              ASRS     r1,r0,#31
00000c  eb005191          ADD      r1,r0,r1,LSR #22
000010  1289              ASRS     r1,r1,#10
000012  eba02181          SUB      r1,r0,r1,LSL #10
000016  b28d              UXTH     r5,r1
;;;155        
;;;156        // 检查缓冲区是否溢出
;;;157        if (nextWriteIndex == txReadIndex)
000018  480a              LDR      r0,|L8.68|
00001a  8800              LDRH     r0,[r0,#0]  ; txReadIndex
00001c  4285              CMP      r5,r0
00001e  d100              BNE      |L8.34|
                  |L8.32|
;;;158        {
;;;159            // 缓冲区满，等待或者处理溢出情况
;;;160            return;
;;;161        }
;;;162        
;;;163        txBuffer[txWriteIndex] = data;
;;;164        txWriteIndex = nextWriteIndex;
;;;165        
;;;166        // 使能发送中断
;;;167        USART_ITConfig(USART1, USART_IT_TXE, ENABLE);// 使能发送中断
;;;168    }
000020  bd70              POP      {r4-r6,pc}
                  |L8.34|
000022  4809              LDR      r0,|L8.72|
000024  4906              LDR      r1,|L8.64|
000026  8809              LDRH     r1,[r1,#0]            ;163  ; txWriteIndex
000028  5444              STRB     r4,[r0,r1]            ;163
00002a  4805              LDR      r0,|L8.64|
00002c  8005              STRH     r5,[r0,#0]            ;164
00002e  2201              MOVS     r2,#1                 ;167
000030  f2407127          MOV      r1,#0x727             ;167
000034  4805              LDR      r0,|L8.76|
000036  f7fffffe          BL       USART_ITConfig
00003a  bf00              NOP      
00003c  e7f0              B        |L8.32|
;;;169    
                          ENDP

00003e  0000              DCW      0x0000
                  |L8.64|
                          DCD      txWriteIndex
                  |L8.68|
                          DCD      txReadIndex
                  |L8.72|
                          DCD      txBuffer
                  |L8.76|
                          DCD      0x40013800

                          AREA ||i.usart1SendString||, CODE, READONLY, ALIGN=1

                  usart1SendString PROC
;;;169    
;;;170    void usart1SendString(const char* str)
000000  b510              PUSH     {r4,lr}
;;;171    {
000002  4604              MOV      r4,r0
;;;172        while (*str)
000004  e003              B        |L9.14|
                  |L9.6|
;;;173        {
;;;174            usart1SendData(*str++);
000006  f8140b01          LDRB     r0,[r4],#1
00000a  f7fffffe          BL       usart1SendData
                  |L9.14|
00000e  7820              LDRB     r0,[r4,#0]            ;172
000010  2800              CMP      r0,#0                 ;172
000012  d1f8              BNE      |L9.6|
;;;175        }
;;;176    }
000014  bd10              POP      {r4,pc}
;;;177    
                          ENDP


                          AREA ||i.usart2Init||, CODE, READONLY, ALIGN=2

                  usart2Init PROC
;;;74     */
;;;75     bool usart2Init(void)
000000  b500              PUSH     {lr}
;;;76     {
000002  b085              SUB      sp,sp,#0x14
;;;77     	GPIO_InitTypeDef GPIO_InitStructure ;	
;;;78         USART_InitTypeDef USART_InitStructure;
;;;79     
;;;80     	//时钟GPIOA,AFIO,USART2使能
;;;81     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;82     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2 , ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0448              LSLS     r0,r1,#17
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;83      
;;;84     	//配置USART2 Tx (PA.2)
;;;85     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000014  2004              MOVS     r0,#4
000016  f8ad0010          STRH     r0,[sp,#0x10]
;;;86     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001a  2003              MOVS     r0,#3
00001c  f88d0012          STRB     r0,[sp,#0x12]
;;;87     	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
000020  2018              MOVS     r0,#0x18
000022  f88d0013          STRB     r0,[sp,#0x13]
;;;88     	GPIO_Init(GPIOA, &GPIO_InitStructure);
000026  a904              ADD      r1,sp,#0x10
000028  4816              LDR      r0,|L10.132|
00002a  f7fffffe          BL       GPIO_Init
;;;89     
;;;90         // 配置USART2 Rx (PA.3)
;;;91         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
00002e  2008              MOVS     r0,#8
000030  f8ad0010          STRH     r0,[sp,#0x10]
;;;92         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; // 浮空输入
000034  2004              MOVS     r0,#4
000036  f88d0013          STRB     r0,[sp,#0x13]
;;;93         GPIO_Init(GPIOA, &GPIO_InitStructure);
00003a  a904              ADD      r1,sp,#0x10
00003c  4811              LDR      r0,|L10.132|
00003e  f7fffffe          BL       GPIO_Init
;;;94     
;;;95         // 配置USART2
;;;96         USART_InitStructure.USART_BaudRate = 115200;
000042  f44f30e1          MOV      r0,#0x1c200
000046  9000              STR      r0,[sp,#0]
;;;97         USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000048  2000              MOVS     r0,#0
00004a  f8ad0004          STRH     r0,[sp,#4]
;;;98         USART_InitStructure.USART_StopBits = USART_StopBits_1;
00004e  f8ad0006          STRH     r0,[sp,#6]
;;;99         USART_InitStructure.USART_Parity = USART_Parity_No;
000052  f8ad0008          STRH     r0,[sp,#8]
;;;100        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000056  f8ad000c          STRH     r0,[sp,#0xc]
;;;101        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005a  200c              MOVS     r0,#0xc
00005c  f8ad000a          STRH     r0,[sp,#0xa]
;;;102        USART_Init(USART2, &USART_InitStructure);
000060  4669              MOV      r1,sp
000062  4809              LDR      r0,|L10.136|
000064  f7fffffe          BL       USART_Init
;;;103    
;;;104        // 使能USART2
;;;105        USART_Cmd(USART2, ENABLE);
000068  2101              MOVS     r1,#1
00006a  4807              LDR      r0,|L10.136|
00006c  f7fffffe          BL       USART_Cmd
;;;106    	
;;;107    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000070  2201              MOVS     r2,#1
000072  f2405125          MOV      r1,#0x525
000076  4804              LDR      r0,|L10.136|
000078  f7fffffe          BL       USART_ITConfig
;;;108    
;;;109    	return true;
00007c  2001              MOVS     r0,#1
;;;110    }
00007e  b005              ADD      sp,sp,#0x14
000080  bd00              POP      {pc}
;;;111    
                          ENDP

000082  0000              DCW      0x0000
                  |L10.132|
                          DCD      0x40010800
                  |L10.136|
                          DCD      0x40004400

                          AREA ||i.usart3Init||, CODE, READONLY, ALIGN=2

                  usart3Init PROC
;;;116    */
;;;117    bool usart3Init(void)
000000  b500              PUSH     {lr}
;;;118    {
000002  b085              SUB      sp,sp,#0x14
;;;119    	GPIO_InitTypeDef GPIO_InitStructure ;	
;;;120        USART_InitTypeDef USART_InitStructure;
;;;121    
;;;122    	//时钟GPIOA,AFIO,USART2使能
;;;123    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2009              MOVS     r0,#9
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;124    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3 , ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0488              LSLS     r0,r1,#18
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;125     
;;;126    	//配置USART3 Tx (PB.10)
;;;127    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000014  f44f6080          MOV      r0,#0x400
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;128    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0012          STRB     r0,[sp,#0x12]
;;;129    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;
000022  2018              MOVS     r0,#0x18
000024  f88d0013          STRB     r0,[sp,#0x13]
;;;130    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  4817              LDR      r0,|L11.136|
00002c  f7fffffe          BL       GPIO_Init
;;;131    
;;;132        // 配置USART3 Rx (PB.11)
;;;133        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000030  f44f6000          MOV      r0,#0x800
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;134        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; // 浮空输入
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;135        GPIO_Init(GPIOB, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4811              LDR      r0,|L11.136|
000042  f7fffffe          BL       GPIO_Init
;;;136    
;;;137        // 配置USART3
;;;138        USART_InitStructure.USART_BaudRate = 115200;
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9000              STR      r0,[sp,#0]
;;;139        USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;140        USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;141        USART_InitStructure.USART_Parity = USART_Parity_No;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;142        USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;143        USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;144        USART_Init(USART3, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  4809              LDR      r0,|L11.140|
000068  f7fffffe          BL       USART_Init
;;;145    
;;;146        // 使能USART2
;;;147        USART_Cmd(USART3, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  4807              LDR      r0,|L11.140|
000070  f7fffffe          BL       USART_Cmd
;;;148    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
000074  2201              MOVS     r2,#1
000076  f2405125          MOV      r1,#0x525
00007a  4804              LDR      r0,|L11.140|
00007c  f7fffffe          BL       USART_ITConfig
;;;149    	return true;
000080  2001              MOVS     r0,#1
;;;150    }
000082  b005              ADD      sp,sp,#0x14
000084  bd00              POP      {pc}
;;;151    
                          ENDP

000086  0000              DCW      0x0000
                  |L11.136|
                          DCD      0x40010c00
                  |L11.140|
                          DCD      0x40004800

                          AREA ||i.usartCyclicCheck||, CODE, READONLY, ALIGN=1

                  usartCyclicCheck PROC
;;;311    
;;;312    void usartCyclicCheck(void)
000000  4770              BX       lr
;;;313    {
;;;314    	return;
;;;315    
;;;316    }
;;;317    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  txBuffer
                          %        1024
                  rxBuffer
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  txWriteIndex
000000  0000              DCW      0x0000
                  txReadIndex
000002  0000              DCW      0x0000
                  rxWriteIndex
000004  0000              DCW      0x0000
                  rxReadIndex
000006  0000              DCW      0x0000
                  Usart1Connfig
000008  00000000          DCW      0x0000,0x0000
00000c  0400              DCW      0x0400
                  Usart2Connfig
00000e  0000              DCW      0x0000
000010  00000400          DCW      0x0000,0x0400
                  Usart3Connfig
000014  00000000          DCW      0x0000,0x0000
000018  0400              DCW      0x0400
                  usart_recv_data_flag
00001a  0000              DCB      0x00,0x00
                  usart_num
                          DCD      0x40013800
                          DCD      0x40004400
                          DCD      0x40004800
                          DCD      0x40004c00
                          DCD      0x40005000
                  CMD_FLAG
000030  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\Driver\\Src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_95cfd769____REV16|
#line 463 "..\\Core\\Inc\\cmsis_armcc.h"
|__asm___6_uart_c_95cfd769____REV16| PROC
#line 464

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_95cfd769____REVSH|
#line 478
|__asm___6_uart_c_95cfd769____REVSH| PROC
#line 479

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_95cfd769____RRX|
#line 665
|__asm___6_uart_c_95cfd769____RRX| PROC
#line 666

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

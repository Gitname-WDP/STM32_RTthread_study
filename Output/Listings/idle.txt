; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\idle.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\idle.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\idle.crf ..\rtthread\src\idle.c]
                          THUMB

                          AREA ||i._has_defunct_thread||, CODE, READONLY, ALIGN=2

                  _has_defunct_thread PROC
;;;72     /* Return whether there is defunctional thread to be deleted. */
;;;73     rt_inline int _has_defunct_thread(void)
000000  4903              LDR      r1,|L1.16|
;;;74     {
;;;75         /* The rt_list_isempty has prototype of "int rt_list_isempty(const rt_list_t *l)".
;;;76          * So the compiler has a good reason that the rt_thread_defunct list does
;;;77          * not change within rt_thread_idle_excute thus optimize the "while" loop
;;;78          * into a "if".
;;;79          *
;;;80          * So add the volatile qualifier here. */
;;;81         const volatile rt_list_t *l = (const volatile rt_list_t *)&rt_thread_defunct;
;;;82     
;;;83         return l->next != l;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d001              BEQ      |L1.12|
000008  2001              MOVS     r0,#1
                  |L1.10|
;;;84     }
00000a  4770              BX       lr
                  |L1.12|
00000c  2000              MOVS     r0,#0                 ;83
00000e  e7fc              B        |L1.10|
;;;85     
                          ENDP

                  |L1.16|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_idle_entry||, CODE, READONLY, ALIGN=1

                  rt_thread_idle_entry PROC
;;;198    
;;;199    static void rt_thread_idle_entry(void *parameter)
000000  e001              B        |L2.6|
                  |L2.2|
;;;200    {
;;;201        while (1)
;;;202        {
;;;203    #ifdef RT_USING_IDLE_HOOK
;;;204            if (rt_thread_idle_hook != RT_NULL)
;;;205            {
;;;206                rt_thread_idle_hook();
;;;207            }
;;;208    #endif
;;;209    
;;;210            rt_thread_idle_excute();
000002  f7fffffe          BL       rt_thread_idle_excute
                  |L2.6|
000006  e7fc              B        |L2.2|
;;;211        }
;;;212    }
;;;213    
                          ENDP


                          AREA ||i.rt_thread_idle_excute||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_excute PROC
;;;90      */
;;;91     void rt_thread_idle_excute(void)
000000  b570              PUSH     {r4-r6,lr}
;;;92     {
;;;93         /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
;;;94          * will do all the cleanups. */
;;;95         while (_has_defunct_thread())
000002  e037              B        |L3.116|
                  |L3.4|
;;;96         {
;;;97             rt_base_t lock;
;;;98             rt_thread_t thread;
;;;99     #ifdef RT_USING_MODULE
;;;100            rt_module_t module = RT_NULL;
;;;101    #endif
;;;102            RT_DEBUG_NOT_IN_INTERRUPT;
;;;103    
;;;104            /* disable interrupt */
;;;105            lock = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;106    
;;;107            /* re-check whether list is empty */
;;;108            if (_has_defunct_thread())
00000a  f7fffffe          BL       _has_defunct_thread
00000e  b318              CBZ      r0,|L3.88|
;;;109            {
;;;110                /* get defunct thread */
;;;111                thread = rt_list_entry(rt_thread_defunct.next,
000010  481b              LDR      r0,|L3.128|
000012  6800              LDR      r0,[r0,#0]  ; rt_thread_defunct
000014  f1a00414          SUB      r4,r0,#0x14
;;;112                                       struct rt_thread,
;;;113                                       tlist);
;;;114    #ifdef RT_USING_MODULE
;;;115                /* get thread's parent module */
;;;116                module = (rt_module_t)thread->module_id;
;;;117    
;;;118                /* if the thread is module's main thread */
;;;119                if (module != RT_NULL && module->module_thread == thread)
;;;120                {
;;;121                    /* detach module's main thread */
;;;122                    module->module_thread = RT_NULL;
;;;123                }
;;;124    #endif
;;;125                /* remove defunct thread */
;;;126                rt_list_remove(&(thread->tlist));
000018  f1040014          ADD      r0,r4,#0x14
00001c  e9d02100          LDRD     r2,r1,[r0,#0]
000020  6051              STR      r1,[r2,#4]
000022  e9d01200          LDRD     r1,r2,[r0,#0]
000026  6011              STR      r1,[r2,#0]
000028  6040              STR      r0,[r0,#4]
00002a  6000              STR      r0,[r0,#0]
00002c  bf00              NOP      
;;;127    
;;;128                /* lock scheduler to prevent scheduling in cleanup function. */
;;;129                rt_enter_critical();
00002e  f7fffffe          BL       rt_enter_critical
;;;130    
;;;131                /* invoke thread cleanup */
;;;132                if (thread->cleanup != RT_NULL)
000032  6f20              LDR      r0,[r4,#0x70]
000034  b110              CBZ      r0,|L3.60|
;;;133                    thread->cleanup(thread);
000036  4620              MOV      r0,r4
000038  6f21              LDR      r1,[r4,#0x70]
00003a  4788              BLX      r1
                  |L3.60|
;;;134    
;;;135    #ifdef RT_USING_SIGNALS
;;;136                rt_thread_free_sig(thread);
;;;137    #endif
;;;138    
;;;139                /* if it's a system object, not delete it */
;;;140                if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       rt_object_is_systemobject
000042  2801              CMP      r0,#1
000044  d105              BNE      |L3.82|
;;;141                {
;;;142                    /* unlock scheduler */
;;;143                    rt_exit_critical();
000046  f7fffffe          BL       rt_exit_critical
;;;144    
;;;145                    /* enable interrupt */
;;;146                    rt_hw_interrupt_enable(lock);
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       rt_hw_interrupt_enable
                  |L3.80|
;;;147    
;;;148                    return;
;;;149                }
;;;150    
;;;151                /* unlock scheduler */
;;;152                rt_exit_critical();
;;;153            }
;;;154            else
;;;155            {
;;;156                /* enable interrupt */
;;;157                rt_hw_interrupt_enable(lock);
;;;158    
;;;159                /* may the defunct thread list is removed by others, just return */
;;;160                return;
;;;161            }
;;;162    
;;;163            /* enable interrupt */
;;;164            rt_hw_interrupt_enable(lock);
;;;165    
;;;166    #ifdef RT_USING_HEAP
;;;167    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;168            /* the thread belongs to an application module */
;;;169            if (thread->flags & RT_OBJECT_FLAG_MODULE)
;;;170                rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
;;;171            else
;;;172    #endif
;;;173                /* release thread's stack */
;;;174                RT_KERNEL_FREE(thread->stack_addr);
;;;175            /* delete thread object */
;;;176            rt_object_delete((rt_object_t)thread);
;;;177    #endif
;;;178    
;;;179    #ifdef RT_USING_MODULE
;;;180            if (module != RT_NULL)
;;;181            {
;;;182                extern rt_err_t rt_module_destroy(rt_module_t module);
;;;183    
;;;184                /* if sub thread list and main thread are all empty */
;;;185                if ((module->module_thread == RT_NULL) &&
;;;186                    rt_list_isempty(&module->module_object[RT_Object_Class_Thread].object_list))
;;;187                {
;;;188                    module->nref --;
;;;189                }
;;;190    
;;;191                /* destroy module */
;;;192                if (module->nref == 0)
;;;193                    rt_module_destroy(module);
;;;194            }
;;;195    #endif
;;;196        }
;;;197    }
000050  bd70              POP      {r4-r6,pc}
                  |L3.82|
000052  f7fffffe          BL       rt_exit_critical
000056  e003              B        |L3.96|
                  |L3.88|
000058  4628              MOV      r0,r5                 ;157
00005a  f7fffffe          BL       rt_hw_interrupt_enable
00005e  e7f7              B        |L3.80|
                  |L3.96|
000060  4628              MOV      r0,r5                 ;164
000062  f7fffffe          BL       rt_hw_interrupt_enable
000066  6aa0              LDR      r0,[r4,#0x28]         ;174
000068  f7fffffe          BL       rt_free
00006c  4620              MOV      r0,r4                 ;176
00006e  f7fffffe          BL       rt_object_delete
000072  bf00              NOP                            ;196
                  |L3.116|
000074  f7fffffe          BL       _has_defunct_thread
000078  2800              CMP      r0,#0                 ;95
00007a  d1c3              BNE      |L3.4|
00007c  bf00              NOP      
00007e  e7e7              B        |L3.80|
;;;198    
                          ENDP

                  |L3.128|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_idle_gethandler||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_gethandler PROC
;;;242     */
;;;243    rt_thread_t rt_thread_idle_gethandler(void)
000000  4800              LDR      r0,|L4.4|
;;;244    {
;;;245        return (rt_thread_t)(&idle);
;;;246    }
000002  4770              BX       lr
                          ENDP

                  |L4.4|
                          DCD      idle

                          AREA ||i.rt_thread_idle_init||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_init PROC
;;;220     */
;;;221    void rt_thread_idle_init(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;222    {
;;;223        /* initialize thread */
;;;224        rt_thread_init(&idle,
000002  2020              MOVS     r0,#0x20
000004  211f              MOVS     r1,#0x1f
000006  00c2              LSLS     r2,r0,#3
000008  4b07              LDR      r3,|L5.40|
00000a  e9cd3200          STRD     r3,r2,[sp,#0]
00000e  e9cd1002          STRD     r1,r0,[sp,#8]
000012  2300              MOVS     r3,#0
000014  4a05              LDR      r2,|L5.44|
000016  a106              ADR      r1,|L5.48|
000018  4807              LDR      r0,|L5.56|
00001a  f7fffffe          BL       rt_thread_init
;;;225                       "tidle",
;;;226                       rt_thread_idle_entry,
;;;227                       RT_NULL,
;;;228                       &rt_thread_stack[0],
;;;229                       sizeof(rt_thread_stack),
;;;230                       RT_THREAD_PRIORITY_MAX - 1,
;;;231                       32);
;;;232    
;;;233        /* startup */
;;;234        rt_thread_startup(&idle);
00001e  4806              LDR      r0,|L5.56|
000020  f7fffffe          BL       rt_thread_startup
;;;235    }
000024  bd1f              POP      {r0-r4,pc}
;;;236    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      rt_thread_stack
                  |L5.44|
                          DCD      rt_thread_idle_entry
                  |L5.48|
000030  7469646c          DCB      "tidle",0
000034  6500    
000036  00                DCB      0
000037  00                DCB      0
                  |L5.56|
                          DCD      idle

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  idle
                          %        120
                  rt_thread_stack
                          %        256

; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\kservice.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\kservice.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\kservice.crf ..\rtthread\src\kservice.c]
                          THUMB

                          AREA ||i.__rt_ffs||, CODE, READONLY, ALIGN=2

                  __rt_ffs PROC
;;;1278    */
;;;1279   int __rt_ffs(int value)
000000  4601              MOV      r1,r0
;;;1280   {
;;;1281       if (value == 0) return 0;
000002  b909              CBNZ     r1,|L1.8|
000004  2000              MOVS     r0,#0
                  |L1.6|
;;;1282   
;;;1283       if (value & 0xff)
;;;1284           return __lowest_bit_bitmap[value & 0xff] + 1;
;;;1285   
;;;1286       if (value & 0xff00)
;;;1287           return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
;;;1288   
;;;1289       if (value & 0xff0000)
;;;1290           return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
;;;1291   
;;;1292       return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
;;;1293   }
000006  4770              BX       lr
                  |L1.8|
000008  b2c8              UXTB     r0,r1                 ;1283
00000a  b120              CBZ      r0,|L1.22|
00000c  b2c8              UXTB     r0,r1                 ;1284
00000e  4a0e              LDR      r2,|L1.72|
000010  5c10              LDRB     r0,[r2,r0]            ;1284
000012  1c40              ADDS     r0,r0,#1              ;1284
000014  e7f7              B        |L1.6|
                  |L1.22|
000016  f401407f          AND      r0,r1,#0xff00         ;1286
00001a  b128              CBZ      r0,|L1.40|
00001c  480a              LDR      r0,|L1.72|
00001e  f3c12207          UBFX     r2,r1,#8,#8           ;1287
000022  5c80              LDRB     r0,[r0,r2]            ;1287
000024  3009              ADDS     r0,r0,#9              ;1287
000026  e7ee              B        |L1.6|
                  |L1.40|
000028  f401007f          AND      r0,r1,#0xff0000       ;1289
00002c  b128              CBZ      r0,|L1.58|
00002e  4806              LDR      r0,|L1.72|
000030  f3c14207          UBFX     r2,r1,#16,#8          ;1290
000034  5c80              LDRB     r0,[r0,r2]            ;1290
000036  3011              ADDS     r0,r0,#0x11           ;1290
000038  e7e5              B        |L1.6|
                  |L1.58|
00003a  4803              LDR      r0,|L1.72|
00003c  eb006011          ADD      r0,r0,r1,LSR #24      ;1292
000040  7800              LDRB     r0,[r0,#0]            ;1292
000042  3019              ADDS     r0,r0,#0x19           ;1292
000044  e7df              B        |L1.6|
;;;1294   #endif
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      __lowest_bit_bitmap

                          AREA ||i._rt_errno||, CODE, READONLY, ALIGN=2

                  _rt_errno PROC
;;;111     */
;;;112    int *_rt_errno(void)
000000  b510              PUSH     {r4,lr}
;;;113    {
;;;114        rt_thread_t tid;
;;;115    
;;;116        if (rt_interrupt_get_nest() != 0)
000002  f7fffffe          BL       rt_interrupt_get_nest
000006  b108              CBZ      r0,|L2.12|
;;;117            return (int *)&__rt_errno;
000008  4805              LDR      r0,|L2.32|
                  |L2.10|
;;;118    
;;;119        tid = rt_thread_self();
;;;120        if (tid != RT_NULL)
;;;121            return (int *) & (tid->error);
;;;122    
;;;123        return (int *)&__rt_errno;
;;;124    }
00000a  bd10              POP      {r4,pc}
                  |L2.12|
00000c  f7fffffe          BL       rt_thread_self
000010  4604              MOV      r4,r0                 ;119
000012  b114              CBZ      r4,|L2.26|
000014  f1040030          ADD      r0,r4,#0x30           ;121
000018  e7f7              B        |L2.10|
                  |L2.26|
00001a  4801              LDR      r0,|L2.32|
00001c  e7f5              B        |L2.10|
;;;125    RTM_EXPORT(_rt_errno);
                          ENDP

00001e  0000              DCW      0x0000
                  |L2.32|
                          DCD      __rt_errno

                          AREA ||i.print_number||, CODE, READONLY, ALIGN=2

                  print_number PROC
;;;588    #ifdef RT_PRINTF_PRECISION
;;;589    static char *print_number(char *buf,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;590                              char *end,
;;;591                              long  num,
;;;592                              int   base,
;;;593                              int   s,
;;;594                              int   precision,
;;;595                              int   type)
;;;596    #else
;;;597    static char *print_number(char *buf,
;;;598                              char *end,
;;;599                              long  num,
;;;600                              int   base,
;;;601                              int   s,
;;;602                              int   type)
;;;603    #endif
;;;604    {
000004  b085              SUB      sp,sp,#0x14
000006  460d              MOV      r5,r1
000008  469c              MOV      r12,r3
00000a  e9dd740f          LDRD     r7,r4,[sp,#0x3c]
;;;605        char c, sign;
;;;606    #ifdef RT_PRINTF_LONGLONG
;;;607        char tmp[32];
;;;608    #else
;;;609        char tmp[16];
;;;610    #endif
;;;611        const char *digits;
;;;612        static const char small_digits[] = "0123456789abcdef";
;;;613        static const char large_digits[] = "0123456789ABCDEF";
;;;614        register int i;
;;;615        register int size;
;;;616    
;;;617        size = s;
00000e  9b0e              LDR      r3,[sp,#0x38]
;;;618    
;;;619        digits = (type & LARGE) ? large_digits : small_digits;
000010  f0040840          AND      r8,r4,#0x40
000014  f1b80f00          CMP      r8,#0
000018  d002              BEQ      |L3.32|
00001a  f8df8168          LDR      r8,|L3.388|
00001e  e001              B        |L3.36|
                  |L3.32|
000020  f8df8164          LDR      r8,|L3.392|
                  |L3.36|
000024  f8cd8000          STR      r8,[sp,#0]
;;;620        if (type & LEFT)
000028  f0040810          AND      r8,r4,#0x10
00002c  f1b80f00          CMP      r8,#0
000030  d001              BEQ      |L3.54|
;;;621            type &= ~ZEROPAD;
000032  f0240401          BIC      r4,r4,#1
                  |L3.54|
;;;622    
;;;623        c = (type & ZEROPAD) ? '0' : ' ';
000036  f0040801          AND      r8,r4,#1
00003a  f1b80f00          CMP      r8,#0
00003e  d002              BEQ      |L3.70|
000040  f04f0830          MOV      r8,#0x30
000044  e001              B        |L3.74|
                  |L3.70|
000046  f04f0820          MOV      r8,#0x20
                  |L3.74|
00004a  46c2              MOV      r10,r8
;;;624    
;;;625        /* get sign */
;;;626        sign = 0;
00004c  2600              MOVS     r6,#0
;;;627        if (type & SIGN)
00004e  f0040802          AND      r8,r4,#2
000052  f1b80f00          CMP      r8,#0
000056  d011              BEQ      |L3.124|
;;;628        {
;;;629            if (num < 0)
000058  2a00              CMP      r2,#0
00005a  da02              BGE      |L3.98|
;;;630            {
;;;631                sign = '-';
00005c  262d              MOVS     r6,#0x2d
;;;632                num = -num;
00005e  4252              RSBS     r2,r2,#0
000060  e00c              B        |L3.124|
                  |L3.98|
;;;633            }
;;;634            else if (type & PLUS)
000062  f0040804          AND      r8,r4,#4
000066  f1b80f00          CMP      r8,#0
00006a  d001              BEQ      |L3.112|
;;;635                sign = '+';
00006c  262b              MOVS     r6,#0x2b
00006e  e005              B        |L3.124|
                  |L3.112|
;;;636            else if (type & SPACE)
000070  f0040808          AND      r8,r4,#8
000074  f1b80f00          CMP      r8,#0
000078  d000              BEQ      |L3.124|
;;;637                sign = ' ';
00007a  2620              MOVS     r6,#0x20
                  |L3.124|
;;;638        }
;;;639    
;;;640    #ifdef RT_PRINTF_SPECIAL
;;;641        if (type & SPECIAL)
;;;642        {
;;;643            if (base == 16)
;;;644                size -= 2;
;;;645            else if (base == 8)
;;;646                size--;
;;;647        }
;;;648    #endif
;;;649    
;;;650        i = 0;
00007c  2100              MOVS     r1,#0
;;;651        if (num == 0)
00007e  b942              CBNZ     r2,|L3.146|
;;;652            tmp[i++] = '0';
000080  f04f0b30          MOV      r11,#0x30
000084  4688              MOV      r8,r1
000086  1c49              ADDS     r1,r1,#1
000088  f10d0904          ADD      r9,sp,#4
00008c  f809b008          STRB     r11,[r9,r8]
000090  e01d              B        |L3.206|
                  |L3.146|
;;;653        else
;;;654        {
;;;655            while (num != 0)
000092  e01a              B        |L3.202|
                  |L3.148|
;;;656                tmp[i++] = digits[divide(&num, base)];
000094  46e1              MOV      r9,r12
000096  f1b90f0a          CMP      r9,#0xa
00009a  d108              BNE      |L3.174|
00009c  f04f0b0a          MOV      r11,#0xa
0000a0  fbb2fefb          UDIV     lr,r2,r11
0000a4  fb0b281e          MLS      r8,r11,lr,r2
0000a8  fbb2f2fb          UDIV     r2,r2,r11
0000ac  e002              B        |L3.180|
                  |L3.174|
0000ae  f002080f          AND      r8,r2,#0xf
0000b2  0912              LSRS     r2,r2,#4
                  |L3.180|
0000b4  bf00              NOP      
0000b6  f8dd9000          LDR      r9,[sp,#0]
0000ba  f819b008          LDRB     r11,[r9,r8]
0000be  4688              MOV      r8,r1
0000c0  1c49              ADDS     r1,r1,#1
0000c2  f10d0904          ADD      r9,sp,#4
0000c6  f809b008          STRB     r11,[r9,r8]
                  |L3.202|
0000ca  2a00              CMP      r2,#0                 ;655
0000cc  d1e2              BNE      |L3.148|
                  |L3.206|
;;;657        }
;;;658    
;;;659    #ifdef RT_PRINTF_PRECISION
;;;660        if (i > precision)
0000ce  42b9              CMP      r1,r7
0000d0  dd00              BLE      |L3.212|
;;;661            precision = i;
0000d2  460f              MOV      r7,r1
                  |L3.212|
;;;662        size -= precision;
0000d4  1bdb              SUBS     r3,r3,r7
;;;663    #else
;;;664        size -= i;
;;;665    #endif
;;;666    
;;;667        if (!(type & (ZEROPAD | LEFT)))
0000d6  f0040811          AND      r8,r4,#0x11
0000da  f1b80f00          CMP      r8,#0
0000de  d110              BNE      |L3.258|
;;;668        {
;;;669            if ((sign) && (size > 0))
0000e0  b116              CBZ      r6,|L3.232|
0000e2  2b00              CMP      r3,#0
0000e4  dd00              BLE      |L3.232|
;;;670                size--;
0000e6  1e5b              SUBS     r3,r3,#1
                  |L3.232|
;;;671    
;;;672            while (size-- > 0)
0000e8  e006              B        |L3.248|
                  |L3.234|
;;;673            {
;;;674                if (buf <= end)
0000ea  42a8              CMP      r0,r5
0000ec  d803              BHI      |L3.246|
;;;675                    *buf = ' ';
0000ee  f04f0820          MOV      r8,#0x20
0000f2  f8808000          STRB     r8,[r0,#0]
                  |L3.246|
;;;676                ++ buf;
0000f6  1c40              ADDS     r0,r0,#1
                  |L3.248|
0000f8  f1b30800          SUBS     r8,r3,#0              ;672
0000fc  f1a30301          SUB      r3,r3,#1              ;672
000100  dcf3              BGT      |L3.234|
                  |L3.258|
;;;677            }
;;;678        }
;;;679    
;;;680        if (sign)
000102  b126              CBZ      r6,|L3.270|
;;;681        {
;;;682            if (buf <= end)
000104  42a8              CMP      r0,r5
000106  d801              BHI      |L3.268|
;;;683            {
;;;684                *buf = sign;
000108  7006              STRB     r6,[r0,#0]
;;;685                -- size;
00010a  1e5b              SUBS     r3,r3,#1
                  |L3.268|
;;;686            }
;;;687            ++ buf;
00010c  1c40              ADDS     r0,r0,#1
                  |L3.270|
;;;688        }
;;;689    
;;;690    #ifdef RT_PRINTF_SPECIAL
;;;691        if (type & SPECIAL)
;;;692        {
;;;693            if (base == 8)
;;;694            {
;;;695                if (buf <= end)
;;;696                    *buf = '0';
;;;697                ++ buf;
;;;698            }
;;;699            else if (base == 16)
;;;700            {
;;;701                if (buf <= end)
;;;702                    *buf = '0';
;;;703                ++ buf;
;;;704                if (buf <= end)
;;;705                {
;;;706                    *buf = type & LARGE ? 'X' : 'x';
;;;707                }
;;;708                ++ buf;
;;;709            }
;;;710        }
;;;711    #endif
;;;712    
;;;713        /* no align to the left */
;;;714        if (!(type & LEFT))
00010e  f0040810          AND      r8,r4,#0x10
000112  f1b80f00          CMP      r8,#0
000116  d10a              BNE      |L3.302|
;;;715        {
;;;716            while (size-- > 0)
000118  e004              B        |L3.292|
                  |L3.282|
;;;717            {
;;;718                if (buf <= end)
00011a  42a8              CMP      r0,r5
00011c  d801              BHI      |L3.290|
;;;719                    *buf = c;
00011e  f880a000          STRB     r10,[r0,#0]
                  |L3.290|
;;;720                ++ buf;
000122  1c40              ADDS     r0,r0,#1
                  |L3.292|
000124  f1b30800          SUBS     r8,r3,#0              ;716
000128  f1a30301          SUB      r3,r3,#1              ;716
00012c  dcf5              BGT      |L3.282|
                  |L3.302|
;;;721            }
;;;722        }
;;;723    
;;;724    #ifdef RT_PRINTF_PRECISION
;;;725        while (i < precision--)
00012e  e006              B        |L3.318|
                  |L3.304|
;;;726        {
;;;727            if (buf <= end)
000130  42a8              CMP      r0,r5
000132  d803              BHI      |L3.316|
;;;728                *buf = '0';
000134  f04f0830          MOV      r8,#0x30
000138  f8808000          STRB     r8,[r0,#0]
                  |L3.316|
;;;729            ++ buf;
00013c  1c40              ADDS     r0,r0,#1
                  |L3.318|
00013e  46b8              MOV      r8,r7                 ;725
000140  1e7f              SUBS     r7,r7,#1              ;725
000142  4588              CMP      r8,r1                 ;725
000144  dcf4              BGT      |L3.304|
;;;730        }
;;;731    #endif
;;;732    
;;;733        /* put number in the temporary buffer */
;;;734        while (i-- > 0)
000146  e008              B        |L3.346|
                  |L3.328|
;;;735        {
;;;736            if (buf <= end)
000148  42a8              CMP      r0,r5
00014a  d805              BHI      |L3.344|
;;;737                *buf = tmp[i];
00014c  f10d0804          ADD      r8,sp,#4
000150  f8188001          LDRB     r8,[r8,r1]
000154  f8808000          STRB     r8,[r0,#0]
                  |L3.344|
;;;738            ++ buf;
000158  1c40              ADDS     r0,r0,#1
                  |L3.346|
00015a  f1b10800          SUBS     r8,r1,#0              ;734
00015e  f1a10101          SUB      r1,r1,#1              ;734
000162  dcf1              BGT      |L3.328|
;;;739        }
;;;740    
;;;741        while (size-- > 0)
000164  e006              B        |L3.372|
                  |L3.358|
;;;742        {
;;;743            if (buf <= end)
000166  42a8              CMP      r0,r5
000168  d803              BHI      |L3.370|
;;;744                *buf = ' ';
00016a  f04f0820          MOV      r8,#0x20
00016e  f8808000          STRB     r8,[r0,#0]
                  |L3.370|
;;;745            ++ buf;
000172  1c40              ADDS     r0,r0,#1
                  |L3.372|
000174  f1b30800          SUBS     r8,r3,#0              ;741
000178  f1a30301          SUB      r3,r3,#1              ;741
00017c  dcf3              BGT      |L3.358|
;;;746        }
;;;747    
;;;748        return buf;
;;;749    }
00017e  b005              ADD      sp,sp,#0x14
000180  e8bd8ff0          POP      {r4-r11,pc}
;;;750    
                          ENDP

                  |L3.388|
                          DCD      large_digits
                  |L3.392|
                          DCD      small_digits

                          AREA ||i.rt_console_get_device||, CODE, READONLY, ALIGN=2

                  rt_console_get_device PROC
;;;1070    */
;;;1071   rt_device_t rt_console_get_device(void)
000000  4801              LDR      r0,|L4.8|
;;;1072   {
;;;1073       return _console_device;
000002  6800              LDR      r0,[r0,#0]  ; _console_device
;;;1074   }
000004  4770              BX       lr
;;;1075   RTM_EXPORT(rt_console_get_device);
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      _console_device

                          AREA ||i.rt_console_set_device||, CODE, READONLY, ALIGN=2

                  rt_console_set_device PROC
;;;1085    */
;;;1086   rt_device_t rt_console_set_device(const char *name)
000000  b570              PUSH     {r4-r6,lr}
;;;1087   {
000002  4605              MOV      r5,r0
;;;1088       rt_device_t new, old;
;;;1089   
;;;1090       /* save old device */
;;;1091       old = _console_device;
000004  480a              LDR      r0,|L5.48|
000006  6806              LDR      r6,[r0,#0]  ; _console_device
;;;1092   
;;;1093       /* find new console device */
;;;1094       new = rt_device_find(name);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       rt_device_find
00000e  4604              MOV      r4,r0
;;;1095       if (new != RT_NULL)
000010  b164              CBZ      r4,|L5.44|
;;;1096       {
;;;1097           if (_console_device != RT_NULL)
000012  4807              LDR      r0,|L5.48|
000014  6800              LDR      r0,[r0,#0]  ; _console_device
000016  b118              CBZ      r0,|L5.32|
;;;1098           {
;;;1099               /* close old console device */
;;;1100               rt_device_close(_console_device);
000018  4805              LDR      r0,|L5.48|
00001a  6800              LDR      r0,[r0,#0]  ; _console_device
00001c  f7fffffe          BL       rt_device_close
                  |L5.32|
;;;1101           }
;;;1102   
;;;1103           /* set new console device */
;;;1104           rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
000020  2143              MOVS     r1,#0x43
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_device_open
;;;1105           _console_device = new;
000028  4801              LDR      r0,|L5.48|
00002a  6004              STR      r4,[r0,#0]  ; _console_device
                  |L5.44|
;;;1106       }
;;;1107   
;;;1108       return old;
00002c  4630              MOV      r0,r6
;;;1109   }
00002e  bd70              POP      {r4-r6,pc}
;;;1110   RTM_EXPORT(rt_console_set_device);
                          ENDP

                  |L5.48|
                          DCD      _console_device

                          AREA ||i.rt_free_align||, CODE, READONLY, ALIGN=1

                  rt_free_align PROC
;;;1237    */
;;;1238   void rt_free_align(void *ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1239   {
000002  4604              MOV      r4,r0
;;;1240       void *real_ptr;
;;;1241   
;;;1242       real_ptr = (void *) * (rt_uint32_t *)((rt_uint32_t)ptr - sizeof(void *));
000004  f8545c04          LDR      r5,[r4,#-4]
;;;1243       rt_free(real_ptr);
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       rt_free
;;;1244   }
00000e  bd70              POP      {r4-r6,pc}
;;;1245   RTM_EXPORT(rt_free_align);
                          ENDP


                          AREA ||i.rt_get_errno||, CODE, READONLY, ALIGN=2

                  rt_get_errno PROC
;;;59      */
;;;60     rt_err_t rt_get_errno(void)
000000  b510              PUSH     {r4,lr}
;;;61     {
;;;62         rt_thread_t tid;
;;;63     
;;;64         if (rt_interrupt_get_nest() != 0)
000002  f7fffffe          BL       rt_interrupt_get_nest
000006  b110              CBZ      r0,|L7.14|
;;;65         {
;;;66             /* it's in interrupt context */
;;;67             return __rt_errno;
000008  4805              LDR      r0,|L7.32|
00000a  6800              LDR      r0,[r0,#0]  ; __rt_errno
                  |L7.12|
;;;68         }
;;;69     
;;;70         tid = rt_thread_self();
;;;71         if (tid == RT_NULL)
;;;72             return __rt_errno;
;;;73     
;;;74         return tid->error;
;;;75     }
00000c  bd10              POP      {r4,pc}
                  |L7.14|
00000e  f7fffffe          BL       rt_thread_self
000012  4604              MOV      r4,r0                 ;70
000014  b914              CBNZ     r4,|L7.28|
000016  4802              LDR      r0,|L7.32|
000018  6800              LDR      r0,[r0,#0]            ;72  ; __rt_errno
00001a  e7f7              B        |L7.12|
                  |L7.28|
00001c  6b20              LDR      r0,[r4,#0x30]         ;74
00001e  e7f5              B        |L7.12|
;;;76     RTM_EXPORT(rt_get_errno);
                          ENDP

                  |L7.32|
                          DCD      __rt_errno

                          AREA ||i.rt_hw_console_output||, CODE, READONLY, ALIGN=1

                  rt_hw_console_output PROC
;;;1112   
;;;1113   RT_WEAK void rt_hw_console_output(const char *str)
000000  4770              BX       lr
;;;1114   {
;;;1115       /* empty console output */
;;;1116   }
;;;1117   RTM_EXPORT(rt_hw_console_output);
                          ENDP


                          AREA ||i.rt_kprintf||, CODE, READONLY, ALIGN=2

                  rt_kprintf PROC
;;;1150    */
;;;1151   void rt_kprintf(const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;1152   {
000002  b538              PUSH     {r3-r5,lr}
;;;1153       va_list args;
;;;1154       rt_size_t length;
;;;1155       static char rt_log_buf[RT_CONSOLEBUF_SIZE];
;;;1156   
;;;1157       va_start(args, fmt);
000004  a805              ADD      r0,sp,#0x14
000006  9000              STR      r0,[sp,#0]
;;;1158       /* the return value of vsnprintf is the number of bytes that would be
;;;1159        * written to buffer had if the size of the buffer been sufficiently
;;;1160        * large excluding the terminating null byte. If the output string
;;;1161        * would be larger than the rt_log_buf, we have to adjust the output
;;;1162        * length. */
;;;1163       length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
000008  217f              MOVS     r1,#0x7f
00000a  4815              LDR      r0,|L9.96|
00000c  9b00              LDR      r3,[sp,#0]
00000e  9a04              LDR      r2,[sp,#0x10]
000010  f7fffffe          BL       rt_vsnprintf
000014  4604              MOV      r4,r0
;;;1164       if (length > RT_CONSOLEBUF_SIZE - 1)
000016  2c7f              CMP      r4,#0x7f
000018  d900              BLS      |L9.28|
;;;1165           length = RT_CONSOLEBUF_SIZE - 1;
00001a  247f              MOVS     r4,#0x7f
                  |L9.28|
;;;1166   #ifdef RT_USING_DEVICE
;;;1167       if (_console_device == RT_NULL)
00001c  4811              LDR      r0,|L9.100|
00001e  6800              LDR      r0,[r0,#0]  ; _console_device
000020  b918              CBNZ     r0,|L9.42|
;;;1168       {
;;;1169           rt_hw_console_output(rt_log_buf);
000022  480f              LDR      r0,|L9.96|
000024  f7fffffe          BL       rt_hw_console_output
000028  e015              B        |L9.86|
                  |L9.42|
;;;1170       }
;;;1171       else
;;;1172       {
;;;1173           rt_uint16_t old_flag = _console_device->open_flag;
00002a  480e              LDR      r0,|L9.100|
00002c  6800              LDR      r0,[r0,#0]  ; _console_device
00002e  8b05              LDRH     r5,[r0,#0x18]
;;;1174   
;;;1175           _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
000030  480c              LDR      r0,|L9.100|
000032  6800              LDR      r0,[r0,#0]  ; _console_device
000034  8b00              LDRH     r0,[r0,#0x18]
000036  f0400040          ORR      r0,r0,#0x40
00003a  490a              LDR      r1,|L9.100|
00003c  6809              LDR      r1,[r1,#0]  ; _console_device
00003e  8308              STRH     r0,[r1,#0x18]
;;;1176           rt_device_write(_console_device, 0, rt_log_buf, length);
000040  4623              MOV      r3,r4
000042  4a07              LDR      r2,|L9.96|
000044  2100              MOVS     r1,#0
000046  4807              LDR      r0,|L9.100|
000048  6800              LDR      r0,[r0,#0]  ; _console_device
00004a  f7fffffe          BL       rt_device_write
;;;1177           _console_device->open_flag = old_flag;
00004e  4805              LDR      r0,|L9.100|
000050  6800              LDR      r0,[r0,#0]  ; _console_device
000052  8305              STRH     r5,[r0,#0x18]
;;;1178       }
000054  bf00              NOP      
                  |L9.86|
;;;1179   #else
;;;1180       rt_hw_console_output(rt_log_buf);
;;;1181   #endif
;;;1182       va_end(args);
000056  2000              MOVS     r0,#0
000058  9000              STR      r0,[sp,#0]
;;;1183   }
00005a  bc38              POP      {r3-r5}
00005c  f85dfb14          LDR      pc,[sp],#0x14
;;;1184   RTM_EXPORT(rt_kprintf);
                          ENDP

                  |L9.96|
                          DCD      rt_log_buf
                  |L9.100|
                          DCD      _console_device

                          AREA ||i.rt_kputs||, CODE, READONLY, ALIGN=2

                  rt_kputs PROC
;;;1123    */
;;;1124   void rt_kputs(const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;1125   {
000002  4604              MOV      r4,r0
;;;1126       if (!str) return;
000004  b904              CBNZ     r4,|L10.8|
                  |L10.6|
;;;1127   
;;;1128   #ifdef RT_USING_DEVICE
;;;1129       if (_console_device == RT_NULL)
;;;1130       {
;;;1131           rt_hw_console_output(str);
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135           rt_uint16_t old_flag = _console_device->open_flag;
;;;1136   
;;;1137           _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
;;;1138           rt_device_write(_console_device, 0, str, rt_strlen(str));
;;;1139           _console_device->open_flag = old_flag;
;;;1140       }
;;;1141   #else
;;;1142       rt_hw_console_output(str);
;;;1143   #endif
;;;1144   }
000006  bd70              POP      {r4-r6,pc}
                  |L10.8|
000008  4811              LDR      r0,|L10.80|
00000a  6800              LDR      r0,[r0,#0]            ;1129  ; _console_device
00000c  b918              CBNZ     r0,|L10.22|
00000e  4620              MOV      r0,r4                 ;1131
000010  f7fffffe          BL       rt_hw_console_output
000014  e019              B        |L10.74|
                  |L10.22|
000016  480e              LDR      r0,|L10.80|
000018  6800              LDR      r0,[r0,#0]            ;1135  ; _console_device
00001a  8b05              LDRH     r5,[r0,#0x18]         ;1135
00001c  480c              LDR      r0,|L10.80|
00001e  6800              LDR      r0,[r0,#0]            ;1137  ; _console_device
000020  8b00              LDRH     r0,[r0,#0x18]         ;1137
000022  f0400040          ORR      r0,r0,#0x40           ;1137
000026  490a              LDR      r1,|L10.80|
000028  6809              LDR      r1,[r1,#0]            ;1137  ; _console_device
00002a  8308              STRH     r0,[r1,#0x18]         ;1137
00002c  4620              MOV      r0,r4                 ;1138
00002e  f7fffffe          BL       rt_strlen
000032  4606              MOV      r6,r0                 ;1138
000034  4633              MOV      r3,r6                 ;1138
000036  4622              MOV      r2,r4                 ;1138
000038  2100              MOVS     r1,#0                 ;1138
00003a  4805              LDR      r0,|L10.80|
00003c  6800              LDR      r0,[r0,#0]            ;1138  ; _console_device
00003e  f7fffffe          BL       rt_device_write
000042  4803              LDR      r0,|L10.80|
000044  6800              LDR      r0,[r0,#0]            ;1139  ; _console_device
000046  8305              STRH     r5,[r0,#0x18]         ;1139
000048  bf00              NOP                            ;1140
                  |L10.74|
00004a  bf00              NOP      
00004c  e7db              B        |L10.6|
;;;1145   
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
                          DCD      _console_device

                          AREA ||i.rt_malloc_align||, CODE, READONLY, ALIGN=1

                  rt_malloc_align PROC
;;;1196    */
;;;1197   void *rt_malloc_align(rt_size_t size, rt_size_t align)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1198   {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;1199       void *align_ptr;
;;;1200       void *ptr;
;;;1201       rt_size_t align_size;
;;;1202   
;;;1203       /* align the alignment size to 4 byte */
;;;1204       align = ((align + 0x03) & ~0x03);
000008  1ce0              ADDS     r0,r4,#3
00000a  f0200403          BIC      r4,r0,#3
;;;1205   
;;;1206       /* get total aligned size */
;;;1207       align_size = ((size + 0x03) & ~0x03) + align;
00000e  1cf8              ADDS     r0,r7,#3
000010  f0200003          BIC      r0,r0,#3
000014  eb000804          ADD      r8,r0,r4
;;;1208       /* allocate memory block from heap */
;;;1209       ptr = rt_malloc(align_size);
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       rt_malloc
00001e  4605              MOV      r5,r0
;;;1210       if (ptr != RT_NULL)
000020  b165              CBZ      r5,|L11.60|
;;;1211       {
;;;1212           /* the allocated memory block is aligned */
;;;1213           if (((rt_uint32_t)ptr & (align - 1)) == 0)
000022  1e60              SUBS     r0,r4,#1
000024  4028              ANDS     r0,r0,r5
000026  b908              CBNZ     r0,|L11.44|
;;;1214           {
;;;1215               align_ptr = (void *)((rt_uint32_t)ptr + align);
000028  192e              ADDS     r6,r5,r4
00002a  e004              B        |L11.54|
                  |L11.44|
;;;1216           }
;;;1217           else
;;;1218           {
;;;1219               align_ptr = (void *)(((rt_uint32_t)ptr + (align - 1)) & ~(align - 1));
00002c  1e60              SUBS     r0,r4,#1
00002e  4428              ADD      r0,r0,r5
000030  1e61              SUBS     r1,r4,#1
000032  ea200601          BIC      r6,r0,r1
                  |L11.54|
;;;1220           }
;;;1221   
;;;1222           /* set the pointer before alignment pointer to the real pointer */
;;;1223           *((rt_uint32_t *)((rt_uint32_t)align_ptr - sizeof(void *))) = (rt_uint32_t)ptr;
000036  f8465c04          STR      r5,[r6,#-4]
;;;1224   
;;;1225           ptr = align_ptr;
00003a  4635              MOV      r5,r6
                  |L11.60|
;;;1226       }
;;;1227   
;;;1228       return ptr;
00003c  4628              MOV      r0,r5
;;;1229   }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;1230   RTM_EXPORT(rt_malloc_align);
                          ENDP


                          AREA ||i.rt_memcmp||, CODE, READONLY, ALIGN=1

                  rt_memcmp PROC
;;;333     */
;;;334    rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
000000  b5f0              PUSH     {r4-r7,lr}
;;;335    {
000002  4603              MOV      r3,r0
;;;336        const unsigned char *su1, *su2;
;;;337        int res = 0;
000004  2000              MOVS     r0,#0
;;;338    
;;;339        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
000006  461c              MOV      r4,r3
000008  460d              MOV      r5,r1
00000a  e008              B        |L12.30|
                  |L12.12|
;;;340            if ((res = *su1 - *su2) != 0)
00000c  7826              LDRB     r6,[r4,#0]
00000e  782f              LDRB     r7,[r5,#0]
000010  1bf6              SUBS     r6,r6,r7
000012  1e30              SUBS     r0,r6,#0
000014  d000              BEQ      |L12.24|
;;;341                break;
000016  e004              B        |L12.34|
                  |L12.24|
000018  1c64              ADDS     r4,r4,#1              ;339
00001a  1c6d              ADDS     r5,r5,#1              ;339
00001c  1e52              SUBS     r2,r2,#1              ;339
                  |L12.30|
00001e  2a00              CMP      r2,#0                 ;339
000020  d8f4              BHI      |L12.12|
                  |L12.34|
000022  bf00              NOP      
;;;342    
;;;343        return res;
;;;344    }
000024  bdf0              POP      {r4-r7,pc}
;;;345    RTM_EXPORT(rt_memcmp);
                          ENDP


                          AREA ||i.rt_memcpy||, CODE, READONLY, ALIGN=1

                  rt_memcpy PROC
;;;218     */
;;;219    void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;220    {
000004  460f              MOV      r7,r1
000006  4616              MOV      r6,r2
;;;221    #ifdef RT_USING_TINY_SIZE
;;;222        char *tmp = (char *)dst, *s = (char *)src;
;;;223        rt_ubase_t len;
;;;224    
;;;225        if (tmp <= s || tmp > (s + count))
;;;226        {
;;;227            while (count--)
;;;228                *tmp ++ = *s ++;
;;;229        }
;;;230        else
;;;231        {
;;;232            for (len = count; len > 0; len --)
;;;233                tmp[len - 1] = s[len - 1];
;;;234        }
;;;235    
;;;236        return dst;
;;;237    #else
;;;238    
;;;239    #define UNALIGNED(X, Y)                                               \
;;;240                            (((rt_int32_t)X & (sizeof(rt_int32_t) - 1)) | \
;;;241                             ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
;;;242    #define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
;;;243    #define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
;;;244    #define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)
;;;245    
;;;246        char *dst_ptr = (char *)dst;
000008  4604              MOV      r4,r0
;;;247        char *src_ptr = (char *)src;
00000a  463d              MOV      r5,r7
;;;248        rt_int32_t *aligned_dst;
;;;249        rt_int32_t *aligned_src;
;;;250        int len = count;
00000c  4633              MOV      r3,r6
;;;251    
;;;252        /* If the size is small, or either SRC or DST is unaligned,
;;;253        then punt into the byte copy loop.  This should be rare. */
;;;254        if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
00000e  2b10              CMP      r3,#0x10
000010  d328              BCC      |L13.100|
000012  f0050c03          AND      r12,r5,#3
000016  f0040803          AND      r8,r4,#3
00001a  ea4c0c08          ORR      r12,r12,r8
00001e  f1bc0f00          CMP      r12,#0
000022  d11f              BNE      |L13.100|
;;;255        {
;;;256            aligned_dst = (rt_int32_t *)dst_ptr;
000024  4621              MOV      r1,r4
;;;257            aligned_src = (rt_int32_t *)src_ptr;
000026  462a              MOV      r2,r5
;;;258    
;;;259            /* Copy 4X long words at a time if possible. */
;;;260            while (len >= BIGBLOCKSIZE)
000028  e010              B        |L13.76|
                  |L13.42|
;;;261            {
;;;262                *aligned_dst++ = *aligned_src++;
00002a  f852cb04          LDR      r12,[r2],#4
00002e  f841cb04          STR      r12,[r1],#4
;;;263                *aligned_dst++ = *aligned_src++;
000032  f852cb04          LDR      r12,[r2],#4
000036  f841cb04          STR      r12,[r1],#4
;;;264                *aligned_dst++ = *aligned_src++;
00003a  f852cb04          LDR      r12,[r2],#4
00003e  f841cb04          STR      r12,[r1],#4
;;;265                *aligned_dst++ = *aligned_src++;
000042  f852cb04          LDR      r12,[r2],#4
000046  f841cb04          STR      r12,[r1],#4
;;;266                len -= BIGBLOCKSIZE;
00004a  3b10              SUBS     r3,r3,#0x10
                  |L13.76|
00004c  2b10              CMP      r3,#0x10              ;260
00004e  d2ec              BCS      |L13.42|
;;;267            }
;;;268    
;;;269            /* Copy one long word at a time if possible. */
;;;270            while (len >= LITTLEBLOCKSIZE)
000050  e004              B        |L13.92|
                  |L13.82|
;;;271            {
;;;272                *aligned_dst++ = *aligned_src++;
000052  f852cb04          LDR      r12,[r2],#4
000056  f841cb04          STR      r12,[r1],#4
;;;273                len -= LITTLEBLOCKSIZE;
00005a  1f1b              SUBS     r3,r3,#4
                  |L13.92|
00005c  2b04              CMP      r3,#4                 ;270
00005e  d2f8              BCS      |L13.82|
;;;274            }
;;;275    
;;;276            /* Pick up any residual with a byte copier. */
;;;277            dst_ptr = (char *)aligned_dst;
000060  460c              MOV      r4,r1
;;;278            src_ptr = (char *)aligned_src;
000062  4615              MOV      r5,r2
                  |L13.100|
;;;279        }
;;;280    
;;;281        while (len--)
000064  e003              B        |L13.110|
                  |L13.102|
;;;282            *dst_ptr++ = *src_ptr++;
000066  f815cb01          LDRB     r12,[r5],#1
00006a  f804cb01          STRB     r12,[r4],#1
                  |L13.110|
00006e  f1b30c00          SUBS     r12,r3,#0             ;281
000072  f1a30301          SUB      r3,r3,#1              ;281
000076  d1f6              BNE      |L13.102|
;;;283    
;;;284        return dst;
;;;285    #undef UNALIGNED
;;;286    #undef BIGBLOCKSIZE
;;;287    #undef LITTLEBLOCKSIZE
;;;288    #undef TOO_SMALL
;;;289    #endif
;;;290    }
000078  e8bd81f0          POP      {r4-r8,pc}
;;;291    RTM_EXPORT(rt_memcpy);
                          ENDP


                          AREA ||i.rt_memmove||, CODE, READONLY, ALIGN=1

                  rt_memmove PROC
;;;302     */
;;;303    void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
000000  b570              PUSH     {r4-r6,lr}
;;;304    {
000002  460c              MOV      r4,r1
;;;305        char *tmp = (char *)dest, *s = (char *)src;
000004  4601              MOV      r1,r0
000006  4623              MOV      r3,r4
;;;306    
;;;307        if (s < tmp && tmp < s + n)
000008  428b              CMP      r3,r1
00000a  d210              BCS      |L14.46|
00000c  189d              ADDS     r5,r3,r2
00000e  428d              CMP      r5,r1
000010  d90d              BLS      |L14.46|
;;;308        {
;;;309            tmp += n;
000012  4411              ADD      r1,r1,r2
;;;310            s += n;
000014  4413              ADD      r3,r3,r2
;;;311    
;;;312            while (n--)
000016  e005              B        |L14.36|
                  |L14.24|
;;;313                *(--tmp) = *(--s);
000018  1e5d              SUBS     r5,r3,#1
00001a  462b              MOV      r3,r5
00001c  782e              LDRB     r6,[r5,#0]
00001e  1e4d              SUBS     r5,r1,#1
000020  4629              MOV      r1,r5
000022  702e              STRB     r6,[r5,#0]
                  |L14.36|
000024  1e15              SUBS     r5,r2,#0              ;312
000026  f1a20201          SUB      r2,r2,#1              ;312
00002a  d1f5              BNE      |L14.24|
00002c  e008              B        |L14.64|
                  |L14.46|
;;;314        }
;;;315        else
;;;316        {
;;;317            while (n--)
00002e  e003              B        |L14.56|
                  |L14.48|
;;;318                *tmp++ = *s++;
000030  f8135b01          LDRB     r5,[r3],#1
000034  f8015b01          STRB     r5,[r1],#1
                  |L14.56|
000038  1e15              SUBS     r5,r2,#0              ;317
00003a  f1a20201          SUB      r2,r2,#1              ;317
00003e  d1f7              BNE      |L14.48|
                  |L14.64|
;;;319        }
;;;320    
;;;321        return dest;
;;;322    }
000040  bd70              POP      {r4-r6,pc}
;;;323    RTM_EXPORT(rt_memmove);
                          ENDP


                          AREA ||i.rt_memset||, CODE, READONLY, ALIGN=1

                  rt_memset PROC
;;;135     */
;;;136    void *rt_memset(void *s, int c, rt_ubase_t count)
000000  b5f0              PUSH     {r4-r7,lr}
;;;137    {
000002  460c              MOV      r4,r1
;;;138    #ifdef RT_USING_TINY_SIZE
;;;139        char *xs = (char *)s;
;;;140    
;;;141        while (count--)
;;;142            *xs++ = c;
;;;143    
;;;144        return s;
;;;145    #else
;;;146    #define LBLOCKSIZE      (sizeof(rt_int32_t))
;;;147    #define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
;;;148    #define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)
;;;149    
;;;150        int i;
;;;151        char *m = (char *)s;
000004  4605              MOV      r5,r0
;;;152        rt_uint32_t buffer;
;;;153        rt_uint32_t *aligned_addr;
;;;154        rt_uint32_t d = c & 0xff;
000006  b2e6              UXTB     r6,r4
;;;155    
;;;156        if (!TOO_SMALL(count) && !UNALIGNED(s))
000008  2a04              CMP      r2,#4
00000a  d315              BCC      |L15.56|
00000c  f0000703          AND      r7,r0,#3
000010  b997              CBNZ     r7,|L15.56|
;;;157        {
;;;158            /* If we get this far, we know that n is large and m is word-aligned. */
;;;159            aligned_addr = (rt_uint32_t *)s;
000012  4601              MOV      r1,r0
;;;160    
;;;161            /* Store D into each char sized location in BUFFER so that
;;;162             * we can set large blocks quickly.
;;;163             */
;;;164            if (LBLOCKSIZE == 4)
;;;165            {
;;;166                buffer = (d << 8) | d;
000014  ea462306          ORR      r3,r6,r6,LSL #8
;;;167                buffer |= (buffer << 16);
000018  ea434303          ORR      r3,r3,r3,LSL #16
;;;168            }
;;;169            else
;;;170            {
;;;171                buffer = 0;
;;;172                for (i = 0; i < LBLOCKSIZE; i ++)
;;;173                    buffer = (buffer << 8) | d;
;;;174            }
;;;175    
;;;176            while (count >= LBLOCKSIZE * 4)
00001c  e004              B        |L15.40|
                  |L15.30|
;;;177            {
;;;178                *aligned_addr++ = buffer;
00001e  c108              STM      r1!,{r3}
;;;179                *aligned_addr++ = buffer;
000020  c108              STM      r1!,{r3}
;;;180                *aligned_addr++ = buffer;
000022  c108              STM      r1!,{r3}
;;;181                *aligned_addr++ = buffer;
000024  c108              STM      r1!,{r3}
;;;182                count -= 4 * LBLOCKSIZE;
000026  3a10              SUBS     r2,r2,#0x10
                  |L15.40|
000028  2a10              CMP      r2,#0x10              ;176
00002a  d2f8              BCS      |L15.30|
;;;183            }
;;;184    
;;;185            while (count >= LBLOCKSIZE)
00002c  e001              B        |L15.50|
                  |L15.46|
;;;186            {
;;;187                *aligned_addr++ = buffer;
00002e  c108              STM      r1!,{r3}
;;;188                count -= LBLOCKSIZE;
000030  1f12              SUBS     r2,r2,#4
                  |L15.50|
000032  2a04              CMP      r2,#4                 ;185
000034  d2fb              BCS      |L15.46|
;;;189            }
;;;190    
;;;191            /* Pick up the remainder with a bytewise loop. */
;;;192            m = (char *)aligned_addr;
000036  460d              MOV      r5,r1
                  |L15.56|
;;;193        }
;;;194    
;;;195        while (count--)
000038  e001              B        |L15.62|
                  |L15.58|
;;;196        {
;;;197            *m++ = (char)d;
00003a  f8056b01          STRB     r6,[r5],#1
                  |L15.62|
00003e  1e17              SUBS     r7,r2,#0              ;195
000040  f1a20201          SUB      r2,r2,#1              ;195
000044  d1f9              BNE      |L15.58|
;;;198        }
;;;199    
;;;200        return s;
;;;201    
;;;202    #undef LBLOCKSIZE
;;;203    #undef UNALIGNED
;;;204    #undef TOO_SMALL
;;;205    #endif
;;;206    }
000046  bdf0              POP      {r4-r7,pc}
;;;207    RTM_EXPORT(rt_memset);
                          ENDP


                          AREA ||i.rt_set_errno||, CODE, READONLY, ALIGN=2

                  rt_set_errno PROC
;;;82      */
;;;83     void rt_set_errno(rt_err_t error)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  4604              MOV      r4,r0
;;;85         rt_thread_t tid;
;;;86     
;;;87         if (rt_interrupt_get_nest() != 0)
000004  f7fffffe          BL       rt_interrupt_get_nest
000008  b110              CBZ      r0,|L16.16|
;;;88         {
;;;89             /* it's in interrupt context */
;;;90             __rt_errno = error;
00000a  4806              LDR      r0,|L16.36|
00000c  6004              STR      r4,[r0,#0]  ; __rt_errno
                  |L16.14|
;;;91     
;;;92             return;
;;;93         }
;;;94     
;;;95         tid = rt_thread_self();
;;;96         if (tid == RT_NULL)
;;;97         {
;;;98             __rt_errno = error;
;;;99     
;;;100            return;
;;;101        }
;;;102    
;;;103        tid->error = error;
;;;104    }
00000e  bd70              POP      {r4-r6,pc}
                  |L16.16|
000010  f7fffffe          BL       rt_thread_self
000014  4605              MOV      r5,r0                 ;95
000016  b915              CBNZ     r5,|L16.30|
000018  4802              LDR      r0,|L16.36|
00001a  6004              STR      r4,[r0,#0]            ;98  ; __rt_errno
00001c  e7f7              B        |L16.14|
                  |L16.30|
00001e  632c              STR      r4,[r5,#0x30]         ;103
000020  bf00              NOP      
000022  e7f4              B        |L16.14|
;;;105    RTM_EXPORT(rt_set_errno);
                          ENDP

                  |L16.36|
                          DCD      __rt_errno

                          AREA ||i.rt_show_version||, CODE, READONLY, ALIGN=2

                  rt_show_version PROC
;;;538     */
;;;539    void rt_show_version(void)
000000  b508              PUSH     {r3,lr}
;;;540    {
;;;541        rt_kprintf("\n \\ | /\n");
000002  a009              ADR      r0,|L17.40|
000004  f7fffffe          BL       rt_kprintf
;;;542        rt_kprintf("- RT -     Thread Operating System\n");
000008  a00a              ADR      r0,|L17.52|
00000a  f7fffffe          BL       rt_kprintf
;;;543        rt_kprintf(" / | \\     %d.%d.%d build %s\n",
00000e  a012              ADR      r0,|L17.88|
000010  2303              MOVS     r3,#3
000012  2200              MOVS     r2,#0
000014  4619              MOV      r1,r3
000016  9000              STR      r0,[sp,#0]
000018  a012              ADR      r0,|L17.100|
00001a  f7fffffe          BL       rt_kprintf
;;;544                   RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
;;;545        rt_kprintf(" 2006 - 2018 Copyright by rt-thread team\n");
00001e  a019              ADR      r0,|L17.132|
000020  f7fffffe          BL       rt_kprintf
;;;546    }
000024  bd08              POP      {r3,pc}
;;;547    RTM_EXPORT(rt_show_version);
                          ENDP

000026  0000              DCW      0x0000
                  |L17.40|
000028  0a205c20          DCB      "\n \\ | /\n",0
00002c  7c202f0a
000030  00      
000031  00                DCB      0
000032  00                DCB      0
000033  00                DCB      0
                  |L17.52|
000034  2d205254          DCB      "- RT -     Thread Operating System\n",0
000038  202d2020
00003c  20202054
000040  68726561
000044  64204f70
000048  65726174
00004c  696e6720
000050  53797374
000054  656d0a00
                  |L17.88|
000058  4a756c20          DCB      "Jul 24 2024",0
00005c  32342032
000060  30323400
                  |L17.100|
000064  202f207c          DCB      " / | \\     %d.%d.%d build %s\n",0
000068  205c2020
00006c  20202025
000070  642e2564
000074  2e256420
000078  6275696c
00007c  64202573
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0
                  |L17.132|
000084  20323030          DCB      " 2006 - 2018 Copyright by rt-thread team\n",0
000088  36202d20
00008c  32303138
000090  20436f70
000094  79726967
000098  68742062
00009c  79207274
0000a0  2d746872
0000a4  65616420
0000a8  7465616d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.rt_snprintf||, CODE, READONLY, ALIGN=1

                  rt_snprintf PROC
;;;1017    */
;;;1018   rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;1019   {
000002  b5f8              PUSH     {r3-r7,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1020       rt_int32_t n;
;;;1021       va_list args;
;;;1022   
;;;1023       va_start(args, fmt);
000008  a809              ADD      r0,sp,#0x24
00000a  9000              STR      r0,[sp,#0]
;;;1024       n = rt_vsnprintf(buf, size, fmt, args);
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  9b00              LDR      r3,[sp,#0]
000012  9a08              LDR      r2,[sp,#0x20]
000014  f7fffffe          BL       rt_vsnprintf
000018  4606              MOV      r6,r0
;;;1025       va_end(args);
00001a  2000              MOVS     r0,#0
00001c  9000              STR      r0,[sp,#0]
;;;1026   
;;;1027       return n;
00001e  4630              MOV      r0,r6
;;;1028   }
000020  bcf8              POP      {r3-r7}
000022  f85dfb14          LDR      pc,[sp],#0x14
;;;1029   RTM_EXPORT(rt_snprintf);
                          ENDP


                          AREA ||i.rt_sprintf||, CODE, READONLY, ALIGN=1

                  rt_sprintf PROC
;;;1049    */
;;;1050   rt_int32_t rt_sprintf(char *buf, const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;1051   {
000002  b538              PUSH     {r3-r5,lr}
000004  4604              MOV      r4,r0
;;;1052       rt_int32_t n;
;;;1053       va_list arg_ptr;
;;;1054   
;;;1055       va_start(arg_ptr, format);
000006  a806              ADD      r0,sp,#0x18
000008  9000              STR      r0,[sp,#0]
;;;1056       n = rt_vsprintf(buf, format, arg_ptr);
00000a  4620              MOV      r0,r4
00000c  9a00              LDR      r2,[sp,#0]
00000e  9905              LDR      r1,[sp,#0x14]
000010  f7fffffe          BL       rt_vsprintf
000014  4605              MOV      r5,r0
;;;1057       va_end(arg_ptr);
000016  2000              MOVS     r0,#0
000018  9000              STR      r0,[sp,#0]
;;;1058   
;;;1059       return n;
00001a  4628              MOV      r0,r5
;;;1060   }
00001c  bc38              POP      {r3-r5}
00001e  f85dfb14          LDR      pc,[sp],#0x14
;;;1061   RTM_EXPORT(rt_sprintf);
                          ENDP


                          AREA ||i.rt_strcasecmp||, CODE, READONLY, ALIGN=1

                  rt_strcasecmp PROC
;;;382     */
;;;383    rt_uint32_t rt_strcasecmp(const char *a, const char *b)
000000  b530              PUSH     {r4,r5,lr}
;;;384    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;385        int ca, cb;
;;;386    
;;;387        do
000006  bf00              NOP      
                  |L20.8|
;;;388        {
;;;389            ca = *a++ & 0xff;
000008  f8131b01          LDRB     r1,[r3],#1
;;;390            cb = *b++ & 0xff;
00000c  f8142b01          LDRB     r2,[r4],#1
;;;391            if (ca >= 'A' && ca <= 'Z')
000010  2941              CMP      r1,#0x41
000012  db02              BLT      |L20.26|
000014  295a              CMP      r1,#0x5a
000016  dc00              BGT      |L20.26|
;;;392                ca += 'a' - 'A';
000018  3120              ADDS     r1,r1,#0x20
                  |L20.26|
;;;393            if (cb >= 'A' && cb <= 'Z')
00001a  2a41              CMP      r2,#0x41
00001c  db02              BLT      |L20.36|
00001e  2a5a              CMP      r2,#0x5a
000020  dc00              BGT      |L20.36|
;;;394                cb += 'a' - 'A';
000022  3220              ADDS     r2,r2,#0x20
                  |L20.36|
;;;395        }
;;;396        while (ca == cb && ca != '\0');
000024  4291              CMP      r1,r2
000026  d101              BNE      |L20.44|
000028  2900              CMP      r1,#0
00002a  d1ed              BNE      |L20.8|
                  |L20.44|
;;;397    
;;;398        return ca - cb;
00002c  1a88              SUBS     r0,r1,r2
;;;399    }
00002e  bd30              POP      {r4,r5,pc}
;;;400    RTM_EXPORT(rt_strcasecmp);
                          ENDP


                          AREA ||i.rt_strcmp||, CODE, READONLY, ALIGN=1

                  rt_strcmp PROC
;;;465     */
;;;466    rt_int32_t rt_strcmp(const char *cs, const char *ct)
000000  4602              MOV      r2,r0
;;;467    {
;;;468        while (*cs && *cs == *ct)
000002  e001              B        |L21.8|
                  |L21.4|
;;;469            cs++, ct++;
000004  1c52              ADDS     r2,r2,#1
000006  1c49              ADDS     r1,r1,#1
                  |L21.8|
000008  7810              LDRB     r0,[r2,#0]            ;468
00000a  b118              CBZ      r0,|L21.20|
00000c  7810              LDRB     r0,[r2,#0]            ;468
00000e  780b              LDRB     r3,[r1,#0]            ;468
000010  4298              CMP      r0,r3                 ;468
000012  d0f7              BEQ      |L21.4|
                  |L21.20|
;;;470    
;;;471        return (*cs - *ct);
000014  7810              LDRB     r0,[r2,#0]
000016  780b              LDRB     r3,[r1,#0]
000018  1ac0              SUBS     r0,r0,r3
;;;472    }
00001a  4770              BX       lr
;;;473    RTM_EXPORT(rt_strcmp);
                          ENDP


                          AREA ||i.rt_strdup||, CODE, READONLY, ALIGN=1

                  rt_strdup PROC
;;;520     */
;;;521    char *rt_strdup(const char *s)
000000  b570              PUSH     {r4-r6,lr}
;;;522    {
000002  4604              MOV      r4,r0
;;;523        rt_size_t len = rt_strlen(s) + 1;
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_strlen
00000a  1c45              ADDS     r5,r0,#1
;;;524        char *tmp = (char *)rt_malloc(len);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       rt_malloc
000012  4606              MOV      r6,r0
;;;525    
;;;526        if (!tmp)
000014  b90e              CBNZ     r6,|L22.26|
;;;527            return RT_NULL;
000016  2000              MOVS     r0,#0
                  |L22.24|
;;;528    
;;;529        rt_memcpy(tmp, s, len);
;;;530    
;;;531        return tmp;
;;;532    }
000018  bd70              POP      {r4-r6,pc}
                  |L22.26|
00001a  462a              MOV      r2,r5                 ;529
00001c  4621              MOV      r1,r4                 ;529
00001e  4630              MOV      r0,r6                 ;529
000020  f7fffffe          BL       rt_memcpy
000024  4630              MOV      r0,r6                 ;531
000026  e7f7              B        |L22.24|
;;;533    RTM_EXPORT(rt_strdup);
                          ENDP


                          AREA ||i.rt_strlen||, CODE, READONLY, ALIGN=1

                  rt_strlen PROC
;;;501     */
;;;502    rt_size_t rt_strlen(const char *s)
000000  4601              MOV      r1,r0
;;;503    {
;;;504        const char *sc;
;;;505    
;;;506        for (sc = s; *sc != '\0'; ++sc) /* nothing */
000002  460a              MOV      r2,r1
000004  e000              B        |L23.8|
                  |L23.6|
000006  1c52              ADDS     r2,r2,#1
                  |L23.8|
000008  7810              LDRB     r0,[r2,#0]
00000a  2800              CMP      r0,#0
00000c  d1fb              BNE      |L23.6|
;;;507            ;
;;;508    
;;;509        return sc - s;
00000e  1a50              SUBS     r0,r2,r1
;;;510    }
000010  4770              BX       lr
;;;511    RTM_EXPORT(rt_strlen);
                          ENDP


                          AREA ||i.rt_strncmp||, CODE, READONLY, ALIGN=1

                  rt_strncmp PROC
;;;442     */
;;;443    rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
000000  b530              PUSH     {r4,r5,lr}
;;;444    {
000002  4603              MOV      r3,r0
;;;445        register signed char __res = 0;
000004  2000              MOVS     r0,#0
;;;446    
;;;447        while (count)
000006  e00b              B        |L24.32|
                  |L24.8|
;;;448        {
;;;449            if ((__res = *cs - *ct++) != 0 || !*cs++)
000008  f8115b01          LDRB     r5,[r1],#1
00000c  781c              LDRB     r4,[r3,#0]
00000e  1b64              SUBS     r4,r4,r5
000010  b264              SXTB     r4,r4
000012  1e20              SUBS     r0,r4,#0
000014  d102              BNE      |L24.28|
000016  f8135b01          LDRB     r5,[r3],#1
00001a  b905              CBNZ     r5,|L24.30|
                  |L24.28|
;;;450                break;
00001c  e002              B        |L24.36|
                  |L24.30|
;;;451            count --;
00001e  1e52              SUBS     r2,r2,#1
                  |L24.32|
000020  2a00              CMP      r2,#0                 ;447
000022  d1f1              BNE      |L24.8|
                  |L24.36|
000024  bf00              NOP                            ;450
;;;452        }
;;;453    
;;;454        return __res;
;;;455    }
000026  bd30              POP      {r4,r5,pc}
;;;456    RTM_EXPORT(rt_strncmp);
                          ENDP


                          AREA ||i.rt_strncpy||, CODE, READONLY, ALIGN=1

                  rt_strncpy PROC
;;;410     */
;;;411    char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
000000  b570              PUSH     {r4-r6,lr}
;;;412    {
000002  4603              MOV      r3,r0
;;;413        if (n != 0)
000004  b1a2              CBZ      r2,|L25.48|
;;;414        {
;;;415            char *d = dst;
000006  4618              MOV      r0,r3
;;;416            const char *s = src;
000008  460c              MOV      r4,r1
;;;417    
;;;418            do
00000a  bf00              NOP      
                  |L25.12|
;;;419            {
;;;420                if ((*d++ = *s++) == 0)
00000c  f8146b01          LDRB     r6,[r4],#1
000010  f8006b01          STRB     r6,[r0],#1
000014  b93e              CBNZ     r6,|L25.38|
;;;421                {
;;;422                    /* NUL pad the remaining n-1 bytes */
;;;423                    while (--n != 0)
000016  e002              B        |L25.30|
                  |L25.24|
;;;424                        *d++ = 0;
000018  2500              MOVS     r5,#0
00001a  f8005b01          STRB     r5,[r0],#1
                  |L25.30|
00001e  1e55              SUBS     r5,r2,#1              ;423
000020  1e2a              SUBS     r2,r5,#0              ;423
000022  d1f9              BNE      |L25.24|
;;;425                    break;
000024  e002              B        |L25.44|
                  |L25.38|
;;;426                }
;;;427            } while (--n != 0);
000026  1e55              SUBS     r5,r2,#1
000028  1e2a              SUBS     r2,r5,#0
00002a  d1ef              BNE      |L25.12|
                  |L25.44|
00002c  bf00              NOP                            ;425
;;;428        }
00002e  bf00              NOP      
                  |L25.48|
;;;429    
;;;430        return (dst);
000030  4618              MOV      r0,r3
;;;431    }
000032  bd70              POP      {r4-r6,pc}
;;;432    RTM_EXPORT(rt_strncpy);
                          ENDP


                          AREA ||i.rt_strnlen||, CODE, READONLY, ALIGN=1

                  rt_strnlen PROC
;;;484     */
;;;485    rt_size_t rt_strnlen(const char *s, rt_ubase_t maxlen)
000000  4602              MOV      r2,r0
;;;486    {
000002  460b              MOV      r3,r1
;;;487        const char *sc;
;;;488    
;;;489        for (sc = s; *sc != '\0' && sc - s < maxlen; ++sc) /* nothing */
000004  4611              MOV      r1,r2
000006  e000              B        |L26.10|
                  |L26.8|
000008  1c49              ADDS     r1,r1,#1
                  |L26.10|
00000a  7808              LDRB     r0,[r1,#0]
00000c  b110              CBZ      r0,|L26.20|
00000e  1a88              SUBS     r0,r1,r2
000010  4298              CMP      r0,r3
000012  d3f9              BCC      |L26.8|
                  |L26.20|
;;;490            ;
;;;491    
;;;492        return sc - s;
000014  1a88              SUBS     r0,r1,r2
;;;493    }
000016  4770              BX       lr
;;;494    /**
                          ENDP


                          AREA ||i.rt_strstr||, CODE, READONLY, ALIGN=1

                  rt_strstr PROC
;;;354     */
;;;355    char *rt_strstr(const char *s1, const char *s2)
000000  b5f0              PUSH     {r4-r7,lr}
;;;356    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;357        int l1, l2;
;;;358    
;;;359        l2 = rt_strlen(s2);
000006  4638              MOV      r0,r7
000008  f7fffffe          BL       rt_strlen
00000c  4605              MOV      r5,r0
;;;360        if (!l2)
00000e  b90d              CBNZ     r5,|L27.20|
;;;361            return (char *)s1;
000010  4630              MOV      r0,r6
                  |L27.18|
;;;362        l1 = rt_strlen(s1);
;;;363        while (l1 >= l2)
;;;364        {
;;;365            l1 --;
;;;366            if (!rt_memcmp(s1, s2, l2))
;;;367                return (char *)s1;
;;;368            s1 ++;
;;;369        }
;;;370    
;;;371        return RT_NULL;
;;;372    }
000012  bdf0              POP      {r4-r7,pc}
                  |L27.20|
000014  4630              MOV      r0,r6                 ;362
000016  f7fffffe          BL       rt_strlen
00001a  4604              MOV      r4,r0                 ;362
00001c  e009              B        |L27.50|
                  |L27.30|
00001e  1e64              SUBS     r4,r4,#1              ;365
000020  462a              MOV      r2,r5                 ;366
000022  4639              MOV      r1,r7                 ;366
000024  4630              MOV      r0,r6                 ;366
000026  f7fffffe          BL       rt_memcmp
00002a  b908              CBNZ     r0,|L27.48|
00002c  4630              MOV      r0,r6                 ;367
00002e  e7f0              B        |L27.18|
                  |L27.48|
000030  1c76              ADDS     r6,r6,#1              ;368
                  |L27.50|
000032  42ac              CMP      r4,r5                 ;363
000034  daf3              BGE      |L27.30|
000036  2000              MOVS     r0,#0                 ;371
000038  e7eb              B        |L27.18|
;;;373    RTM_EXPORT(rt_strstr);
                          ENDP


                          AREA ||i.rt_vsnprintf||, CODE, READONLY, ALIGN=2

                  rt_vsnprintf PROC
;;;750    
;;;751    rt_int32_t rt_vsnprintf(char       *buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;752                            rt_size_t   size,
;;;753                            const char *fmt,
;;;754                            va_list     args)
;;;755    {
000004  b089              SUB      sp,sp,#0x24
000006  4680              MOV      r8,r0
;;;756    #ifdef RT_PRINTF_LONGLONG
;;;757        unsigned long long num;
;;;758    #else
;;;759        rt_uint32_t num;
;;;760    #endif
;;;761        int i, len;
;;;762        char *str, *end, c;
;;;763        const char *s;
;;;764    
;;;765        rt_uint8_t base;            /* the base of number */
;;;766        rt_uint8_t flags;           /* flags to print number */
;;;767        rt_uint8_t qualifier;       /* 'h', 'l', or 'L' for integer fields */
;;;768        rt_int32_t field_width;     /* width of output field */
;;;769    
;;;770    #ifdef RT_PRINTF_PRECISION
;;;771        int precision;      /* min. # of digits for integers and max for a string */
;;;772    #endif
;;;773    
;;;774        str = buf;
000008  4644              MOV      r4,r8
;;;775        end = buf + size - 1;
00000a  980a              LDR      r0,[sp,#0x28]
00000c  4440              ADD      r0,r0,r8
00000e  1e46              SUBS     r6,r0,#1
;;;776    
;;;777        /* Make sure end is always >= buf */
;;;778        if (end < buf)
000010  4546              CMP      r6,r8
000012  d204              BCS      |L28.30|
;;;779        {
;;;780            end  = ((char *) - 1);
000014  f04f36ff          MOV      r6,#0xffffffff
;;;781            size = end - buf;
000018  eba60008          SUB      r0,r6,r8
00001c  900a              STR      r0,[sp,#0x28]
                  |L28.30|
;;;782        }
;;;783    
;;;784        for (; *fmt ; ++fmt)
00001e  e16f              B        |L28.768|
                  |L28.32|
;;;785        {
;;;786            if (*fmt != '%')
000020  980b              LDR      r0,[sp,#0x2c]
000022  7800              LDRB     r0,[r0,#0]
000024  2825              CMP      r0,#0x25
000026  d006              BEQ      |L28.54|
;;;787            {
;;;788                if (str <= end)
000028  42b4              CMP      r4,r6
00002a  d802              BHI      |L28.50|
;;;789                    *str = *fmt;
00002c  980b              LDR      r0,[sp,#0x2c]
00002e  7800              LDRB     r0,[r0,#0]
000030  7020              STRB     r0,[r4,#0]
                  |L28.50|
;;;790                ++ str;
000032  1c64              ADDS     r4,r4,#1
;;;791                continue;
000034  e161              B        |L28.762|
                  |L28.54|
;;;792            }
;;;793    
;;;794            /* process flags */
;;;795            flags = 0;
000036  2500              MOVS     r5,#0
;;;796    
;;;797            while (1)
000038  e026              B        |L28.136|
                  |L28.58|
;;;798            {
;;;799                /* skips the first '%' also */
;;;800                ++ fmt;
00003a  980b              LDR      r0,[sp,#0x2c]
00003c  1c40              ADDS     r0,r0,#1
00003e  900b              STR      r0,[sp,#0x2c]
;;;801                if (*fmt == '-') flags |= LEFT;
000040  980b              LDR      r0,[sp,#0x2c]
000042  7800              LDRB     r0,[r0,#0]
000044  282d              CMP      r0,#0x2d
000046  d102              BNE      |L28.78|
000048  f0450510          ORR      r5,r5,#0x10
00004c  e01c              B        |L28.136|
                  |L28.78|
;;;802                else if (*fmt == '+') flags |= PLUS;
00004e  980b              LDR      r0,[sp,#0x2c]
000050  7800              LDRB     r0,[r0,#0]
000052  282b              CMP      r0,#0x2b
000054  d102              BNE      |L28.92|
000056  f0450504          ORR      r5,r5,#4
00005a  e015              B        |L28.136|
                  |L28.92|
;;;803                else if (*fmt == ' ') flags |= SPACE;
00005c  980b              LDR      r0,[sp,#0x2c]
00005e  7800              LDRB     r0,[r0,#0]
000060  2820              CMP      r0,#0x20
000062  d102              BNE      |L28.106|
000064  f0450508          ORR      r5,r5,#8
000068  e00e              B        |L28.136|
                  |L28.106|
;;;804                else if (*fmt == '#') flags |= SPECIAL;
00006a  980b              LDR      r0,[sp,#0x2c]
00006c  7800              LDRB     r0,[r0,#0]
00006e  2823              CMP      r0,#0x23
000070  d102              BNE      |L28.120|
000072  f0450520          ORR      r5,r5,#0x20
000076  e007              B        |L28.136|
                  |L28.120|
;;;805                else if (*fmt == '0') flags |= ZEROPAD;
000078  980b              LDR      r0,[sp,#0x2c]
00007a  7800              LDRB     r0,[r0,#0]
00007c  2830              CMP      r0,#0x30
00007e  d102              BNE      |L28.134|
000080  f0450501          ORR      r5,r5,#1
000084  e000              B        |L28.136|
                  |L28.134|
;;;806                else break;
000086  e000              B        |L28.138|
                  |L28.136|
000088  e7d7              B        |L28.58|
                  |L28.138|
00008a  bf00              NOP      
;;;807            }
;;;808    
;;;809            /* get field width */
;;;810            field_width = -1;
00008c  f04f37ff          MOV      r7,#0xffffffff
;;;811            if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
000090  980b              LDR      r0,[sp,#0x2c]
000092  7800              LDRB     r0,[r0,#0]
000094  3830              SUBS     r0,r0,#0x30
000096  280a              CMP      r0,#0xa
000098  d204              BCS      |L28.164|
00009a  a80b              ADD      r0,sp,#0x2c
00009c  f7fffffe          BL       skip_atoi
0000a0  4607              MOV      r7,r0
0000a2  e00e              B        |L28.194|
                  |L28.164|
;;;812            else if (*fmt == '*')
0000a4  980b              LDR      r0,[sp,#0x2c]
0000a6  7800              LDRB     r0,[r0,#0]
0000a8  282a              CMP      r0,#0x2a
0000aa  d10a              BNE      |L28.194|
;;;813            {
;;;814                ++ fmt;
0000ac  980b              LDR      r0,[sp,#0x2c]
0000ae  1c40              ADDS     r0,r0,#1
0000b0  900b              STR      r0,[sp,#0x2c]
;;;815                /* it's the next argument */
;;;816                field_width = va_arg(args, int);
0000b2  980c              LDR      r0,[sp,#0x30]
0000b4  c880              LDM      r0!,{r7}
0000b6  900c              STR      r0,[sp,#0x30]
;;;817                if (field_width < 0)
0000b8  2f00              CMP      r7,#0
0000ba  da02              BGE      |L28.194|
;;;818                {
;;;819                    field_width = -field_width;
0000bc  427f              RSBS     r7,r7,#0
;;;820                    flags |= LEFT;
0000be  f0450510          ORR      r5,r5,#0x10
                  |L28.194|
;;;821                }
;;;822            }
;;;823    
;;;824    #ifdef RT_PRINTF_PRECISION
;;;825            /* get the precision */
;;;826            precision = -1;
0000c2  f04f39ff          MOV      r9,#0xffffffff
;;;827            if (*fmt == '.')
0000c6  980b              LDR      r0,[sp,#0x2c]
0000c8  7800              LDRB     r0,[r0,#0]
0000ca  282e              CMP      r0,#0x2e
0000cc  d11c              BNE      |L28.264|
;;;828            {
;;;829                ++ fmt;
0000ce  980b              LDR      r0,[sp,#0x2c]
0000d0  1c40              ADDS     r0,r0,#1
0000d2  900b              STR      r0,[sp,#0x2c]
;;;830                if (isdigit(*fmt)) precision = skip_atoi(&fmt);
0000d4  980b              LDR      r0,[sp,#0x2c]
0000d6  7800              LDRB     r0,[r0,#0]
0000d8  3830              SUBS     r0,r0,#0x30
0000da  280a              CMP      r0,#0xa
0000dc  d204              BCS      |L28.232|
0000de  a80b              ADD      r0,sp,#0x2c
0000e0  f7fffffe          BL       skip_atoi
0000e4  4681              MOV      r9,r0
0000e6  e00a              B        |L28.254|
                  |L28.232|
;;;831                else if (*fmt == '*')
0000e8  980b              LDR      r0,[sp,#0x2c]
0000ea  7800              LDRB     r0,[r0,#0]
0000ec  282a              CMP      r0,#0x2a
0000ee  d106              BNE      |L28.254|
;;;832                {
;;;833                    ++ fmt;
0000f0  980b              LDR      r0,[sp,#0x2c]
0000f2  1c40              ADDS     r0,r0,#1
0000f4  900b              STR      r0,[sp,#0x2c]
;;;834                    /* it's the next argument */
;;;835                    precision = va_arg(args, int);
0000f6  980c              LDR      r0,[sp,#0x30]
0000f8  f8509b04          LDR      r9,[r0],#4
0000fc  900c              STR      r0,[sp,#0x30]
                  |L28.254|
;;;836                }
;;;837                if (precision < 0) precision = 0;
0000fe  f1b90f00          CMP      r9,#0
000102  da01              BGE      |L28.264|
000104  f04f0900          MOV      r9,#0
                  |L28.264|
;;;838            }
;;;839    #endif
;;;840            /* get the conversion qualifier */
;;;841            qualifier = 0;
000108  2000              MOVS     r0,#0
00010a  9004              STR      r0,[sp,#0x10]
;;;842    #ifdef RT_PRINTF_LONGLONG
;;;843            if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
;;;844    #else
;;;845            if (*fmt == 'h' || *fmt == 'l')
00010c  980b              LDR      r0,[sp,#0x2c]
00010e  7800              LDRB     r0,[r0,#0]
000110  2868              CMP      r0,#0x68
000112  d003              BEQ      |L28.284|
000114  980b              LDR      r0,[sp,#0x2c]
000116  7800              LDRB     r0,[r0,#0]
000118  286c              CMP      r0,#0x6c
00011a  d105              BNE      |L28.296|
                  |L28.284|
;;;846    #endif
;;;847            {
;;;848                qualifier = *fmt;
00011c  980b              LDR      r0,[sp,#0x2c]
00011e  7800              LDRB     r0,[r0,#0]
000120  9004              STR      r0,[sp,#0x10]
;;;849                ++ fmt;
000122  980b              LDR      r0,[sp,#0x2c]
000124  1c40              ADDS     r0,r0,#1
000126  900b              STR      r0,[sp,#0x2c]
                  |L28.296|
;;;850    #ifdef RT_PRINTF_LONGLONG
;;;851                if (qualifier == 'l' && *fmt == 'l')
;;;852                {
;;;853                    qualifier = 'L';
;;;854                    ++ fmt;
;;;855                }
;;;856    #endif
;;;857            }
;;;858    
;;;859            /* the default base */
;;;860            base = 10;
000128  200a              MOVS     r0,#0xa
00012a  9005              STR      r0,[sp,#0x14]
;;;861    
;;;862            switch (*fmt)
00012c  980b              LDR      r0,[sp,#0x2c]
00012e  7800              LDRB     r0,[r0,#0]
000130  286f              CMP      r0,#0x6f
000132  d075              BEQ      |L28.544|
000134  dc0c              BGT      |L28.336|
000136  2863              CMP      r0,#0x63
000138  d013              BEQ      |L28.354|
00013a  dc04              BGT      |L28.326|
00013c  2825              CMP      r0,#0x25
00013e  d070              BEQ      |L28.546|
000140  2858              CMP      r0,#0x58
                  |L28.322|
000142  d16f              BNE      |L28.548|
000144  e08d              B        |L28.610|
                  |L28.326|
000146  2864              CMP      r0,#0x64
000148  d06d              BEQ      |L28.550|
00014a  2869              CMP      r0,#0x69
00014c  d1f9              BNE      |L28.322|
00014e  e08f              B        |L28.624|
                  |L28.336|
000150  2870              CMP      r0,#0x70
000152  d06a              BEQ      |L28.554|
000154  2873              CMP      r0,#0x73
000156  d025              BEQ      |L28.420|
000158  2875              CMP      r0,#0x75
00015a  d078              BEQ      |L28.590|
00015c  2878              CMP      r0,#0x78
00015e  d1f0              BNE      |L28.322|
000160  e082              B        |L28.616|
                  |L28.354|
;;;863            {
;;;864            case 'c':
;;;865                if (!(flags & LEFT))
000162  f0050010          AND      r0,r5,#0x10
000166  b940              CBNZ     r0,|L28.378|
;;;866                {
;;;867                    while (--field_width > 0)
000168  e004              B        |L28.372|
                  |L28.362|
;;;868                    {
;;;869                        if (str <= end) *str = ' ';
00016a  42b4              CMP      r4,r6
00016c  d801              BHI      |L28.370|
00016e  2020              MOVS     r0,#0x20
000170  7020              STRB     r0,[r4,#0]
                  |L28.370|
;;;870                        ++ str;
000172  1c64              ADDS     r4,r4,#1
                  |L28.372|
000174  1e78              SUBS     r0,r7,#1              ;867
000176  1e07              SUBS     r7,r0,#0              ;867
000178  dcf7              BGT      |L28.362|
                  |L28.378|
;;;871                    }
;;;872                }
;;;873    
;;;874                /* get character */
;;;875                c = (rt_uint8_t)va_arg(args, int);
00017a  980c              LDR      r0,[sp,#0x30]
00017c  f8101b04          LDRB     r1,[r0],#4
000180  900c              STR      r0,[sp,#0x30]
000182  b2c8              UXTB     r0,r1
000184  9007              STR      r0,[sp,#0x1c]
;;;876                if (str <= end) *str = c;
000186  42b4              CMP      r4,r6
000188  d801              BHI      |L28.398|
00018a  9807              LDR      r0,[sp,#0x1c]
00018c  7020              STRB     r0,[r4,#0]
                  |L28.398|
;;;877                ++ str;
00018e  1c64              ADDS     r4,r4,#1
;;;878    
;;;879                /* put width */
;;;880                while (--field_width > 0)
000190  e004              B        |L28.412|
                  |L28.402|
;;;881                {
;;;882                    if (str <= end) *str = ' ';
000192  42b4              CMP      r4,r6
000194  d801              BHI      |L28.410|
000196  2020              MOVS     r0,#0x20
000198  7020              STRB     r0,[r4,#0]
                  |L28.410|
;;;883                    ++ str;
00019a  1c64              ADDS     r4,r4,#1
                  |L28.412|
00019c  1e78              SUBS     r0,r7,#1              ;880
00019e  1e07              SUBS     r7,r0,#0              ;880
0001a0  dcf7              BGT      |L28.402|
;;;884                }
;;;885                continue;
0001a2  e0aa              B        |L28.762|
                  |L28.420|
;;;886    
;;;887            case 's':
;;;888                s = va_arg(args, char *);
0001a4  980c              LDR      r0,[sp,#0x30]
0001a6  6800              LDR      r0,[r0,#0]
0001a8  9006              STR      r0,[sp,#0x18]
0001aa  980c              LDR      r0,[sp,#0x30]
0001ac  1d00              ADDS     r0,r0,#4
0001ae  900c              STR      r0,[sp,#0x30]
;;;889                if (!s) s = "(NULL)";
0001b0  9806              LDR      r0,[sp,#0x18]
0001b2  b908              CBNZ     r0,|L28.440|
0001b4  a05a              ADR      r0,|L28.800|
0001b6  9006              STR      r0,[sp,#0x18]
                  |L28.440|
;;;890    
;;;891                len = rt_strlen(s);
0001b8  9806              LDR      r0,[sp,#0x18]
0001ba  f7fffffe          BL       rt_strlen
0001be  4683              MOV      r11,r0
;;;892    #ifdef RT_PRINTF_PRECISION
;;;893                if (precision > 0 && len > precision) len = precision;
0001c0  f1b90f00          CMP      r9,#0
0001c4  dd02              BLE      |L28.460|
0001c6  45cb              CMP      r11,r9
0001c8  dd00              BLE      |L28.460|
0001ca  46cb              MOV      r11,r9
                  |L28.460|
;;;894    #endif
;;;895    
;;;896                if (!(flags & LEFT))
0001cc  f0050010          AND      r0,r5,#0x10
0001d0  b948              CBNZ     r0,|L28.486|
;;;897                {
;;;898                    while (len < field_width--)
0001d2  e004              B        |L28.478|
                  |L28.468|
;;;899                    {
;;;900                        if (str <= end) *str = ' ';
0001d4  42b4              CMP      r4,r6
0001d6  d801              BHI      |L28.476|
0001d8  2020              MOVS     r0,#0x20
0001da  7020              STRB     r0,[r4,#0]
                  |L28.476|
;;;901                        ++ str;
0001dc  1c64              ADDS     r4,r4,#1
                  |L28.478|
0001de  4638              MOV      r0,r7                 ;898
0001e0  1e7f              SUBS     r7,r7,#1              ;898
0001e2  4558              CMP      r0,r11                ;898
0001e4  dcf6              BGT      |L28.468|
                  |L28.486|
;;;902                    }
;;;903                }
;;;904    
;;;905                for (i = 0; i < len; ++i)
0001e6  2000              MOVS     r0,#0
0001e8  9008              STR      r0,[sp,#0x20]
0001ea  e00b              B        |L28.516|
                  |L28.492|
;;;906                {
;;;907                    if (str <= end) *str = *s;
0001ec  42b4              CMP      r4,r6
0001ee  d802              BHI      |L28.502|
0001f0  9806              LDR      r0,[sp,#0x18]
0001f2  7800              LDRB     r0,[r0,#0]
0001f4  7020              STRB     r0,[r4,#0]
                  |L28.502|
;;;908                    ++ str;
0001f6  1c64              ADDS     r4,r4,#1
;;;909                    ++ s;
0001f8  9806              LDR      r0,[sp,#0x18]
0001fa  1c40              ADDS     r0,r0,#1
0001fc  9006              STR      r0,[sp,#0x18]
0001fe  9808              LDR      r0,[sp,#0x20]         ;905
000200  1c40              ADDS     r0,r0,#1              ;905
000202  9008              STR      r0,[sp,#0x20]         ;905
                  |L28.516|
000204  9808              LDR      r0,[sp,#0x20]         ;905
000206  4558              CMP      r0,r11                ;905
000208  dbf0              BLT      |L28.492|
;;;910                }
;;;911    
;;;912                while (len < field_width--)
00020a  e004              B        |L28.534|
                  |L28.524|
;;;913                {
;;;914                    if (str <= end) *str = ' ';
00020c  42b4              CMP      r4,r6
00020e  d801              BHI      |L28.532|
000210  2020              MOVS     r0,#0x20
000212  7020              STRB     r0,[r4,#0]
                  |L28.532|
;;;915                    ++ str;
000214  1c64              ADDS     r4,r4,#1
                  |L28.534|
000216  4638              MOV      r0,r7                 ;912
000218  1e7f              SUBS     r7,r7,#1              ;912
00021a  4558              CMP      r0,r11                ;912
00021c  dcf6              BGT      |L28.524|
;;;916                }
;;;917                continue;
00021e  e06c              B        |L28.762|
                  |L28.544|
000220  e01c              B        |L28.604|
                  |L28.546|
000222  e015              B        |L28.592|
                  |L28.548|
000224  e028              B        |L28.632|
                  |L28.550|
000226  e022              B        |L28.622|
000228  e7ff              B        |L28.554|
                  |L28.554|
;;;918    
;;;919            case 'p':
;;;920                if (field_width == -1)
00022a  1c78              ADDS     r0,r7,#1
00022c  b910              CBNZ     r0,|L28.564|
;;;921                {
;;;922                    field_width = sizeof(void *) << 1;
00022e  2708              MOVS     r7,#8
;;;923                    flags |= ZEROPAD;
000230  f0450501          ORR      r5,r5,#1
                  |L28.564|
;;;924                }
;;;925    #ifdef RT_PRINTF_PRECISION
;;;926                str = print_number(str, end,
000234  e9cd7900          STRD     r7,r9,[sp,#0]
000238  9502              STR      r5,[sp,#8]
00023a  980c              LDR      r0,[sp,#0x30]
00023c  c804              LDM      r0!,{r2}
00023e  2310              MOVS     r3,#0x10
000240  4631              MOV      r1,r6
000242  900c              STR      r0,[sp,#0x30]
000244  4620              MOV      r0,r4
000246  f7fffffe          BL       print_number
00024a  4604              MOV      r4,r0
;;;927                                   (long)va_arg(args, void *),
;;;928                                   16, field_width, precision, flags);
;;;929    #else
;;;930                str = print_number(str, end,
;;;931                                   (long)va_arg(args, void *),
;;;932                                   16, field_width, flags);
;;;933    #endif
;;;934                continue;
00024c  e055              B        |L28.762|
                  |L28.590|
00024e  e012              B        |L28.630|
                  |L28.592|
;;;935    
;;;936            case '%':
;;;937                if (str <= end) *str = '%';
000250  42b4              CMP      r4,r6
000252  d801              BHI      |L28.600|
000254  2025              MOVS     r0,#0x25
000256  7020              STRB     r0,[r4,#0]
                  |L28.600|
;;;938                ++ str;
000258  1c64              ADDS     r4,r4,#1
;;;939                continue;
00025a  e04e              B        |L28.762|
                  |L28.604|
;;;940    
;;;941            /* integer number formats - set up the flags and "break" */
;;;942            case 'o':
;;;943                base = 8;
00025c  2008              MOVS     r0,#8
00025e  9005              STR      r0,[sp,#0x14]
;;;944                break;
000260  e01d              B        |L28.670|
                  |L28.610|
;;;945    
;;;946            case 'X':
;;;947                flags |= LARGE;
000262  f0450540          ORR      r5,r5,#0x40
;;;948            case 'x':
000266  bf00              NOP      
                  |L28.616|
;;;949                base = 16;
000268  2010              MOVS     r0,#0x10
00026a  9005              STR      r0,[sp,#0x14]
;;;950                break;
00026c  e017              B        |L28.670|
                  |L28.622|
;;;951    
;;;952            case 'd':
;;;953            case 'i':
00026e  bf00              NOP      
                  |L28.624|
;;;954                flags |= SIGN;
000270  f0450502          ORR      r5,r5,#2
;;;955            case 'u':
000274  bf00              NOP      
                  |L28.630|
;;;956                break;
000276  e012              B        |L28.670|
                  |L28.632|
;;;957    
;;;958            default:
;;;959                if (str <= end) *str = '%';
000278  42b4              CMP      r4,r6
00027a  d801              BHI      |L28.640|
00027c  2025              MOVS     r0,#0x25
00027e  7020              STRB     r0,[r4,#0]
                  |L28.640|
;;;960                ++ str;
000280  1c64              ADDS     r4,r4,#1
;;;961    
;;;962                if (*fmt)
000282  980b              LDR      r0,[sp,#0x2c]
000284  7800              LDRB     r0,[r0,#0]
000286  b130              CBZ      r0,|L28.662|
;;;963                {
;;;964                    if (str <= end) *str = *fmt;
000288  42b4              CMP      r4,r6
00028a  d802              BHI      |L28.658|
00028c  980b              LDR      r0,[sp,#0x2c]
00028e  7800              LDRB     r0,[r0,#0]
000290  7020              STRB     r0,[r4,#0]
                  |L28.658|
;;;965                    ++ str;
000292  1c64              ADDS     r4,r4,#1
000294  e002              B        |L28.668|
                  |L28.662|
;;;966                }
;;;967                else
;;;968                {
;;;969                    -- fmt;
000296  980b              LDR      r0,[sp,#0x2c]
000298  1e40              SUBS     r0,r0,#1
00029a  900b              STR      r0,[sp,#0x2c]
                  |L28.668|
;;;970                }
;;;971                continue;
00029c  e02d              B        |L28.762|
                  |L28.670|
00029e  bf00              NOP                            ;944
;;;972            }
;;;973    
;;;974    #ifdef RT_PRINTF_LONGLONG
;;;975            if (qualifier == 'L') num = va_arg(args, long long);
;;;976            else if (qualifier == 'l')
;;;977    #else
;;;978            if (qualifier == 'l')
0002a0  9804              LDR      r0,[sp,#0x10]
0002a2  286c              CMP      r0,#0x6c
0002a4  d107              BNE      |L28.694|
;;;979    #endif
;;;980            {
;;;981                num = va_arg(args, rt_uint32_t);
0002a6  980c              LDR      r0,[sp,#0x30]
0002a8  f850ab04          LDR      r10,[r0],#4
0002ac  900c              STR      r0,[sp,#0x30]
;;;982                if (flags & SIGN) num = (rt_int32_t)num;
0002ae  f0050002          AND      r0,r5,#2
0002b2  b1b8              CBZ      r0,|L28.740|
0002b4  e016              B        |L28.740|
                  |L28.694|
;;;983            }
;;;984            else if (qualifier == 'h')
0002b6  9804              LDR      r0,[sp,#0x10]
0002b8  2868              CMP      r0,#0x68
0002ba  d10b              BNE      |L28.724|
;;;985            {
;;;986                num = (rt_uint16_t)va_arg(args, rt_int32_t);
0002bc  980c              LDR      r0,[sp,#0x30]
0002be  f8301b04          LDRH     r1,[r0],#4
0002c2  fa1ffa81          UXTH     r10,r1
0002c6  900c              STR      r0,[sp,#0x30]
;;;987                if (flags & SIGN) num = (rt_int16_t)num;
0002c8  f0050002          AND      r0,r5,#2
0002cc  b150              CBZ      r0,|L28.740|
0002ce  fa0ffa8a          SXTH     r10,r10
0002d2  e007              B        |L28.740|
                  |L28.724|
;;;988            }
;;;989            else
;;;990            {
;;;991                num = va_arg(args, rt_uint32_t);
0002d4  980c              LDR      r0,[sp,#0x30]
0002d6  f850ab04          LDR      r10,[r0],#4
0002da  900c              STR      r0,[sp,#0x30]
;;;992                if (flags & SIGN) num = (rt_int32_t)num;
0002dc  f0050002          AND      r0,r5,#2
0002e0  b100              CBZ      r0,|L28.740|
0002e2  bf00              NOP      
                  |L28.740|
;;;993            }
;;;994    #ifdef RT_PRINTF_PRECISION
;;;995            str = print_number(str, end, num, base, field_width, precision, flags);
0002e4  e9cd7900          STRD     r7,r9,[sp,#0]
0002e8  9502              STR      r5,[sp,#8]
0002ea  4652              MOV      r2,r10
0002ec  4631              MOV      r1,r6
0002ee  4620              MOV      r0,r4
0002f0  9b05              LDR      r3,[sp,#0x14]
0002f2  f7fffffe          BL       print_number
0002f6  4604              MOV      r4,r0
0002f8  bf00              NOP                            ;791
                  |L28.762|
0002fa  980b              LDR      r0,[sp,#0x2c]         ;784
0002fc  1c40              ADDS     r0,r0,#1              ;784
0002fe  900b              STR      r0,[sp,#0x2c]         ;784
                  |L28.768|
000300  980b              LDR      r0,[sp,#0x2c]         ;784
000302  7800              LDRB     r0,[r0,#0]            ;784
000304  2800              CMP      r0,#0                 ;784
000306  f47fae8b          BNE      |L28.32|
;;;996    #else
;;;997            str = print_number(str, end, num, base, field_width, flags);
;;;998    #endif
;;;999        }
;;;1000   
;;;1001       if (str <= end) *str = '\0';
00030a  42b4              CMP      r4,r6
00030c  d801              BHI      |L28.786|
00030e  7020              STRB     r0,[r4,#0]
000310  e001              B        |L28.790|
                  |L28.786|
;;;1002       else *end = '\0';
000312  2000              MOVS     r0,#0
000314  7030              STRB     r0,[r6,#0]
                  |L28.790|
;;;1003   
;;;1004       /* the trailing null byte doesn't count towards the total
;;;1005       * ++str;
;;;1006       */
;;;1007       return str - buf;
000316  eba40008          SUB      r0,r4,r8
;;;1008   }
00031a  b00d              ADD      sp,sp,#0x34
00031c  e8bd8ff0          POP      {r4-r11,pc}
;;;1009   RTM_EXPORT(rt_vsnprintf);
                          ENDP

                  |L28.800|
000320  284e554c          DCB      "(NULL)",0
000324  4c2900  
000327  00                DCB      0

                          AREA ||i.rt_vsprintf||, CODE, READONLY, ALIGN=1

                  rt_vsprintf PROC
;;;1037    */
;;;1038   rt_int32_t rt_vsprintf(char *buf, const char *format, va_list arg_ptr)
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;1039   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1040       return rt_vsnprintf(buf, (rt_size_t) - 1, format, arg_ptr);
000006  4622              MOV      r2,r4
000008  f04f31ff          MOV      r1,#0xffffffff
00000c  4628              MOV      r0,r5
00000e  9b02              LDR      r3,[sp,#8]
000010  f7fffffe          BL       rt_vsnprintf
;;;1041   }
000014  bd3e              POP      {r1-r5,pc}
;;;1042   RTM_EXPORT(rt_vsprintf);
                          ENDP


                          AREA ||i.skip_atoi||, CODE, READONLY, ALIGN=1

                  skip_atoi PROC
;;;570    
;;;571    rt_inline int skip_atoi(const char **s)
000000  4601              MOV      r1,r0
;;;572    {
;;;573        register int i = 0;
000002  2000              MOVS     r0,#0
;;;574        while (isdigit(**s))
000004  e009              B        |L30.26|
                  |L30.6|
;;;575            i = i * 10 + *((*s)++) - '0';
000006  680b              LDR      r3,[r1,#0]
000008  1c5a              ADDS     r2,r3,#1
00000a  600a              STR      r2,[r1,#0]
00000c  781a              LDRB     r2,[r3,#0]
00000e  eb000380          ADD      r3,r0,r0,LSL #2
000012  eb020243          ADD      r2,r2,r3,LSL #1
000016  f1a20030          SUB      r0,r2,#0x30
                  |L30.26|
00001a  680a              LDR      r2,[r1,#0]            ;574
00001c  7812              LDRB     r2,[r2,#0]            ;574
00001e  3a30              SUBS     r2,r2,#0x30           ;574
000020  2a0a              CMP      r2,#0xa               ;574
000022  d3f0              BCC      |L30.6|
;;;576    
;;;577        return i;
;;;578    }
000024  4770              BX       lr
;;;579    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  rt_log_buf
                          %        128

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __lowest_bit_bitmap
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00
                  small_digits
000100  30313233          DCB      0x30,0x31,0x32,0x33
000104  34353637          DCB      0x34,0x35,0x36,0x37
000108  38396162          DCB      0x38,0x39,0x61,0x62
00010c  63646566          DCB      0x63,0x64,0x65,0x66
000110  00                DCB      0x00
                  large_digits
000111  303132            DCB      0x30,0x31,0x32
000114  33343536          DCB      0x33,0x34,0x35,0x36
000118  37383941          DCB      0x37,0x38,0x39,0x41
00011c  42434445          DCB      0x42,0x43,0x44,0x45
000120  4600              DCB      0x46,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  __rt_errno
                          DCD      0x00000000
                  _console_device
                          DCD      0x00000000

; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\ipc.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\ipc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\ipc.crf ..\rtthread\src\ipc.c]
                          THUMB

                          AREA ||i.rt_ipc_list_resume||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume PROC
;;;145     */
;;;146    rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
000000  b570              PUSH     {r4-r6,lr}
;;;147    {
000002  4604              MOV      r4,r0
;;;148        struct rt_thread *thread;
;;;149    
;;;150        /* get thread entry */
;;;151        thread = rt_list_entry(list->next, struct rt_thread, tlist);
000004  6820              LDR      r0,[r4,#0]
000006  f1a00514          SUB      r5,r0,#0x14
;;;152    
;;;153        RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));
;;;154    
;;;155        /* resume it */
;;;156        rt_thread_resume(thread);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       rt_thread_resume
;;;157    
;;;158        return RT_EOK;
000010  2000              MOVS     r0,#0
;;;159    }
000012  bd70              POP      {r4-r6,pc}
;;;160    
                          ENDP


                          AREA ||i.rt_ipc_list_resume_all||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume_all PROC
;;;168     */
;;;169    rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
000000  b570              PUSH     {r4-r6,lr}
;;;170    {
000002  4605              MOV      r5,r0
;;;171        struct rt_thread *thread;
;;;172        register rt_ubase_t temp;
;;;173    
;;;174        /* wakeup all suspend threads */
;;;175        while (!rt_list_isempty(list))
000004  e00e              B        |L2.36|
                  |L2.6|
;;;176        {
;;;177            /* disable interrupt */
;;;178            temp = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
;;;179    
;;;180            /* get next suspend thread */
;;;181            thread = rt_list_entry(list->next, struct rt_thread, tlist);
00000c  6828              LDR      r0,[r5,#0]
00000e  f1a00414          SUB      r4,r0,#0x14
;;;182            /* set error code to RT_ERROR */
;;;183            thread->error = -RT_ERROR;
000012  f04f30ff          MOV      r0,#0xffffffff
000016  6320              STR      r0,[r4,#0x30]
;;;184    
;;;185            /*
;;;186             * resume thread
;;;187             * In rt_thread_resume function, it will remove current thread from
;;;188             * suspend list
;;;189             */
;;;190            rt_thread_resume(thread);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_thread_resume
;;;191    
;;;192            /* enable interrupt */
;;;193            rt_hw_interrupt_enable(temp);
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       rt_hw_interrupt_enable
                  |L2.36|
000024  4628              MOV      r0,r5                 ;175
000026  f7fffffe          BL       rt_list_isempty
00002a  2800              CMP      r0,#0                 ;175
00002c  d0eb              BEQ      |L2.6|
;;;194        }
;;;195    
;;;196        return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;197    }
000030  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP


                          AREA ||i.rt_ipc_list_suspend||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_suspend PROC
;;;91      */
;;;92     rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;93                                            struct rt_thread *thread,
;;;94                                            rt_uint8_t        flag)
;;;95     {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4690              MOV      r8,r2
;;;96         /* suspend thread */
;;;97         rt_thread_suspend(thread);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_thread_suspend
;;;98     
;;;99         switch (flag)
000010  f1b80f00          CMP      r8,#0
000014  d003              BEQ      |L3.30|
000016  f1b80f01          CMP      r8,#1
00001a  d123              BNE      |L3.100|
00001c  e005              B        |L3.42|
                  |L3.30|
;;;100        {
;;;101        case RT_IPC_FLAG_FIFO:
;;;102            rt_list_insert_before(list, &(thread->tlist));
00001e  f1040114          ADD      r1,r4,#0x14
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       rt_list_insert_before
;;;103            break;
000028  e01c              B        |L3.100|
                  |L3.42|
;;;104    
;;;105        case RT_IPC_FLAG_PRIO:
;;;106            {
;;;107                struct rt_list_node *n;
;;;108                struct rt_thread *sthread;
;;;109    
;;;110                /* find a suitable position */
;;;111                for (n = list->next; n != list; n = n->next)
00002a  682e              LDR      r6,[r5,#0]
00002c  e00f              B        |L3.78|
                  |L3.46|
;;;112                {
;;;113                    sthread = rt_list_entry(n, struct rt_thread, tlist);
00002e  f1a60714          SUB      r7,r6,#0x14
;;;114    
;;;115                    /* find out */
;;;116                    if (thread->current_priority < sthread->current_priority)
000032  f8940035          LDRB     r0,[r4,#0x35]
000036  f8971035          LDRB     r1,[r7,#0x35]
00003a  4288              CMP      r0,r1
00003c  da06              BGE      |L3.76|
;;;117                    {
;;;118                        /* insert this thread before the sthread */
;;;119                        rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
00003e  f1040114          ADD      r1,r4,#0x14
000042  f1070014          ADD      r0,r7,#0x14
000046  f7fffffe          BL       rt_list_insert_before
;;;120                        break;
00004a  e002              B        |L3.82|
                  |L3.76|
00004c  6836              LDR      r6,[r6,#0]            ;111
                  |L3.78|
00004e  42ae              CMP      r6,r5                 ;111
000050  d1ed              BNE      |L3.46|
                  |L3.82|
000052  bf00              NOP      
;;;121                    }
;;;122                }
;;;123    
;;;124                /*
;;;125                 * not found a suitable position,
;;;126                 * append to the end of suspend_thread list
;;;127                 */
;;;128                if (n == list)
000054  42ae              CMP      r6,r5
000056  d104              BNE      |L3.98|
;;;129                    rt_list_insert_before(list, &(thread->tlist));
000058  f1040114          ADD      r1,r4,#0x14
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       rt_list_insert_before
                  |L3.98|
;;;130            }
;;;131            break;
000062  bf00              NOP      
                  |L3.100|
000064  bf00              NOP                            ;103
;;;132        }
;;;133    
;;;134        return RT_EOK;
000066  2000              MOVS     r0,#0
;;;135    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP


                          AREA ||i.rt_ipc_object_init||, CODE, READONLY, ALIGN=1

                  rt_ipc_object_init PROC
;;;72      */
;;;73     rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc)
000000  b510              PUSH     {r4,lr}
;;;74     {
000002  4604              MOV      r4,r0
;;;75         /* init ipc object */
;;;76         rt_list_init(&(ipc->suspend_thread));
000004  f1040014          ADD      r0,r4,#0x14
000008  f7fffffe          BL       rt_list_init
;;;77     
;;;78         return RT_EOK;
00000c  2000              MOVS     r0,#0
;;;79     }
00000e  bd10              POP      {r4,pc}
;;;80     
                          ENDP


                          AREA ||i.rt_list_init||, CODE, READONLY, ALIGN=1

                  rt_list_init PROC
;;;60      */
;;;61     rt_inline void rt_list_init(rt_list_t *l)
000000  6040              STR      r0,[r0,#4]
;;;62     {
;;;63         l->next = l->prev = l;
000002  6000              STR      r0,[r0,#0]
;;;64     }
000004  4770              BX       lr
;;;65     
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;86      */
;;;87     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;88     {
;;;89         l->prev->next = n;
000002  6011              STR      r1,[r2,#0]
;;;90         n->prev = l->prev;
000004  6842              LDR      r2,[r0,#4]
000006  604a              STR      r2,[r1,#4]
;;;91     
;;;92         l->prev = n;
000008  6041              STR      r1,[r0,#4]
;;;93         n->next = l;
00000a  6008              STR      r0,[r1,#0]
;;;94     }
00000c  4770              BX       lr
;;;95     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;111     */
;;;112    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  4601              MOV      r1,r0
;;;113    {
;;;114        return l->next == l;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d101              BNE      |L7.12|
000008  2001              MOVS     r0,#1
                  |L7.10|
;;;115    }
00000a  4770              BX       lr
                  |L7.12|
00000c  2000              MOVS     r0,#0                 ;114
00000e  e7fc              B        |L7.10|
;;;116    
                          ENDP


                          AREA ||i.rt_mb_control||, CODE, READONLY, ALIGN=1

                  rt_mb_control PROC
;;;1691    */
;;;1692   rt_err_t rt_mb_control(rt_mailbox_t mb, int cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1693   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4617              MOV      r7,r2
;;;1694       rt_ubase_t level;
;;;1695       RT_ASSERT(mb != RT_NULL);
;;;1696   
;;;1697       if (cmd == RT_IPC_CMD_RESET)
00000a  2d01              CMP      r5,#1
00000c  d116              BNE      |L8.60|
;;;1698       {
;;;1699           /* disable interrupt */
;;;1700           level = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  4606              MOV      r6,r0
;;;1701   
;;;1702           /* resume all waiting thread */
;;;1703           rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000014  f1040014          ADD      r0,r4,#0x14
000018  f7fffffe          BL       rt_ipc_list_resume_all
;;;1704           /* also resume all mailbox private suspended thread */
;;;1705           rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00001c  f1040028          ADD      r0,r4,#0x28
000020  f7fffffe          BL       rt_ipc_list_resume_all
;;;1706   
;;;1707           /* re-init mailbox */
;;;1708           mb->entry      = 0;
000024  2000              MOVS     r0,#0
000026  8460              STRH     r0,[r4,#0x22]
;;;1709           mb->in_offset  = 0;
000028  84a0              STRH     r0,[r4,#0x24]
;;;1710           mb->out_offset = 0;
00002a  84e0              STRH     r0,[r4,#0x26]
;;;1711   
;;;1712           /* enable interrupt */
;;;1713           rt_hw_interrupt_enable(level);
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       rt_hw_interrupt_enable
;;;1714   
;;;1715           rt_schedule();
000032  f7fffffe          BL       rt_schedule
;;;1716   
;;;1717           return RT_EOK;
000036  2000              MOVS     r0,#0
                  |L8.56|
;;;1718       }
;;;1719   
;;;1720       return -RT_ERROR;
;;;1721   }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L8.60|
00003c  f04f30ff          MOV      r0,#0xffffffff        ;1720
000040  e7fa              B        |L8.56|
;;;1722   RTM_EXPORT(rt_mb_control);
                          ENDP


                          AREA ||i.rt_mb_create||, CODE, READONLY, ALIGN=1

                  rt_mb_create PROC
;;;1323    */
;;;1324   rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1325   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1326       rt_mailbox_t mb;
;;;1327   
;;;1328       RT_DEBUG_NOT_IN_INTERRUPT;
;;;1329   
;;;1330       /* allocate object */
;;;1331       mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
00000a  4629              MOV      r1,r5
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       rt_object_allocate
000012  4604              MOV      r4,r0
;;;1332       if (mb == RT_NULL)
000014  b914              CBNZ     r4,|L9.28|
;;;1333           return mb;
000016  4620              MOV      r0,r4
                  |L9.24|
;;;1334   
;;;1335       /* set parent */
;;;1336       mb->parent.parent.flag = flag;
;;;1337   
;;;1338       /* init ipc object */
;;;1339       rt_ipc_object_init(&(mb->parent));
;;;1340   
;;;1341       /* init mailbox */
;;;1342       mb->size     = size;
;;;1343       mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
;;;1344       if (mb->msg_pool == RT_NULL)
;;;1345       {
;;;1346           /* delete mailbox object */
;;;1347           rt_object_delete(&(mb->parent.parent));
;;;1348   
;;;1349           return RT_NULL;
;;;1350       }
;;;1351       mb->entry      = 0;
;;;1352       mb->in_offset  = 0;
;;;1353       mb->out_offset = 0;
;;;1354   
;;;1355       /* init an additional list of sender suspend thread */
;;;1356       rt_list_init(&(mb->suspend_sender_thread));
;;;1357   
;;;1358       return mb;
;;;1359   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L9.28|
00001c  7267              STRB     r7,[r4,#9]            ;1336
00001e  4620              MOV      r0,r4                 ;1339
000020  f7fffffe          BL       rt_ipc_object_init
000024  8426              STRH     r6,[r4,#0x20]         ;1342
000026  8c21              LDRH     r1,[r4,#0x20]         ;1343
000028  0088              LSLS     r0,r1,#2              ;1343
00002a  f7fffffe          BL       rt_malloc
00002e  61e0              STR      r0,[r4,#0x1c]         ;1343
000030  69e0              LDR      r0,[r4,#0x1c]         ;1344
000032  b920              CBNZ     r0,|L9.62|
000034  4620              MOV      r0,r4                 ;1347
000036  f7fffffe          BL       rt_object_delete
00003a  2000              MOVS     r0,#0                 ;1349
00003c  e7ec              B        |L9.24|
                  |L9.62|
00003e  2000              MOVS     r0,#0                 ;1351
000040  8460              STRH     r0,[r4,#0x22]         ;1351
000042  84a0              STRH     r0,[r4,#0x24]         ;1352
000044  84e0              STRH     r0,[r4,#0x26]         ;1353
000046  f1040028          ADD      r0,r4,#0x28           ;1356
00004a  f7fffffe          BL       rt_list_init
00004e  4620              MOV      r0,r4                 ;1358
000050  e7e2              B        |L9.24|
;;;1360   RTM_EXPORT(rt_mb_create);
                          ENDP


                          AREA ||i.rt_mb_delete||, CODE, READONLY, ALIGN=1

                  rt_mb_delete PROC
;;;1368    */
;;;1369   rt_err_t rt_mb_delete(rt_mailbox_t mb)
000000  b510              PUSH     {r4,lr}
;;;1370   {
000002  4604              MOV      r4,r0
;;;1371       RT_DEBUG_NOT_IN_INTERRUPT;
;;;1372   
;;;1373       /* parameter check */
;;;1374       RT_ASSERT(mb != RT_NULL);
;;;1375   
;;;1376       /* resume all suspended thread */
;;;1377       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000004  f1040014          ADD      r0,r4,#0x14
000008  f7fffffe          BL       rt_ipc_list_resume_all
;;;1378   
;;;1379       /* also resume all mailbox private suspended thread */
;;;1380       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00000c  f1040028          ADD      r0,r4,#0x28
000010  f7fffffe          BL       rt_ipc_list_resume_all
;;;1381   
;;;1382   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1383       /* the mb object belongs to an application module */
;;;1384       if (mb->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1385           rt_module_free(mb->parent.parent.module_id, mb->msg_pool);
;;;1386       else
;;;1387   #endif
;;;1388   
;;;1389           /* free mailbox pool */
;;;1390           RT_KERNEL_FREE(mb->msg_pool);
000014  69e0              LDR      r0,[r4,#0x1c]
000016  f7fffffe          BL       rt_free
;;;1391   
;;;1392       /* delete mailbox object */
;;;1393       rt_object_delete(&(mb->parent.parent));
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_object_delete
;;;1394   
;;;1395       return RT_EOK;
000020  2000              MOVS     r0,#0
;;;1396   }
000022  bd10              POP      {r4,pc}
;;;1397   RTM_EXPORT(rt_mb_delete);
                          ENDP


                          AREA ||i.rt_mb_detach||, CODE, READONLY, ALIGN=1

                  rt_mb_detach PROC
;;;1296    */
;;;1297   rt_err_t rt_mb_detach(rt_mailbox_t mb)
000000  b510              PUSH     {r4,lr}
;;;1298   {
000002  4604              MOV      r4,r0
;;;1299       /* parameter check */
;;;1300       RT_ASSERT(mb != RT_NULL);
;;;1301   
;;;1302       /* resume all suspended thread */
;;;1303       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000004  f1040014          ADD      r0,r4,#0x14
000008  f7fffffe          BL       rt_ipc_list_resume_all
;;;1304       /* also resume all mailbox private suspended thread */
;;;1305       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00000c  f1040028          ADD      r0,r4,#0x28
000010  f7fffffe          BL       rt_ipc_list_resume_all
;;;1306   
;;;1307       /* detach mailbox object */
;;;1308       rt_object_detach(&(mb->parent.parent));
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rt_object_detach
;;;1309   
;;;1310       return RT_EOK;
00001a  2000              MOVS     r0,#0
;;;1311   }
00001c  bd10              POP      {r4,pc}
;;;1312   RTM_EXPORT(rt_mb_detach);
                          ENDP


                          AREA ||i.rt_mb_init||, CODE, READONLY, ALIGN=1

                  rt_mb_init PROC
;;;1258    */
;;;1259   rt_err_t rt_mb_init(rt_mailbox_t mb,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1260                       const char  *name,
;;;1261                       void        *msgpool,
;;;1262                       rt_size_t    size,
;;;1263                       rt_uint8_t   flag)
;;;1264   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8dd8018          LDR      r8,[sp,#0x18]
;;;1265       RT_ASSERT(mb != RT_NULL);
;;;1266   
;;;1267       /* init object */
;;;1268       rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
000010  462a              MOV      r2,r5
000012  2104              MOVS     r1,#4
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rt_object_init
;;;1269   
;;;1270       /* set parent flag */
;;;1271       mb->parent.parent.flag = flag;
00001a  f8848009          STRB     r8,[r4,#9]
;;;1272   
;;;1273       /* init ipc object */
;;;1274       rt_ipc_object_init(&(mb->parent));
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       rt_ipc_object_init
;;;1275   
;;;1276       /* init mailbox */
;;;1277       mb->msg_pool   = msgpool;
000024  61e6              STR      r6,[r4,#0x1c]
;;;1278       mb->size       = size;
000026  8427              STRH     r7,[r4,#0x20]
;;;1279       mb->entry      = 0;
000028  2000              MOVS     r0,#0
00002a  8460              STRH     r0,[r4,#0x22]
;;;1280       mb->in_offset  = 0;
00002c  84a0              STRH     r0,[r4,#0x24]
;;;1281       mb->out_offset = 0;
00002e  84e0              STRH     r0,[r4,#0x26]
;;;1282   
;;;1283       /* init an additional list of sender suspend thread */
;;;1284       rt_list_init(&(mb->suspend_sender_thread));
000030  f1040028          ADD      r0,r4,#0x28
000034  f7fffffe          BL       rt_list_init
;;;1285   
;;;1286       return RT_EOK;
000038  2000              MOVS     r0,#0
;;;1287   }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;1288   RTM_EXPORT(rt_mb_init);
                          ENDP


                          AREA ||i.rt_mb_recv||, CODE, READONLY, ALIGN=1

                  rt_mb_recv PROC
;;;1556    */
;;;1557   rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)
000000  e92d43f7          PUSH     {r0-r2,r4-r9,lr}
;;;1558   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1559       struct rt_thread *thread;
;;;1560       register rt_ubase_t temp;
;;;1561       rt_uint32_t tick_delta;
;;;1562   
;;;1563       /* parameter check */
;;;1564       RT_ASSERT(mb != RT_NULL);
;;;1565   
;;;1566       /* initialize delta tick */
;;;1567       tick_delta = 0;
000008  2700              MOVS     r7,#0
;;;1568       /* get current thread */
;;;1569       thread = rt_thread_self();
00000a  f7fffffe          BL       rt_thread_self
00000e  4605              MOV      r5,r0
;;;1570   
;;;1571       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
;;;1572   
;;;1573       /* disable interrupt */
;;;1574       temp = rt_hw_interrupt_disable();
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4680              MOV      r8,r0
;;;1575   
;;;1576       /* for non-blocking call */
;;;1577       if (mb->entry == 0 && timeout == 0)
000016  8c60              LDRH     r0,[r4,#0x22]
000018  b938              CBNZ     r0,|L13.42|
00001a  9802              LDR      r0,[sp,#8]
00001c  b928              CBNZ     r0,|L13.42|
;;;1578       {
;;;1579           rt_hw_interrupt_enable(temp);
00001e  4640              MOV      r0,r8
000020  f7fffffe          BL       rt_hw_interrupt_enable
;;;1580   
;;;1581           return -RT_ETIMEOUT;
000024  1eb8              SUBS     r0,r7,#2
                  |L13.38|
;;;1582       }
;;;1583   
;;;1584       /* mailbox is empty */
;;;1585       while (mb->entry == 0)
;;;1586       {
;;;1587           /* reset error number in thread */
;;;1588           thread->error = RT_EOK;
;;;1589   
;;;1590           /* no waiting, return timeout */
;;;1591           if (timeout == 0)
;;;1592           {
;;;1593               /* enable interrupt */
;;;1594               rt_hw_interrupt_enable(temp);
;;;1595   
;;;1596               thread->error = -RT_ETIMEOUT;
;;;1597   
;;;1598               return -RT_ETIMEOUT;
;;;1599           }
;;;1600   
;;;1601           RT_DEBUG_IN_THREAD_CONTEXT;
;;;1602           /* suspend current thread */
;;;1603           rt_ipc_list_suspend(&(mb->parent.suspend_thread),
;;;1604                               thread,
;;;1605                               mb->parent.parent.flag);
;;;1606   
;;;1607           /* has waiting time, start thread timer */
;;;1608           if (timeout > 0)
;;;1609           {
;;;1610               /* get the start tick of timer */
;;;1611               tick_delta = rt_tick_get();
;;;1612   
;;;1613               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
;;;1614                                           thread->name));
;;;1615   
;;;1616               /* reset the timeout of thread timer and start it */
;;;1617               rt_timer_control(&(thread->thread_timer),
;;;1618                                RT_TIMER_CTRL_SET_TIME,
;;;1619                                &timeout);
;;;1620               rt_timer_start(&(thread->thread_timer));
;;;1621           }
;;;1622   
;;;1623           /* enable interrupt */
;;;1624           rt_hw_interrupt_enable(temp);
;;;1625   
;;;1626           /* re-schedule */
;;;1627           rt_schedule();
;;;1628   
;;;1629           /* resume from suspend state */
;;;1630           if (thread->error != RT_EOK)
;;;1631           {
;;;1632               /* return error */
;;;1633               return thread->error;
;;;1634           }
;;;1635   
;;;1636           /* disable interrupt */
;;;1637           temp = rt_hw_interrupt_disable();
;;;1638   
;;;1639           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1640           if (timeout > 0)
;;;1641           {
;;;1642               tick_delta = rt_tick_get() - tick_delta;
;;;1643               timeout -= tick_delta;
;;;1644               if (timeout < 0)
;;;1645                   timeout = 0;
;;;1646           }
;;;1647       }
;;;1648   
;;;1649       /* fill ptr */
;;;1650       *value = mb->msg_pool[mb->out_offset];
;;;1651   
;;;1652       /* increase output offset */
;;;1653       ++ mb->out_offset;
;;;1654       if (mb->out_offset >= mb->size)
;;;1655           mb->out_offset = 0;
;;;1656       /* decrease message entry */
;;;1657       mb->entry --;
;;;1658   
;;;1659       /* resume suspended thread */
;;;1660       if (!rt_list_isempty(&(mb->suspend_sender_thread)))
;;;1661       {
;;;1662           rt_ipc_list_resume(&(mb->suspend_sender_thread));
;;;1663   
;;;1664           /* enable interrupt */
;;;1665           rt_hw_interrupt_enable(temp);
;;;1666   
;;;1667           RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1668   
;;;1669           rt_schedule();
;;;1670   
;;;1671           return RT_EOK;
;;;1672       }
;;;1673   
;;;1674       /* enable interrupt */
;;;1675       rt_hw_interrupt_enable(temp);
;;;1676   
;;;1677       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1678   
;;;1679       return RT_EOK;
;;;1680   }
000026  e8bd83fe          POP      {r1-r9,pc}
                  |L13.42|
00002a  e03a              B        |L13.162|
                  |L13.44|
00002c  2000              MOVS     r0,#0                 ;1588
00002e  6328              STR      r0,[r5,#0x30]         ;1588
000030  9802              LDR      r0,[sp,#8]            ;1591
000032  b930              CBNZ     r0,|L13.66|
000034  4640              MOV      r0,r8                 ;1594
000036  f7fffffe          BL       rt_hw_interrupt_enable
00003a  f06f0001          MVN      r0,#1                 ;1596
00003e  6328              STR      r0,[r5,#0x30]         ;1596
000040  e7f1              B        |L13.38|
                  |L13.66|
000042  7a62              LDRB     r2,[r4,#9]            ;1603
000044  4629              MOV      r1,r5                 ;1603
000046  f1040014          ADD      r0,r4,#0x14           ;1603
00004a  f7fffffe          BL       rt_ipc_list_suspend
00004e  9802              LDR      r0,[sp,#8]            ;1608
000050  2800              CMP      r0,#0                 ;1608
000052  dd0c              BLE      |L13.110|
000054  f7fffffe          BL       rt_tick_get
000058  4607              MOV      r7,r0                 ;1611
00005a  aa02              ADD      r2,sp,#8              ;1617
00005c  2100              MOVS     r1,#0                 ;1617
00005e  f1050044          ADD      r0,r5,#0x44           ;1617
000062  f7fffffe          BL       rt_timer_control
000066  f1050044          ADD      r0,r5,#0x44           ;1620
00006a  f7fffffe          BL       rt_timer_start
                  |L13.110|
00006e  4640              MOV      r0,r8                 ;1624
000070  f7fffffe          BL       rt_hw_interrupt_enable
000074  f7fffffe          BL       rt_schedule
000078  6b28              LDR      r0,[r5,#0x30]         ;1630
00007a  b108              CBZ      r0,|L13.128|
00007c  6b28              LDR      r0,[r5,#0x30]         ;1633
00007e  e7d2              B        |L13.38|
                  |L13.128|
000080  f7fffffe          BL       rt_hw_interrupt_disable
000084  4680              MOV      r8,r0                 ;1637
000086  9802              LDR      r0,[sp,#8]            ;1640
000088  2800              CMP      r0,#0                 ;1640
00008a  dd0a              BLE      |L13.162|
00008c  f7fffffe          BL       rt_tick_get
000090  1bc7              SUBS     r7,r0,r7              ;1642
000092  9802              LDR      r0,[sp,#8]            ;1643
000094  1bc0              SUBS     r0,r0,r7              ;1643
000096  9002              STR      r0,[sp,#8]            ;1643
000098  9802              LDR      r0,[sp,#8]            ;1644
00009a  2800              CMP      r0,#0                 ;1644
00009c  da01              BGE      |L13.162|
00009e  2000              MOVS     r0,#0                 ;1645
0000a0  9002              STR      r0,[sp,#8]            ;1645
                  |L13.162|
0000a2  8c60              LDRH     r0,[r4,#0x22]         ;1585
0000a4  2800              CMP      r0,#0                 ;1585
0000a6  d0c1              BEQ      |L13.44|
0000a8  8ce1              LDRH     r1,[r4,#0x26]         ;1650
0000aa  69e0              LDR      r0,[r4,#0x1c]         ;1650
0000ac  f8500021          LDR      r0,[r0,r1,LSL #2]     ;1650
0000b0  6030              STR      r0,[r6,#0]            ;1650
0000b2  8ce0              LDRH     r0,[r4,#0x26]         ;1653
0000b4  1c40              ADDS     r0,r0,#1              ;1653
0000b6  84e0              STRH     r0,[r4,#0x26]         ;1653
0000b8  8ce0              LDRH     r0,[r4,#0x26]         ;1654
0000ba  8c21              LDRH     r1,[r4,#0x20]         ;1654
0000bc  4288              CMP      r0,r1                 ;1654
0000be  db01              BLT      |L13.196|
0000c0  2000              MOVS     r0,#0                 ;1655
0000c2  84e0              STRH     r0,[r4,#0x26]         ;1655
                  |L13.196|
0000c4  8c60              LDRH     r0,[r4,#0x22]         ;1657
0000c6  1e40              SUBS     r0,r0,#1              ;1657
0000c8  8460              STRH     r0,[r4,#0x22]         ;1657
0000ca  f1040028          ADD      r0,r4,#0x28           ;1660
0000ce  f7fffffe          BL       rt_list_isempty
0000d2  b950              CBNZ     r0,|L13.234|
0000d4  f1040028          ADD      r0,r4,#0x28           ;1662
0000d8  f7fffffe          BL       rt_ipc_list_resume
0000dc  4640              MOV      r0,r8                 ;1665
0000de  f7fffffe          BL       rt_hw_interrupt_enable
0000e2  f7fffffe          BL       rt_schedule
0000e6  2000              MOVS     r0,#0                 ;1671
0000e8  e79d              B        |L13.38|
                  |L13.234|
0000ea  4640              MOV      r0,r8                 ;1675
0000ec  f7fffffe          BL       rt_hw_interrupt_enable
0000f0  2000              MOVS     r0,#0                 ;1679
0000f2  e798              B        |L13.38|
;;;1681   RTM_EXPORT(rt_mb_recv);
                          ENDP


                          AREA ||i.rt_mb_send||, CODE, READONLY, ALIGN=1

                  rt_mb_send PROC
;;;1540    */
;;;1541   rt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value)
000000  b570              PUSH     {r4-r6,lr}
;;;1542   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1543       return rt_mb_send_wait(mb, value, 0);
000006  2200              MOVS     r2,#0
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_mb_send_wait
;;;1544   }
000010  bd70              POP      {r4-r6,pc}
;;;1545   RTM_EXPORT(rt_mb_send);
                          ENDP


                          AREA ||i.rt_mb_send_wait||, CODE, READONLY, ALIGN=1

                  rt_mb_send_wait PROC
;;;1409    */
;;;1410   rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
000000  e92d43f7          PUSH     {r0-r2,r4-r9,lr}
;;;1411                            rt_uint32_t  value,
;;;1412                            rt_int32_t   timeout)
;;;1413   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;1414       struct rt_thread *thread;
;;;1415       register rt_ubase_t temp;
;;;1416       rt_uint32_t tick_delta;
;;;1417   
;;;1418       /* parameter check */
;;;1419       RT_ASSERT(mb != RT_NULL);
;;;1420   
;;;1421       /* initialize delta tick */
;;;1422       tick_delta = 0;
000008  2700              MOVS     r7,#0
;;;1423       /* get current thread */
;;;1424       thread = rt_thread_self();
00000a  f7fffffe          BL       rt_thread_self
00000e  4605              MOV      r5,r0
;;;1425   
;;;1426       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
;;;1427   
;;;1428       /* disable interrupt */
;;;1429       temp = rt_hw_interrupt_disable();
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4680              MOV      r8,r0
;;;1430   
;;;1431       /* for non-blocking call */
;;;1432       if (mb->entry == mb->size && timeout == 0)
000016  8c60              LDRH     r0,[r4,#0x22]
000018  8c21              LDRH     r1,[r4,#0x20]
00001a  4288              CMP      r0,r1
00001c  d107              BNE      |L15.46|
00001e  9802              LDR      r0,[sp,#8]
000020  b928              CBNZ     r0,|L15.46|
;;;1433       {
;;;1434           rt_hw_interrupt_enable(temp);
000022  4640              MOV      r0,r8
000024  f7fffffe          BL       rt_hw_interrupt_enable
;;;1435   
;;;1436           return -RT_EFULL;
000028  1ef8              SUBS     r0,r7,#3
                  |L15.42|
;;;1437       }
;;;1438   
;;;1439       /* mailbox is full */
;;;1440       while (mb->entry == mb->size)
;;;1441       {
;;;1442           /* reset error number in thread */
;;;1443           thread->error = RT_EOK;
;;;1444   
;;;1445           /* no waiting, return timeout */
;;;1446           if (timeout == 0)
;;;1447           {
;;;1448               /* enable interrupt */
;;;1449               rt_hw_interrupt_enable(temp);
;;;1450   
;;;1451               return -RT_EFULL;
;;;1452           }
;;;1453   
;;;1454           RT_DEBUG_IN_THREAD_CONTEXT;
;;;1455           /* suspend current thread */
;;;1456           rt_ipc_list_suspend(&(mb->suspend_sender_thread),
;;;1457                               thread,
;;;1458                               mb->parent.parent.flag);
;;;1459   
;;;1460           /* has waiting time, start thread timer */
;;;1461           if (timeout > 0)
;;;1462           {
;;;1463               /* get the start tick of timer */
;;;1464               tick_delta = rt_tick_get();
;;;1465   
;;;1466               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
;;;1467                                           thread->name));
;;;1468   
;;;1469               /* reset the timeout of thread timer and start it */
;;;1470               rt_timer_control(&(thread->thread_timer),
;;;1471                                RT_TIMER_CTRL_SET_TIME,
;;;1472                                &timeout);
;;;1473               rt_timer_start(&(thread->thread_timer));
;;;1474           }
;;;1475   
;;;1476           /* enable interrupt */
;;;1477           rt_hw_interrupt_enable(temp);
;;;1478   
;;;1479           /* re-schedule */
;;;1480           rt_schedule();
;;;1481   
;;;1482           /* resume from suspend state */
;;;1483           if (thread->error != RT_EOK)
;;;1484           {
;;;1485               /* return error */
;;;1486               return thread->error;
;;;1487           }
;;;1488   
;;;1489           /* disable interrupt */
;;;1490           temp = rt_hw_interrupt_disable();
;;;1491   
;;;1492           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1493           if (timeout > 0)
;;;1494           {
;;;1495               tick_delta = rt_tick_get() - tick_delta;
;;;1496               timeout -= tick_delta;
;;;1497               if (timeout < 0)
;;;1498                   timeout = 0;
;;;1499           }
;;;1500       }
;;;1501   
;;;1502       /* set ptr */
;;;1503       mb->msg_pool[mb->in_offset] = value;
;;;1504       /* increase input offset */
;;;1505       ++ mb->in_offset;
;;;1506       if (mb->in_offset >= mb->size)
;;;1507           mb->in_offset = 0;
;;;1508       /* increase message entry */
;;;1509       mb->entry ++;
;;;1510   
;;;1511       /* resume suspended thread */
;;;1512       if (!rt_list_isempty(&mb->parent.suspend_thread))
;;;1513       {
;;;1514           rt_ipc_list_resume(&(mb->parent.suspend_thread));
;;;1515   
;;;1516           /* enable interrupt */
;;;1517           rt_hw_interrupt_enable(temp);
;;;1518   
;;;1519           rt_schedule();
;;;1520   
;;;1521           return RT_EOK;
;;;1522       }
;;;1523   
;;;1524       /* enable interrupt */
;;;1525       rt_hw_interrupt_enable(temp);
;;;1526   
;;;1527       return RT_EOK;
;;;1528   }
00002a  e8bd83fe          POP      {r1-r9,pc}
                  |L15.46|
00002e  e039              B        |L15.164|
                  |L15.48|
000030  2000              MOVS     r0,#0                 ;1443
000032  6328              STR      r0,[r5,#0x30]         ;1443
000034  9802              LDR      r0,[sp,#8]            ;1446
000036  b928              CBNZ     r0,|L15.68|
000038  4640              MOV      r0,r8                 ;1449
00003a  f7fffffe          BL       rt_hw_interrupt_enable
00003e  f06f0002          MVN      r0,#2                 ;1451
000042  e7f2              B        |L15.42|
                  |L15.68|
000044  7a62              LDRB     r2,[r4,#9]            ;1456
000046  4629              MOV      r1,r5                 ;1456
000048  f1040028          ADD      r0,r4,#0x28           ;1456
00004c  f7fffffe          BL       rt_ipc_list_suspend
000050  9802              LDR      r0,[sp,#8]            ;1461
000052  2800              CMP      r0,#0                 ;1461
000054  dd0c              BLE      |L15.112|
000056  f7fffffe          BL       rt_tick_get
00005a  4607              MOV      r7,r0                 ;1464
00005c  aa02              ADD      r2,sp,#8              ;1470
00005e  2100              MOVS     r1,#0                 ;1470
000060  f1050044          ADD      r0,r5,#0x44           ;1470
000064  f7fffffe          BL       rt_timer_control
000068  f1050044          ADD      r0,r5,#0x44           ;1473
00006c  f7fffffe          BL       rt_timer_start
                  |L15.112|
000070  4640              MOV      r0,r8                 ;1477
000072  f7fffffe          BL       rt_hw_interrupt_enable
000076  f7fffffe          BL       rt_schedule
00007a  6b28              LDR      r0,[r5,#0x30]         ;1483
00007c  b108              CBZ      r0,|L15.130|
00007e  6b28              LDR      r0,[r5,#0x30]         ;1486
000080  e7d3              B        |L15.42|
                  |L15.130|
000082  f7fffffe          BL       rt_hw_interrupt_disable
000086  4680              MOV      r8,r0                 ;1490
000088  9802              LDR      r0,[sp,#8]            ;1493
00008a  2800              CMP      r0,#0                 ;1493
00008c  dd0a              BLE      |L15.164|
00008e  f7fffffe          BL       rt_tick_get
000092  1bc7              SUBS     r7,r0,r7              ;1495
000094  9802              LDR      r0,[sp,#8]            ;1496
000096  1bc0              SUBS     r0,r0,r7              ;1496
000098  9002              STR      r0,[sp,#8]            ;1496
00009a  9802              LDR      r0,[sp,#8]            ;1497
00009c  2800              CMP      r0,#0                 ;1497
00009e  da01              BGE      |L15.164|
0000a0  2000              MOVS     r0,#0                 ;1498
0000a2  9002              STR      r0,[sp,#8]            ;1498
                  |L15.164|
0000a4  8c60              LDRH     r0,[r4,#0x22]         ;1440
0000a6  8c21              LDRH     r1,[r4,#0x20]         ;1440
0000a8  4288              CMP      r0,r1                 ;1440
0000aa  d0c1              BEQ      |L15.48|
0000ac  8ca1              LDRH     r1,[r4,#0x24]         ;1503
0000ae  69e0              LDR      r0,[r4,#0x1c]         ;1503
0000b0  f8406021          STR      r6,[r0,r1,LSL #2]     ;1503
0000b4  8ca0              LDRH     r0,[r4,#0x24]         ;1505
0000b6  1c40              ADDS     r0,r0,#1              ;1505
0000b8  84a0              STRH     r0,[r4,#0x24]         ;1505
0000ba  8ca0              LDRH     r0,[r4,#0x24]         ;1506
0000bc  8c21              LDRH     r1,[r4,#0x20]         ;1506
0000be  4288              CMP      r0,r1                 ;1506
0000c0  db01              BLT      |L15.198|
0000c2  2000              MOVS     r0,#0                 ;1507
0000c4  84a0              STRH     r0,[r4,#0x24]         ;1507
                  |L15.198|
0000c6  8c60              LDRH     r0,[r4,#0x22]         ;1509
0000c8  1c40              ADDS     r0,r0,#1              ;1509
0000ca  8460              STRH     r0,[r4,#0x22]         ;1509
0000cc  f1040014          ADD      r0,r4,#0x14           ;1512
0000d0  f7fffffe          BL       rt_list_isempty
0000d4  b950              CBNZ     r0,|L15.236|
0000d6  f1040014          ADD      r0,r4,#0x14           ;1514
0000da  f7fffffe          BL       rt_ipc_list_resume
0000de  4640              MOV      r0,r8                 ;1517
0000e0  f7fffffe          BL       rt_hw_interrupt_enable
0000e4  f7fffffe          BL       rt_schedule
0000e8  2000              MOVS     r0,#0                 ;1521
0000ea  e79e              B        |L15.42|
                  |L15.236|
0000ec  4640              MOV      r0,r8                 ;1525
0000ee  f7fffffe          BL       rt_hw_interrupt_enable
0000f2  2000              MOVS     r0,#0                 ;1527
0000f4  e799              B        |L15.42|
;;;1529   RTM_EXPORT(rt_mb_send_wait);
                          ENDP


                          AREA ||i.rt_sem_control||, CODE, READONLY, ALIGN=1

                  rt_sem_control PROC
;;;480     */
;;;481    rt_err_t rt_sem_control(rt_sem_t sem, int cmd, void *arg)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;482    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;483        rt_ubase_t level;
;;;484        RT_ASSERT(sem != RT_NULL);
;;;485    
;;;486        if (cmd == RT_IPC_CMD_RESET)
00000a  2e01              CMP      r6,#1
00000c  d110              BNE      |L16.48|
;;;487        {
;;;488            rt_uint32_t value;
;;;489    
;;;490            /* get value */
;;;491            value = (rt_uint32_t)arg;
00000e  462f              MOV      r7,r5
;;;492            /* disable interrupt */
;;;493            level = rt_hw_interrupt_disable();
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4680              MOV      r8,r0
;;;494    
;;;495            /* resume all waiting thread */
;;;496            rt_ipc_list_resume_all(&sem->parent.suspend_thread);
000016  f1040014          ADD      r0,r4,#0x14
00001a  f7fffffe          BL       rt_ipc_list_resume_all
;;;497    
;;;498            /* set new value */
;;;499            sem->value = (rt_uint16_t)value;
00001e  83a7              STRH     r7,[r4,#0x1c]
;;;500    
;;;501            /* enable interrupt */
;;;502            rt_hw_interrupt_enable(level);
000020  4640              MOV      r0,r8
000022  f7fffffe          BL       rt_hw_interrupt_enable
;;;503    
;;;504            rt_schedule();
000026  f7fffffe          BL       rt_schedule
;;;505    
;;;506            return RT_EOK;
00002a  2000              MOVS     r0,#0
                  |L16.44|
;;;507        }
;;;508    
;;;509        return -RT_ERROR;
;;;510    }
00002c  e8bd81f0          POP      {r4-r8,pc}
                  |L16.48|
000030  f04f30ff          MOV      r0,#0xffffffff        ;509
000034  e7fa              B        |L16.44|
;;;511    RTM_EXPORT(rt_sem_control);
                          ENDP


                          AREA ||i.rt_sem_create||, CODE, READONLY, ALIGN=1

                  rt_sem_create PROC
;;;268     */
;;;269    rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;270    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;271        rt_sem_t sem;
;;;272    
;;;273        RT_DEBUG_NOT_IN_INTERRUPT;
;;;274    
;;;275        /* allocate object */
;;;276        sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
00000a  4629              MOV      r1,r5
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       rt_object_allocate
000012  4604              MOV      r4,r0
;;;277        if (sem == RT_NULL)
000014  b914              CBNZ     r4,|L17.28|
;;;278            return sem;
000016  4620              MOV      r0,r4
                  |L17.24|
;;;279    
;;;280        /* init ipc object */
;;;281        rt_ipc_object_init(&(sem->parent));
;;;282    
;;;283        /* set init value */
;;;284        sem->value = value;
;;;285    
;;;286        /* set parent */
;;;287        sem->parent.parent.flag = flag;
;;;288    
;;;289        return sem;
;;;290    }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L17.28|
00001c  4620              MOV      r0,r4                 ;281
00001e  f7fffffe          BL       rt_ipc_object_init
000022  83a6              STRH     r6,[r4,#0x1c]         ;284
000024  7267              STRB     r7,[r4,#9]            ;287
000026  4620              MOV      r0,r4                 ;289
000028  e7f6              B        |L17.24|
;;;291    RTM_EXPORT(rt_sem_create);
                          ENDP


                          AREA ||i.rt_sem_delete||, CODE, READONLY, ALIGN=1

                  rt_sem_delete PROC
;;;301     */
;;;302    rt_err_t rt_sem_delete(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304        RT_DEBUG_NOT_IN_INTERRUPT;
;;;305    
;;;306        RT_ASSERT(sem != RT_NULL);
;;;307    
;;;308        /* wakeup all suspend threads */
;;;309        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
000004  f1040014          ADD      r0,r4,#0x14
000008  f7fffffe          BL       rt_ipc_list_resume_all
;;;310    
;;;311        /* delete semaphore object */
;;;312        rt_object_delete(&(sem->parent.parent));
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       rt_object_delete
;;;313    
;;;314        return RT_EOK;
000012  2000              MOVS     r0,#0
;;;315    }
000014  bd10              POP      {r4,pc}
;;;316    RTM_EXPORT(rt_sem_delete);
                          ENDP


                          AREA ||i.rt_sem_detach||, CODE, READONLY, ALIGN=1

                  rt_sem_detach PROC
;;;242     */
;;;243    rt_err_t rt_sem_detach(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245        RT_ASSERT(sem != RT_NULL);
;;;246    
;;;247        /* wakeup all suspend threads */
;;;248        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
000004  f1040014          ADD      r0,r4,#0x14
000008  f7fffffe          BL       rt_ipc_list_resume_all
;;;249    
;;;250        /* detach semaphore object */
;;;251        rt_object_detach(&(sem->parent.parent));
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       rt_object_detach
;;;252    
;;;253        return RT_EOK;
000012  2000              MOVS     r0,#0
;;;254    }
000014  bd10              POP      {r4,pc}
;;;255    RTM_EXPORT(rt_sem_detach);
                          ENDP


                          AREA ||i.rt_sem_init||, CODE, READONLY, ALIGN=1

                  rt_sem_init PROC
;;;210     */
;;;211    rt_err_t rt_sem_init(rt_sem_t    sem,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;212                         const char *name,
;;;213                         rt_uint32_t value,
;;;214                         rt_uint8_t  flag)
;;;215    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;216        RT_ASSERT(sem != RT_NULL);
;;;217    
;;;218        /* init object */
;;;219        rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
00000c  462a              MOV      r2,r5
00000e  2101              MOVS     r1,#1
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_object_init
;;;220    
;;;221        /* init ipc object */
;;;222        rt_ipc_object_init(&(sem->parent));
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       rt_ipc_object_init
;;;223    
;;;224        /* set init value */
;;;225        sem->value = value;
00001c  83a6              STRH     r6,[r4,#0x1c]
;;;226    
;;;227        /* set parent */
;;;228        sem->parent.parent.flag = flag;
00001e  7267              STRB     r7,[r4,#9]
;;;229    
;;;230        return RT_EOK;
000020  2000              MOVS     r0,#0
;;;231    }
000022  e8bd81f0          POP      {r4-r8,pc}
;;;232    RTM_EXPORT(rt_sem_init);
                          ENDP


                          AREA ||i.rt_sem_release||, CODE, READONLY, ALIGN=1

                  rt_sem_release PROC
;;;434     */
;;;435    rt_err_t rt_sem_release(rt_sem_t sem)
000000  b570              PUSH     {r4-r6,lr}
;;;436    {
000002  4604              MOV      r4,r0
;;;437        register rt_base_t temp;
;;;438        register rt_bool_t need_schedule;
;;;439    
;;;440        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
;;;441    
;;;442        need_schedule = RT_FALSE;
000004  2500              MOVS     r5,#0
;;;443    
;;;444        /* disable interrupt */
;;;445        temp = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
;;;446    
;;;447        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
;;;448                                    rt_thread_self()->name,
;;;449                                    ((struct rt_object *)sem)->name,
;;;450                                    sem->value));
;;;451    
;;;452        if (!rt_list_isempty(&sem->parent.suspend_thread))
00000c  f1040014          ADD      r0,r4,#0x14
000010  f7fffffe          BL       rt_list_isempty
000014  b928              CBNZ     r0,|L21.34|
;;;453        {
;;;454            /* resume the suspended thread */
;;;455            rt_ipc_list_resume(&(sem->parent.suspend_thread));
000016  f1040014          ADD      r0,r4,#0x14
00001a  f7fffffe          BL       rt_ipc_list_resume
;;;456            need_schedule = RT_TRUE;
00001e  2501              MOVS     r5,#1
000020  e002              B        |L21.40|
                  |L21.34|
;;;457        }
;;;458        else
;;;459            sem->value ++; /* increase value */
000022  8ba0              LDRH     r0,[r4,#0x1c]
000024  1c40              ADDS     r0,r0,#1
000026  83a0              STRH     r0,[r4,#0x1c]
                  |L21.40|
;;;460    
;;;461        /* enable interrupt */
;;;462        rt_hw_interrupt_enable(temp);
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       rt_hw_interrupt_enable
;;;463    
;;;464        /* resume a thread, re-schedule */
;;;465        if (need_schedule == RT_TRUE)
00002e  2d01              CMP      r5,#1
000030  d101              BNE      |L21.54|
;;;466            rt_schedule();
000032  f7fffffe          BL       rt_schedule
                  |L21.54|
;;;467    
;;;468        return RT_EOK;
000036  2000              MOVS     r0,#0
;;;469    }
000038  bd70              POP      {r4-r6,pc}
;;;470    RTM_EXPORT(rt_sem_release);
                          ENDP


                          AREA ||i.rt_sem_take||, CODE, READONLY, ALIGN=1

                  rt_sem_take PROC
;;;327     */
;;;328    rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;329    {
000002  4605              MOV      r5,r0
;;;330        register rt_base_t temp;
;;;331        struct rt_thread *thread;
;;;332    
;;;333        RT_ASSERT(sem != RT_NULL);
;;;334    
;;;335        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
;;;336    
;;;337        /* disable interrupt */
;;;338        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
;;;339    
;;;340        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
;;;341                                    rt_thread_self()->name,
;;;342                                    ((struct rt_object *)sem)->name,
;;;343                                    sem->value));
;;;344    
;;;345        if (sem->value > 0)
00000a  8ba8              LDRH     r0,[r5,#0x1c]
00000c  2800              CMP      r0,#0
00000e  dd06              BLE      |L22.30|
;;;346        {
;;;347            /* semaphore is available */
;;;348            sem->value --;
000010  8ba8              LDRH     r0,[r5,#0x1c]
000012  1e40              SUBS     r0,r0,#1
000014  83a8              STRH     r0,[r5,#0x1c]
;;;349    
;;;350            /* enable interrupt */
;;;351            rt_hw_interrupt_enable(temp);
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       rt_hw_interrupt_enable
00001c  e028              B        |L22.112|
                  |L22.30|
;;;352        }
;;;353        else
;;;354        {
;;;355            /* no waiting, return with timeout */
;;;356            if (time == 0)
00001e  9801              LDR      r0,[sp,#4]
000020  b928              CBNZ     r0,|L22.46|
;;;357            {
;;;358                rt_hw_interrupt_enable(temp);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       rt_hw_interrupt_enable
;;;359    
;;;360                return -RT_ETIMEOUT;
000028  f06f0001          MVN      r0,#1
                  |L22.44|
;;;361            }
;;;362            else
;;;363            {
;;;364                /* current context checking */
;;;365                RT_DEBUG_IN_THREAD_CONTEXT;
;;;366    
;;;367                /* semaphore is unavailable, push to suspend list */
;;;368                /* get current thread */
;;;369                thread = rt_thread_self();
;;;370    
;;;371                /* reset thread error number */
;;;372                thread->error = RT_EOK;
;;;373    
;;;374                RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
;;;375                                            thread->name));
;;;376    
;;;377                /* suspend thread */
;;;378                rt_ipc_list_suspend(&(sem->parent.suspend_thread),
;;;379                                    thread,
;;;380                                    sem->parent.parent.flag);
;;;381    
;;;382                /* has waiting time, start thread timer */
;;;383                if (time > 0)
;;;384                {
;;;385                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;386                                                thread->name));
;;;387    
;;;388                    /* reset the timeout of thread timer and start it */
;;;389                    rt_timer_control(&(thread->thread_timer),
;;;390                                     RT_TIMER_CTRL_SET_TIME,
;;;391                                     &time);
;;;392                    rt_timer_start(&(thread->thread_timer));
;;;393                }
;;;394    
;;;395                /* enable interrupt */
;;;396                rt_hw_interrupt_enable(temp);
;;;397    
;;;398                /* do schedule */
;;;399                rt_schedule();
;;;400    
;;;401                if (thread->error != RT_EOK)
;;;402                {
;;;403                    return thread->error;
;;;404                }
;;;405            }
;;;406        }
;;;407    
;;;408        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
;;;409    
;;;410        return RT_EOK;
;;;411    }
00002c  bd7c              POP      {r2-r6,pc}
                  |L22.46|
00002e  f7fffffe          BL       rt_thread_self
000032  4604              MOV      r4,r0                 ;369
000034  2000              MOVS     r0,#0                 ;372
000036  6320              STR      r0,[r4,#0x30]         ;372
000038  7a6a              LDRB     r2,[r5,#9]            ;378
00003a  4621              MOV      r1,r4                 ;378
00003c  f1050014          ADD      r0,r5,#0x14           ;378
000040  f7fffffe          BL       rt_ipc_list_suspend
000044  9801              LDR      r0,[sp,#4]            ;383
000046  2800              CMP      r0,#0                 ;383
000048  dd09              BLE      |L22.94|
00004a  aa01              ADD      r2,sp,#4              ;389
00004c  2100              MOVS     r1,#0                 ;389
00004e  f1040044          ADD      r0,r4,#0x44           ;389
000052  f7fffffe          BL       rt_timer_control
000056  f1040044          ADD      r0,r4,#0x44           ;392
00005a  f7fffffe          BL       rt_timer_start
                  |L22.94|
00005e  4630              MOV      r0,r6                 ;396
000060  f7fffffe          BL       rt_hw_interrupt_enable
000064  f7fffffe          BL       rt_schedule
000068  6b20              LDR      r0,[r4,#0x30]         ;401
00006a  b108              CBZ      r0,|L22.112|
00006c  6b20              LDR      r0,[r4,#0x30]         ;403
00006e  e7dd              B        |L22.44|
                  |L22.112|
000070  2000              MOVS     r0,#0                 ;410
000072  e7db              B        |L22.44|
;;;412    RTM_EXPORT(rt_sem_take);
                          ENDP


                          AREA ||i.rt_sem_trytake||, CODE, READONLY, ALIGN=1

                  rt_sem_trytake PROC
;;;420     */
;;;421    rt_err_t rt_sem_trytake(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;422    {
000002  4604              MOV      r4,r0
;;;423        return rt_sem_take(sem, 0);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       rt_sem_take
;;;424    }
00000c  bd10              POP      {r4,pc}
;;;425    RTM_EXPORT(rt_sem_trytake);
                          ENDP


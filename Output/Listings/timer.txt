; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\timer.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\timer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\timer.crf ..\rtthread\src\timer.c]
                          THUMB

                          AREA ||i._rt_timer_init||, CODE, READONLY, ALIGN=1

                  _rt_timer_init PROC
;;;81     
;;;82     static void _rt_timer_init(rt_timer_t timer,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;83                                void (*timeout)(void *parameter),
;;;84                                void      *parameter,
;;;85                                rt_tick_t  time,
;;;86                                rt_uint8_t flag)
;;;87     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;88         int i;
;;;89     
;;;90         /* set flag */
;;;91         timer->parent.flag  = flag;
000010  f8849009          STRB     r9,[r4,#9]
;;;92     
;;;93         /* set deactivated */
;;;94         timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000014  7a60              LDRB     r0,[r4,#9]
000016  f0200001          BIC      r0,r0,#1
00001a  7260              STRB     r0,[r4,#9]
;;;95     
;;;96         timer->timeout_func = timeout;
00001c  61e6              STR      r6,[r4,#0x1c]
;;;97         timer->parameter    = parameter;
00001e  6227              STR      r7,[r4,#0x20]
;;;98     
;;;99         timer->timeout_tick = 0;
000020  2000              MOVS     r0,#0
000022  62a0              STR      r0,[r4,#0x28]
;;;100        timer->init_tick    = time;
000024  f8c48024          STR      r8,[r4,#0x24]
;;;101    
;;;102        /* initialize timer list */
;;;103        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
000028  2500              MOVS     r5,#0
00002a  e006              B        |L1.58|
                  |L1.44|
;;;104        {
;;;105            rt_list_init(&(timer->row[i]));
00002c  f1040114          ADD      r1,r4,#0x14
000030  eb0100c5          ADD      r0,r1,r5,LSL #3
000034  f7fffffe          BL       rt_list_init
000038  1c6d              ADDS     r5,r5,#1              ;103
                  |L1.58|
00003a  2d01              CMP      r5,#1                 ;103
00003c  dbf6              BLT      |L1.44|
;;;106        }
;;;107    }
00003e  e8bd87f0          POP      {r4-r10,pc}
;;;108    
                          ENDP


                          AREA ||i._rt_timer_remove||, CODE, READONLY, ALIGN=1

                  _rt_timer_remove PROC
;;;122    
;;;123    rt_inline void _rt_timer_remove(rt_timer_t timer)
000000  b510              PUSH     {r4,lr}
;;;124    {
000002  4602              MOV      r2,r0
;;;125        int i;
;;;126    
;;;127        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
000004  2000              MOVS     r0,#0
000006  4601              MOV      r1,r0
000008  e00e              B        |L2.40|
                  |L2.10|
;;;128        {
;;;129            rt_list_remove(&timer->row[i]);
00000a  f1020314          ADD      r3,r2,#0x14
00000e  eb0300c1          ADD      r0,r3,r1,LSL #3
000012  e9d04300          LDRD     r4,r3,[r0,#0]
000016  6063              STR      r3,[r4,#4]
000018  e9d03400          LDRD     r3,r4,[r0,#0]
00001c  6023              STR      r3,[r4,#0]
00001e  6040              STR      r0,[r0,#4]
000020  6000              STR      r0,[r0,#0]
000022  bf00              NOP      
000024  1c48              ADDS     r0,r1,#1              ;127
000026  4601              MOV      r1,r0                 ;127
                  |L2.40|
000028  2901              CMP      r1,#1                 ;127
00002a  dbee              BLT      |L2.10|
;;;130        }
;;;131    }
00002c  bd10              POP      {r4,pc}
;;;132    
                          ENDP


                          AREA ||i.rt_list_init||, CODE, READONLY, ALIGN=1

                  rt_list_init PROC
;;;60      */
;;;61     rt_inline void rt_list_init(rt_list_t *l)
000000  6040              STR      r0,[r0,#4]
;;;62     {
;;;63         l->next = l->prev = l;
000002  6000              STR      r0,[r0,#0]
;;;64     }
000004  4770              BX       lr
;;;65     
                          ENDP


                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;71      */
;;;72     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;73     {
;;;74         l->next->prev = n;
000002  6051              STR      r1,[r2,#4]
;;;75         n->next = l->next;
000004  6802              LDR      r2,[r0,#0]
000006  600a              STR      r2,[r1,#0]
;;;76     
;;;77         l->next = n;
000008  6001              STR      r1,[r0,#0]
;;;78         n->prev = l;
00000a  6048              STR      r0,[r1,#4]
;;;79     }
00000c  4770              BX       lr
;;;80     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;111     */
;;;112    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  4601              MOV      r1,r0
;;;113    {
;;;114        return l->next == l;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d101              BNE      |L5.12|
000008  2001              MOVS     r0,#1
                  |L5.10|
;;;115    }
00000a  4770              BX       lr
                  |L5.12|
00000c  2000              MOVS     r0,#0                 ;114
00000e  e7fc              B        |L5.10|
;;;116    
                          ENDP


                          AREA ||i.rt_system_timer_init||, CODE, READONLY, ALIGN=2

                  rt_system_timer_init PROC
;;;670     */
;;;671    void rt_system_timer_init(void)
000000  b510              PUSH     {r4,lr}
;;;672    {
;;;673        int i;
;;;674    
;;;675        for (i = 0; i < sizeof(rt_timer_list) / sizeof(rt_timer_list[0]); i++)
000002  2400              MOVS     r4,#0
000004  e005              B        |L6.18|
                  |L6.6|
;;;676        {
;;;677            rt_list_init(rt_timer_list + i);
000006  4904              LDR      r1,|L6.24|
000008  eb0100c4          ADD      r0,r1,r4,LSL #3
00000c  f7fffffe          BL       rt_list_init
000010  1c64              ADDS     r4,r4,#1              ;675
                  |L6.18|
000012  2c00              CMP      r4,#0                 ;675
000014  d0f7              BEQ      |L6.6|
;;;678        }
;;;679    }
000016  bd10              POP      {r4,pc}
;;;680    
                          ENDP

                  |L6.24|
                          DCD      rt_timer_list

                          AREA ||i.rt_system_timer_thread_init||, CODE, READONLY, ALIGN=1

                  rt_system_timer_thread_init PROC
;;;685     */
;;;686    void rt_system_timer_thread_init(void)
000000  4770              BX       lr
;;;687    {
;;;688    #ifdef RT_USING_TIMER_SOFT
;;;689        int i;
;;;690    
;;;691        for (i = 0;
;;;692             i < sizeof(rt_soft_timer_list) / sizeof(rt_soft_timer_list[0]);
;;;693             i++)
;;;694        {
;;;695            rt_list_init(rt_soft_timer_list + i);
;;;696        }
;;;697    
;;;698        /* start software timer thread */
;;;699        rt_thread_init(&timer_thread,
;;;700                       "timer",
;;;701                       rt_thread_timer_entry,
;;;702                       RT_NULL,
;;;703                       &timer_thread_stack[0],
;;;704                       sizeof(timer_thread_stack),
;;;705                       RT_TIMER_THREAD_PRIO,
;;;706                       10);
;;;707    
;;;708        /* startup */
;;;709        rt_thread_startup(&timer_thread);
;;;710    #endif
;;;711    }
;;;712    
                          ENDP


                          AREA ||i.rt_timer_check||, CODE, READONLY, ALIGN=2

                  rt_timer_check PROC
;;;487     */
;;;488    void rt_timer_check(void)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
;;;490        struct rt_timer *t;
;;;491        rt_tick_t current_tick;
;;;492        register rt_base_t level;
;;;493    
;;;494        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));
;;;495    
;;;496        current_tick = rt_tick_get();
000002  f7fffffe          BL       rt_tick_get
000006  4605              MOV      r5,r0
;;;497    
;;;498        /* disable interrupt */
;;;499        level = rt_hw_interrupt_disable();
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4606              MOV      r6,r0
;;;500    
;;;501        while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
00000e  e028              B        |L8.98|
                  |L8.16|
;;;502        {
;;;503            t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
000010  4819              LDR      r0,|L8.120|
000012  6800              LDR      r0,[r0,#0]  ; rt_timer_list
000014  f1a00414          SUB      r4,r0,#0x14
;;;504                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
;;;505    
;;;506            /*
;;;507             * It supposes that the new tick shall less than the half duration of
;;;508             * tick max.
;;;509             */
;;;510            if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
000018  6aa0              LDR      r0,[r4,#0x28]
00001a  1a28              SUBS     r0,r5,r0
00001c  f06f4100          MVN      r1,#0x80000000
000020  4288              CMP      r0,r1
000022  d21d              BCS      |L8.96|
;;;511            {
;;;512                RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
;;;513    
;;;514                /* remove timer from timer list firstly */
;;;515                _rt_timer_remove(t);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       _rt_timer_remove
;;;516    
;;;517                /* call timeout function */
;;;518                t->timeout_func(t->parameter);
00002a  e9d41007          LDRD     r1,r0,[r4,#0x1c]
00002e  4788              BLX      r1
;;;519    
;;;520                /* re-get tick */
;;;521                current_tick = rt_tick_get();
000030  f7fffffe          BL       rt_tick_get
000034  4605              MOV      r5,r0
;;;522    
;;;523                RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
;;;524    
;;;525                if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
000036  7a60              LDRB     r0,[r4,#9]
000038  f0000002          AND      r0,r0,#2
00003c  b158              CBZ      r0,|L8.86|
;;;526                    (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
00003e  7a60              LDRB     r0,[r4,#9]
000040  f0000001          AND      r0,r0,#1
000044  b138              CBZ      r0,|L8.86|
;;;527                {
;;;528                    /* start it */
;;;529                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000046  7a60              LDRB     r0,[r4,#9]
000048  f0200001          BIC      r0,r0,#1
00004c  7260              STRB     r0,[r4,#9]
;;;530                    rt_timer_start(t);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       rt_timer_start
000054  e005              B        |L8.98|
                  |L8.86|
;;;531                }
;;;532                else
;;;533                {
;;;534                    /* stop timer */
;;;535                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000056  7a60              LDRB     r0,[r4,#9]
000058  f0200001          BIC      r0,r0,#1
00005c  7260              STRB     r0,[r4,#9]
00005e  e000              B        |L8.98|
                  |L8.96|
;;;536                }
;;;537            }
;;;538            else
;;;539                break;
000060  e004              B        |L8.108|
                  |L8.98|
000062  4805              LDR      r0,|L8.120|
000064  f7fffffe          BL       rt_list_isempty
000068  2800              CMP      r0,#0                 ;501
00006a  d0d1              BEQ      |L8.16|
                  |L8.108|
00006c  bf00              NOP      
;;;540        }
;;;541    
;;;542        /* enable interrupt */
;;;543        rt_hw_interrupt_enable(level);
00006e  4630              MOV      r0,r6
000070  f7fffffe          BL       rt_hw_interrupt_enable
;;;544    
;;;545        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
;;;546    }
000074  bd70              POP      {r4-r6,pc}
;;;547    
                          ENDP

000076  0000              DCW      0x0000
                  |L8.120|
                          DCD      rt_timer_list

                          AREA ||i.rt_timer_control||, CODE, READONLY, ALIGN=1

                  rt_timer_control PROC
;;;453     */
;;;454    rt_err_t rt_timer_control(rt_timer_t timer, int cmd, void *arg)
000000  4603              MOV      r3,r0
;;;455    {
;;;456        /* timer check */
;;;457        RT_ASSERT(timer != RT_NULL);
;;;458    
;;;459        switch (cmd)
000002  b149              CBZ      r1,|L9.24|
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L9.18|
000008  2902              CMP      r1,#2
00000a  d008              BEQ      |L9.30|
00000c  2903              CMP      r1,#3
00000e  d110              BNE      |L9.50|
000010  e00a              B        |L9.40|
                  |L9.18|
;;;460        {
;;;461        case RT_TIMER_CTRL_GET_TIME:
;;;462            *(rt_tick_t *)arg = timer->init_tick;
000012  6a58              LDR      r0,[r3,#0x24]
000014  6010              STR      r0,[r2,#0]
;;;463            break;
000016  e00c              B        |L9.50|
                  |L9.24|
;;;464    
;;;465        case RT_TIMER_CTRL_SET_TIME:
;;;466            timer->init_tick = *(rt_tick_t *)arg;
000018  6810              LDR      r0,[r2,#0]
00001a  6258              STR      r0,[r3,#0x24]
;;;467            break;
00001c  e009              B        |L9.50|
                  |L9.30|
;;;468    
;;;469        case RT_TIMER_CTRL_SET_ONESHOT:
;;;470            timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
00001e  7a58              LDRB     r0,[r3,#9]
000020  f0200002          BIC      r0,r0,#2
000024  7258              STRB     r0,[r3,#9]
;;;471            break;
000026  e004              B        |L9.50|
                  |L9.40|
;;;472    
;;;473        case RT_TIMER_CTRL_SET_PERIODIC:
;;;474            timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
000028  7a58              LDRB     r0,[r3,#9]
00002a  f0400002          ORR      r0,r0,#2
00002e  7258              STRB     r0,[r3,#9]
;;;475            break;
000030  bf00              NOP      
                  |L9.50|
000032  bf00              NOP                            ;463
;;;476        }
;;;477    
;;;478        return RT_EOK;
000034  2000              MOVS     r0,#0
;;;479    }
000036  4770              BX       lr
;;;480    RTM_EXPORT(rt_timer_control);
                          ENDP


                          AREA ||i.rt_timer_create||, CODE, READONLY, ALIGN=1

                  rt_timer_create PROC
;;;236     */
;;;237    rt_timer_t rt_timer_create(const char *name,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;238                               void (*timeout)(void *parameter),
;;;239                               void       *parameter,
;;;240                               rt_tick_t   time,
;;;241                               rt_uint8_t  flag)
;;;242    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  4698              MOV      r8,r3
00000c  f8dd9020          LDR      r9,[sp,#0x20]
;;;243        struct rt_timer *timer;
;;;244    
;;;245        /* allocate a object */
;;;246        timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
000010  4621              MOV      r1,r4
000012  2009              MOVS     r0,#9
000014  f7fffffe          BL       rt_object_allocate
000018  4605              MOV      r5,r0
;;;247        if (timer == RT_NULL)
00001a  b915              CBNZ     r5,|L10.34|
;;;248        {
;;;249            return RT_NULL;
00001c  2000              MOVS     r0,#0
                  |L10.30|
;;;250        }
;;;251    
;;;252        _rt_timer_init(timer, timeout, parameter, time, flag);
;;;253    
;;;254        return timer;
;;;255    }
00001e  e8bd83f8          POP      {r3-r9,pc}
                  |L10.34|
000022  4643              MOV      r3,r8                 ;252
000024  463a              MOV      r2,r7                 ;252
000026  4631              MOV      r1,r6                 ;252
000028  4628              MOV      r0,r5                 ;252
00002a  f8cd9000          STR      r9,[sp,#0]            ;252
00002e  f7fffffe          BL       _rt_timer_init
000032  4628              MOV      r0,r5                 ;254
000034  e7f3              B        |L10.30|
;;;256    RTM_EXPORT(rt_timer_create);
                          ENDP


                          AREA ||i.rt_timer_delete||, CODE, READONLY, ALIGN=1

                  rt_timer_delete PROC
;;;264     */
;;;265    rt_err_t rt_timer_delete(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
000002  4604              MOV      r4,r0
;;;267        register rt_base_t level;
;;;268    
;;;269        /* timer check */
;;;270        RT_ASSERT(timer != RT_NULL);
;;;271    
;;;272        /* disable interrupt */
;;;273        level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;274    
;;;275        _rt_timer_remove(timer);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       _rt_timer_remove
;;;276    
;;;277        /* enable interrupt */
;;;278        rt_hw_interrupt_enable(level);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       rt_hw_interrupt_enable
;;;279    
;;;280        rt_object_delete((rt_object_t)timer);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       rt_object_delete
;;;281    
;;;282        return -RT_EOK;
00001c  2000              MOVS     r0,#0
;;;283    }
00001e  bd70              POP      {r4-r6,pc}
;;;284    RTM_EXPORT(rt_timer_delete);
                          ENDP


                          AREA ||i.rt_timer_detach||, CODE, READONLY, ALIGN=1

                  rt_timer_detach PROC
;;;203     */
;;;204    rt_err_t rt_timer_detach(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  4604              MOV      r4,r0
;;;206        register rt_base_t level;
;;;207    
;;;208        /* timer check */
;;;209        RT_ASSERT(timer != RT_NULL);
;;;210    
;;;211        /* disable interrupt */
;;;212        level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;213    
;;;214        _rt_timer_remove(timer);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       _rt_timer_remove
;;;215    
;;;216        /* enable interrupt */
;;;217        rt_hw_interrupt_enable(level);
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       rt_hw_interrupt_enable
;;;218    
;;;219        rt_object_detach((rt_object_t)timer);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       rt_object_detach
;;;220    
;;;221        return -RT_EOK;
00001c  2000              MOVS     r0,#0
;;;222    }
00001e  bd70              POP      {r4-r6,pc}
;;;223    RTM_EXPORT(rt_timer_detach);
                          ENDP


                          AREA ||i.rt_timer_init||, CODE, READONLY, ALIGN=1

                  rt_timer_init PROC
;;;179     */
;;;180    void rt_timer_init(rt_timer_t  timer,
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;181                       const char *name,
;;;182                       void (*timeout)(void *parameter),
;;;183                       void       *parameter,
;;;184                       rt_tick_t   time,
;;;185                       rt_uint8_t  flag)
;;;186    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
00000c  e9dd8908          LDRD     r8,r9,[sp,#0x20]
;;;187        /* timer check */
;;;188        RT_ASSERT(timer != RT_NULL);
;;;189    
;;;190        /* timer object initialization */
;;;191        rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
000010  4622              MOV      r2,r4
000012  2109              MOVS     r1,#9
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       rt_object_init
;;;192    
;;;193        _rt_timer_init(timer, timeout, parameter, time, flag);
00001a  4643              MOV      r3,r8
00001c  4632              MOV      r2,r6
00001e  4629              MOV      r1,r5
000020  4638              MOV      r0,r7
000022  f8cd9000          STR      r9,[sp,#0]
000026  f7fffffe          BL       _rt_timer_init
;;;194    }
00002a  e8bd83f8          POP      {r3-r9,pc}
;;;195    RTM_EXPORT(rt_timer_init);
                          ENDP


                          AREA ||i.rt_timer_list_next_timeout||, CODE, READONLY, ALIGN=1

                  rt_timer_list_next_timeout PROC
;;;109    /* the fist timer always in the last row */
;;;110    static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  4604              MOV      r4,r0
;;;112        struct rt_timer *timer;
;;;113    
;;;114        if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_list_isempty
00000a  b110              CBZ      r0,|L14.18|
;;;115            return RT_TICK_MAX;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L14.16|
;;;116    
;;;117        timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
;;;118                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
;;;119    
;;;120        return timer->timeout_tick;
;;;121    }
000010  bd70              POP      {r4-r6,pc}
                  |L14.18|
000012  6820              LDR      r0,[r4,#0]            ;117
000014  f1a00514          SUB      r5,r0,#0x14           ;117
000018  6aa8              LDR      r0,[r5,#0x28]         ;120
00001a  e7f9              B        |L14.16|
;;;122    
                          ENDP


                          AREA ||i.rt_timer_next_timeout_tick||, CODE, READONLY, ALIGN=2

                  rt_timer_next_timeout_tick PROC
;;;552     */
;;;553    rt_tick_t rt_timer_next_timeout_tick(void)
000000  b510              PUSH     {r4,lr}
;;;554    {
;;;555        return rt_timer_list_next_timeout(rt_timer_list);
000002  4802              LDR      r0,|L15.12|
000004  f7fffffe          BL       rt_timer_list_next_timeout
;;;556    }
000008  bd10              POP      {r4,pc}
;;;557    
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      rt_timer_list

                          AREA ||i.rt_timer_start||, CODE, READONLY, ALIGN=2

                  rt_timer_start PROC
;;;293     */
;;;294    rt_err_t rt_timer_start(rt_timer_t timer)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;295    {
000004  4605              MOV      r5,r0
;;;296        unsigned int row_lvl;
;;;297        rt_list_t *timer_list;
;;;298        register rt_base_t level;
;;;299        rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
;;;300        unsigned int tst_nr;
;;;301        static unsigned int random_nr;
;;;302    
;;;303        /* timer check */
;;;304        RT_ASSERT(timer != RT_NULL);
;;;305    
;;;306        /* stop timer firstly */
;;;307        level = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4680              MOV      r8,r0
;;;308        /* remove timer from list */
;;;309        _rt_timer_remove(timer);
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       _rt_timer_remove
;;;310        /* change status of timer */
;;;311        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000012  7a68              LDRB     r0,[r5,#9]
000014  f0200001          BIC      r0,r0,#1
000018  7268              STRB     r0,[r5,#9]
;;;312        rt_hw_interrupt_enable(level);
00001a  4640              MOV      r0,r8
00001c  f7fffffe          BL       rt_hw_interrupt_enable
;;;313    
;;;314        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
;;;315    
;;;316        /*
;;;317         * get timeout tick,
;;;318         * the max timeout tick shall not great than RT_TICK_MAX/2
;;;319         */
;;;320        RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
;;;321        timer->timeout_tick = rt_tick_get() + timer->init_tick;
000020  f7fffffe          BL       rt_tick_get
000024  6a69              LDR      r1,[r5,#0x24]
000026  4408              ADD      r0,r0,r1
000028  62a8              STR      r0,[r5,#0x28]
;;;322    
;;;323        /* disable interrupt */
;;;324        level = rt_hw_interrupt_disable();
00002a  f7fffffe          BL       rt_hw_interrupt_disable
00002e  4680              MOV      r8,r0
;;;325    
;;;326    #ifdef RT_USING_TIMER_SOFT
;;;327        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
;;;328        {
;;;329            /* insert timer to soft timer list */
;;;330            timer_list = rt_soft_timer_list;
;;;331        }
;;;332        else
;;;333    #endif
;;;334        {
;;;335            /* insert timer to system timer list */
;;;336            timer_list = rt_timer_list;
000030  4f2f              LDR      r7,|L16.240|
;;;337        }
;;;338    
;;;339        row_head[0]  = &timer_list[0];
000032  9700              STR      r7,[sp,#0]
;;;340        for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
000034  2400              MOVS     r4,#0
000036  e02a              B        |L16.142|
                  |L16.56|
;;;341        {
;;;342            for (; row_head[row_lvl] != timer_list[row_lvl].prev;
000038  e019              B        |L16.110|
                  |L16.58|
;;;343                 row_head[row_lvl]  = row_head[row_lvl]->next)
;;;344            {
;;;345                struct rt_timer *t;
;;;346                rt_list_t *p = row_head[row_lvl]->next;
00003a  f85d2024          LDR      r2,[sp,r4,LSL #2]
00003e  6811              LDR      r1,[r2,#0]
;;;347    
;;;348                /* fix up the entry pointer */
;;;349                t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
000040  2214              MOVS     r2,#0x14
000042  eb0202c4          ADD      r2,r2,r4,LSL #3
000046  1a88              SUBS     r0,r1,r2
;;;350    
;;;351                /* If we have two timers that timeout at the same time, it's
;;;352                 * preferred that the timer inserted early get called early.
;;;353                 * So insert the new timer to the end the the some-timeout timer
;;;354                 * list.
;;;355                 */
;;;356                if ((t->timeout_tick - timer->timeout_tick) == 0)
000048  6a82              LDR      r2,[r0,#0x28]
00004a  6aab              LDR      r3,[r5,#0x28]
00004c  1ad2              SUBS     r2,r2,r3
00004e  d100              BNE      |L16.82|
;;;357                {
;;;358                    continue;
000050  e008              B        |L16.100|
                  |L16.82|
;;;359                }
;;;360                else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
000052  6a82              LDR      r2,[r0,#0x28]
000054  6aab              LDR      r3,[r5,#0x28]
000056  1ad2              SUBS     r2,r2,r3
000058  f06f4300          MVN      r3,#0x80000000
00005c  429a              CMP      r2,r3
00005e  d200              BCS      |L16.98|
;;;361                {
;;;362                    break;
000060  e00c              B        |L16.124|
                  |L16.98|
000062  bf00              NOP                            ;358
                  |L16.100|
000064  f85d0024          LDR      r0,[sp,r4,LSL #2]     ;343
000068  6800              LDR      r0,[r0,#0]            ;343
00006a  f84d0024          STR      r0,[sp,r4,LSL #2]     ;343
                  |L16.110|
00006e  f85d0024          LDR      r0,[sp,r4,LSL #2]     ;342
000072  eb0701c4          ADD      r1,r7,r4,LSL #3       ;342
000076  6849              LDR      r1,[r1,#4]            ;342
000078  4288              CMP      r0,r1                 ;342
00007a  d1de              BNE      |L16.58|
                  |L16.124|
00007c  bf00              NOP      
;;;363                }
;;;364            }
;;;365            if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
00007e  b12c              CBZ      r4,|L16.140|
;;;366                row_head[row_lvl + 1] = row_head[row_lvl] + 1;
000080  f85d0024          LDR      r0,[sp,r4,LSL #2]
000084  3008              ADDS     r0,r0,#8
000086  1c61              ADDS     r1,r4,#1
000088  f84d0021          STR      r0,[sp,r1,LSL #2]
                  |L16.140|
00008c  1c64              ADDS     r4,r4,#1              ;340
                  |L16.142|
00008e  2c00              CMP      r4,#0                 ;340
000090  d0d2              BEQ      |L16.56|
;;;367        }
;;;368    
;;;369        /* Interestingly, this super simple timer insert counter works very very
;;;370         * well on distributing the list height uniformly. By means of "very very
;;;371         * well", I mean it beats the randomness of timer->timeout_tick very easily
;;;372         * (actually, the timeout_tick is not random and easy to be attacked). */
;;;373        random_nr++;
000092  4818              LDR      r0,|L16.244|
000094  6800              LDR      r0,[r0,#0]  ; random_nr
000096  1c40              ADDS     r0,r0,#1
000098  4916              LDR      r1,|L16.244|
00009a  6008              STR      r0,[r1,#0]  ; random_nr
;;;374        tst_nr = random_nr;
00009c  4608              MOV      r0,r1
00009e  6806              LDR      r6,[r0,#0]  ; random_nr
;;;375    
;;;376        rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - 1],
0000a0  f1050114          ADD      r1,r5,#0x14
0000a4  9800              LDR      r0,[sp,#0]
0000a6  f7fffffe          BL       rt_list_insert_after
;;;377                             &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - 1]));
;;;378        for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
0000aa  2402              MOVS     r4,#2
0000ac  e012              B        |L16.212|
                  |L16.174|
;;;379        {
;;;380            if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
0000ae  f0060003          AND      r0,r6,#3
0000b2  b960              CBNZ     r0,|L16.206|
;;;381                rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
0000b4  f1c40301          RSB      r3,r4,#1
0000b8  f1050214          ADD      r2,r5,#0x14
0000bc  eb0201c3          ADD      r1,r2,r3,LSL #3
0000c0  f1c40201          RSB      r2,r4,#1
0000c4  f85d0022          LDR      r0,[sp,r2,LSL #2]
0000c8  f7fffffe          BL       rt_list_insert_after
0000cc  e000              B        |L16.208|
                  |L16.206|
;;;382                                     &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
;;;383            else
;;;384                break;
0000ce  e003              B        |L16.216|
                  |L16.208|
;;;385            /* Shift over the bits we have tested. Works well with 1 bit and 2
;;;386             * bits. */
;;;387            tst_nr >>= (RT_TIMER_SKIP_LIST_MASK + 1) >> 1;
0000d0  08b6              LSRS     r6,r6,#2
0000d2  1c64              ADDS     r4,r4,#1              ;378
                  |L16.212|
0000d4  2c01              CMP      r4,#1                 ;378
0000d6  d9ea              BLS      |L16.174|
                  |L16.216|
0000d8  bf00              NOP                            ;384
;;;388        }
;;;389    
;;;390        timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
0000da  7a68              LDRB     r0,[r5,#9]
0000dc  f0400001          ORR      r0,r0,#1
0000e0  7268              STRB     r0,[r5,#9]
;;;391    
;;;392        /* enable interrupt */
;;;393        rt_hw_interrupt_enable(level);
0000e2  4640              MOV      r0,r8
0000e4  f7fffffe          BL       rt_hw_interrupt_enable
;;;394    
;;;395    #ifdef RT_USING_TIMER_SOFT
;;;396        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
;;;397        {
;;;398            /* check whether timer thread is ready */
;;;399            if ((timer_thread.stat & RT_THREAD_STAT_MASK) != RT_THREAD_READY)
;;;400            {
;;;401                /* resume timer thread to check soft timer */
;;;402                rt_thread_resume(&timer_thread);
;;;403                rt_schedule();
;;;404            }
;;;405        }
;;;406    #endif
;;;407    
;;;408        return -RT_EOK;
0000e8  2000              MOVS     r0,#0
;;;409    }
0000ea  e8bd83f8          POP      {r3-r9,pc}
;;;410    RTM_EXPORT(rt_timer_start);
                          ENDP

0000ee  0000              DCW      0x0000
                  |L16.240|
                          DCD      rt_timer_list
                  |L16.244|
                          DCD      random_nr

                          AREA ||i.rt_timer_stop||, CODE, READONLY, ALIGN=1

                  rt_timer_stop PROC
;;;418     */
;;;419    rt_err_t rt_timer_stop(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  4604              MOV      r4,r0
;;;421        register rt_base_t level;
;;;422    
;;;423        /* timer check */
;;;424        RT_ASSERT(timer != RT_NULL);
;;;425        if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000004  7a60              LDRB     r0,[r4,#9]
000006  f0000001          AND      r0,r0,#1
00000a  b910              CBNZ     r0,|L17.18|
;;;426            return -RT_ERROR;
00000c  f04f30ff          MOV      r0,#0xffffffff
                  |L17.16|
;;;427    
;;;428        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
;;;429    
;;;430        /* disable interrupt */
;;;431        level = rt_hw_interrupt_disable();
;;;432    
;;;433        _rt_timer_remove(timer);
;;;434    
;;;435        /* enable interrupt */
;;;436        rt_hw_interrupt_enable(level);
;;;437    
;;;438        /* change stat */
;;;439        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
;;;440    
;;;441        return RT_EOK;
;;;442    }
000010  bd70              POP      {r4-r6,pc}
                  |L17.18|
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4605              MOV      r5,r0                 ;431
000018  4620              MOV      r0,r4                 ;433
00001a  f7fffffe          BL       _rt_timer_remove
00001e  4628              MOV      r0,r5                 ;436
000020  f7fffffe          BL       rt_hw_interrupt_enable
000024  7a60              LDRB     r0,[r4,#9]            ;439
000026  f0200001          BIC      r0,r0,#1              ;439
00002a  7260              STRB     r0,[r4,#9]            ;439
00002c  2000              MOVS     r0,#0                 ;441
00002e  e7ef              B        |L17.16|
;;;443    RTM_EXPORT(rt_timer_stop);
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  rt_timer_list
                          %        8
                  random_nr
                          DCD      0x00000000

; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o..\output\objects\scheduler.o --asm_dir=..\Output\Listings\ --list_dir=..\Output\Listings\ --depend=..\output\objects\scheduler.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\Core\Inc -I..\Driver -I..\Driver\Inc -I..\Middle\Inc -I..\rtthread\include -I..\rtthread\include\libc -I..\rtthread\components\finsh -I..\rtthread -I..\rtthread\components\drivers\include -ID:\Software\Keil\Keil\STM32F1xx_DFP\2.3.0\Device\Include -ID:\Software\Keil\ARM\CMSIS\Include -D__UVISION_VERSION=539 -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DRT_USING_DEVICE --omf_browse=..\output\objects\scheduler.crf ..\rtthread\src\scheduler.c]
                          THUMB

                          AREA ||i.rt_critical_level||, CODE, READONLY, ALIGN=2

                  rt_critical_level PROC
;;;427     */
;;;428    rt_uint16_t rt_critical_level(void)
000000  4801              LDR      r0,|L1.8|
;;;429    {
;;;430        return rt_scheduler_lock_nest;
000002  8800              LDRH     r0,[r0,#0]  ; rt_scheduler_lock_nest
000004  b280              UXTH     r0,r0
;;;431    }
000006  4770              BX       lr
;;;432    RTM_EXPORT(rt_critical_level);
                          ENDP

                  |L1.8|
                          DCD      rt_scheduler_lock_nest

                          AREA ||i.rt_enter_critical||, CODE, READONLY, ALIGN=2

                  rt_enter_critical PROC
;;;376     */
;;;377    void rt_enter_critical(void)
000000  b510              PUSH     {r4,lr}
;;;378    {
;;;379        register rt_base_t level;
;;;380    
;;;381        /* disable interrupt */
;;;382        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4604              MOV      r4,r0
;;;383    
;;;384        /*
;;;385         * the maximal number of nest is RT_UINT16_MAX, which is big
;;;386         * enough and does not check here
;;;387         */
;;;388        rt_scheduler_lock_nest ++;
000008  4804              LDR      r0,|L2.28|
00000a  8800              LDRH     r0,[r0,#0]  ; rt_scheduler_lock_nest
00000c  1c40              ADDS     r0,r0,#1
00000e  b200              SXTH     r0,r0
000010  4902              LDR      r1,|L2.28|
000012  8008              STRH     r0,[r1,#0]
;;;389    
;;;390        /* enable interrupt */
;;;391        rt_hw_interrupt_enable(level);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rt_hw_interrupt_enable
;;;392    }
00001a  bd10              POP      {r4,pc}
;;;393    RTM_EXPORT(rt_enter_critical);
                          ENDP

                  |L2.28|
                          DCD      rt_scheduler_lock_nest

                          AREA ||i.rt_exit_critical||, CODE, READONLY, ALIGN=2

                  rt_exit_critical PROC
;;;397     */
;;;398    void rt_exit_critical(void)
000000  b510              PUSH     {r4,lr}
;;;399    {
;;;400        register rt_base_t level;
;;;401    
;;;402        /* disable interrupt */
;;;403        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4604              MOV      r4,r0
;;;404    
;;;405        rt_scheduler_lock_nest --;
000008  480b              LDR      r0,|L3.56|
00000a  8800              LDRH     r0,[r0,#0]  ; rt_scheduler_lock_nest
00000c  1e40              SUBS     r0,r0,#1
00000e  b200              SXTH     r0,r0
000010  4909              LDR      r1,|L3.56|
000012  8008              STRH     r0,[r1,#0]
;;;406    
;;;407        if (rt_scheduler_lock_nest <= 0)
000014  4608              MOV      r0,r1
000016  f9b00000          LDRSH    r0,[r0,#0]  ; rt_scheduler_lock_nest
00001a  2800              CMP      r0,#0
00001c  dc07              BGT      |L3.46|
;;;408        {
;;;409            rt_scheduler_lock_nest = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;410            /* enable interrupt */
;;;411            rt_hw_interrupt_enable(level);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_hw_interrupt_enable
;;;412    
;;;413            rt_schedule();
000028  f7fffffe          BL       rt_schedule
00002c  e002              B        |L3.52|
                  |L3.46|
;;;414        }
;;;415        else
;;;416        {
;;;417            /* enable interrupt */
;;;418            rt_hw_interrupt_enable(level);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       rt_hw_interrupt_enable
                  |L3.52|
;;;419        }
;;;420    }
000034  bd10              POP      {r4,pc}
;;;421    RTM_EXPORT(rt_exit_critical);
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      rt_scheduler_lock_nest

                          AREA ||i.rt_list_init||, CODE, READONLY, ALIGN=1

                  rt_list_init PROC
;;;60      */
;;;61     rt_inline void rt_list_init(rt_list_t *l)
000000  6040              STR      r0,[r0,#4]
;;;62     {
;;;63         l->next = l->prev = l;
000002  6000              STR      r0,[r0,#0]
;;;64     }
000004  4770              BX       lr
;;;65     
                          ENDP


                          AREA ||i.rt_schedule||, CODE, READONLY, ALIGN=2

                  rt_schedule PROC
;;;190     */
;;;191    void rt_schedule(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;192    {
;;;193        rt_base_t level;
;;;194        struct rt_thread *to_thread;
;;;195        struct rt_thread *from_thread;
;;;196    
;;;197        /* disable interrupt */
;;;198        level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4607              MOV      r7,r0
;;;199    
;;;200        /* check the scheduler is enabled or not */
;;;201        if (rt_scheduler_lock_nest == 0)
00000a  481b              LDR      r0,|L5.120|
00000c  8800              LDRH     r0,[r0,#0]  ; rt_scheduler_lock_nest
00000e  bb68              CBNZ     r0,|L5.108|
;;;202        {
;;;203            register rt_ubase_t highest_ready_priority;
;;;204    
;;;205    #if RT_THREAD_PRIORITY_MAX <= 32
;;;206            highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
000010  481a              LDR      r0,|L5.124|
000012  6800              LDR      r0,[r0,#0]  ; rt_thread_ready_priority_group
000014  f7fffffe          BL       __rt_ffs
000018  1e46              SUBS     r6,r0,#1
;;;207    #else
;;;208            register rt_ubase_t number;
;;;209    
;;;210            number = __rt_ffs(rt_thread_ready_priority_group) - 1;
;;;211            highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
;;;212    #endif
;;;213    
;;;214            /* get switch to thread */
;;;215            to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
00001a  4819              LDR      r0,|L5.128|
00001c  f8500036          LDR      r0,[r0,r6,LSL #3]
000020  f1a00414          SUB      r4,r0,#0x14
;;;216                                      struct rt_thread,
;;;217                                      tlist);
;;;218    
;;;219            /* if the destination thread is not the same as current thread */
;;;220            if (to_thread != rt_current_thread)
000024  4817              LDR      r0,|L5.132|
000026  6800              LDR      r0,[r0,#0]  ; rt_current_thread
000028  4284              CMP      r4,r0
00002a  d01b              BEQ      |L5.100|
;;;221            {
;;;222                rt_current_priority = (rt_uint8_t)highest_ready_priority;
00002c  4916              LDR      r1,|L5.136|
00002e  700e              STRB     r6,[r1,#0]
;;;223                from_thread         = rt_current_thread;
000030  4814              LDR      r0,|L5.132|
000032  6805              LDR      r5,[r0,#0]  ; rt_current_thread
;;;224                rt_current_thread   = to_thread;
000034  6004              STR      r4,[r0,#0]  ; rt_current_thread
;;;225    
;;;226                RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
;;;227    
;;;228                /* switch to new thread */
;;;229                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
;;;230                             ("[%d]switch to priority#%d "
;;;231                              "thread:%.*s(sp:0x%p), "
;;;232                              "from thread:%.*s(sp: 0x%p)\n",
;;;233                              rt_interrupt_nest, highest_ready_priority,
;;;234                              RT_NAME_MAX, to_thread->name, to_thread->sp,
;;;235                              RT_NAME_MAX, from_thread->name, from_thread->sp));
;;;236    
;;;237    #ifdef RT_USING_OVERFLOW_CHECK
;;;238                _rt_scheduler_stack_check(to_thread);
;;;239    #endif
;;;240    
;;;241                if (rt_interrupt_nest == 0)
000036  4815              LDR      r0,|L5.140|
000038  7800              LDRB     r0,[r0,#0]  ; rt_interrupt_nest
00003a  b948              CBNZ     r0,|L5.80|
;;;242                {
;;;243                    extern void rt_thread_handle_sig(rt_bool_t clean_state);
;;;244    
;;;245                    rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
00003c  f104011c          ADD      r1,r4,#0x1c
000040  f105001c          ADD      r0,r5,#0x1c
000044  f7fffffe          BL       rt_hw_context_switch
;;;246                                         (rt_uint32_t)&to_thread->sp);
;;;247    
;;;248                    /* enable interrupt */
;;;249                    rt_hw_interrupt_enable(level);
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       rt_hw_interrupt_enable
00004e  e00c              B        |L5.106|
                  |L5.80|
;;;250    
;;;251    #ifdef RT_USING_SIGNALS
;;;252                    /* check signal status */
;;;253                    rt_thread_handle_sig(RT_TRUE);
;;;254    #endif
;;;255                }
;;;256                else
;;;257                {
;;;258                    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));
;;;259    
;;;260                    rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
000050  f104011c          ADD      r1,r4,#0x1c
000054  f105001c          ADD      r0,r5,#0x1c
000058  f7fffffe          BL       rt_hw_context_switch_interrupt
;;;261                                                   (rt_uint32_t)&to_thread->sp);
;;;262                    /* enable interrupt */
;;;263                    rt_hw_interrupt_enable(level);
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       rt_hw_interrupt_enable
000062  e002              B        |L5.106|
                  |L5.100|
;;;264                }
;;;265            }
;;;266            else
;;;267            {
;;;268                /* enable interrupt */
;;;269                rt_hw_interrupt_enable(level);
000064  4638              MOV      r0,r7
000066  f7fffffe          BL       rt_hw_interrupt_enable
                  |L5.106|
;;;270            }
;;;271        }
00006a  e002              B        |L5.114|
                  |L5.108|
;;;272        else
;;;273        {
;;;274            /* enable interrupt */
;;;275            rt_hw_interrupt_enable(level);
00006c  4638              MOV      r0,r7
00006e  f7fffffe          BL       rt_hw_interrupt_enable
                  |L5.114|
;;;276        }
;;;277    }
000072  e8bd81f0          POP      {r4-r8,pc}
;;;278    
                          ENDP

000076  0000              DCW      0x0000
                  |L5.120|
                          DCD      rt_scheduler_lock_nest
                  |L5.124|
                          DCD      rt_thread_ready_priority_group
                  |L5.128|
                          DCD      rt_thread_priority_table
                  |L5.132|
                          DCD      rt_current_thread
                  |L5.136|
                          DCD      rt_current_priority
                  |L5.140|
                          DCD      rt_interrupt_nest

                          AREA ||i.rt_schedule_insert_thread||, CODE, READONLY, ALIGN=2

                  rt_schedule_insert_thread PROC
;;;285     */
;;;286    void rt_schedule_insert_thread(struct rt_thread *thread)
000000  b570              PUSH     {r4-r6,lr}
;;;287    {
000002  4604              MOV      r4,r0
;;;288        register rt_base_t temp;
;;;289    
;;;290        RT_ASSERT(thread != RT_NULL);
;;;291    
;;;292        /* disable interrupt */
;;;293        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;294    
;;;295        /* change stat */
;;;296        thread->stat = RT_THREAD_READY | (thread->stat & ~RT_THREAD_STAT_MASK);
00000a  f8140f34          LDRB     r0,[r4,#0x34]!
00000e  f020000f          BIC      r0,r0,#0xf
000012  f0400001          ORR      r0,r0,#1
000016  7020              STRB     r0,[r4,#0]
;;;297    
;;;298        /* insert thread to ready list */
;;;299        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
000018  7862              LDRB     r2,[r4,#1]
00001a  3c34              SUBS     r4,r4,#0x34
00001c  4b0a              LDR      r3,|L6.72|
00001e  eb0300c2          ADD      r0,r3,r2,LSL #3
000022  f1040114          ADD      r1,r4,#0x14
000026  6842              LDR      r2,[r0,#4]
000028  6011              STR      r1,[r2,#0]
00002a  6842              LDR      r2,[r0,#4]
00002c  604a              STR      r2,[r1,#4]
00002e  6041              STR      r1,[r0,#4]
000030  6008              STR      r0,[r1,#0]
000032  bf00              NOP      
;;;300                              &(thread->tlist));
;;;301    
;;;302        /* set priority mask */
;;;303    #if RT_THREAD_PRIORITY_MAX <= 32
;;;304        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("insert thread[%.*s], the priority: %d\n",
;;;305                                          RT_NAME_MAX, thread->name, thread->current_priority));
;;;306    #else
;;;307        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
;;;308                     ("insert thread[%.*s], the priority: %d 0x%x %d\n",
;;;309                      RT_NAME_MAX,
;;;310                      thread->name,
;;;311                      thread->number,
;;;312                      thread->number_mask,
;;;313                      thread->high_mask));
;;;314    #endif
;;;315    
;;;316    #if RT_THREAD_PRIORITY_MAX > 32
;;;317        rt_thread_ready_table[thread->number] |= thread->high_mask;
;;;318    #endif
;;;319        rt_thread_ready_priority_group |= thread->number_mask;
000034  4905              LDR      r1,|L6.76|
000036  6ba0              LDR      r0,[r4,#0x38]
000038  6809              LDR      r1,[r1,#0]  ; rt_thread_ready_priority_group
00003a  4308              ORRS     r0,r0,r1
00003c  4903              LDR      r1,|L6.76|
00003e  6008              STR      r0,[r1,#0]  ; rt_thread_ready_priority_group
;;;320    
;;;321        /* enable interrupt */
;;;322        rt_hw_interrupt_enable(temp);
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       rt_hw_interrupt_enable
;;;323    }
000046  bd70              POP      {r4-r6,pc}
;;;324    
                          ENDP

                  |L6.72|
                          DCD      rt_thread_priority_table
                  |L6.76|
                          DCD      rt_thread_ready_priority_group

                          AREA ||i.rt_schedule_remove_thread||, CODE, READONLY, ALIGN=2

                  rt_schedule_remove_thread PROC
;;;331     */
;;;332    void rt_schedule_remove_thread(struct rt_thread *thread)
000000  b570              PUSH     {r4-r6,lr}
;;;333    {
000002  4604              MOV      r4,r0
;;;334        register rt_base_t temp;
;;;335    
;;;336        RT_ASSERT(thread != RT_NULL);
;;;337    
;;;338        /* disable interrupt */
;;;339        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;340    
;;;341    #if RT_THREAD_PRIORITY_MAX <= 32
;;;342        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
;;;343                                          RT_NAME_MAX, thread->name,
;;;344                                          thread->current_priority));
;;;345    #else
;;;346        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
;;;347                     ("remove thread[%.*s], the priority: %d 0x%x %d\n",
;;;348                      RT_NAME_MAX,
;;;349                      thread->name,
;;;350                      thread->number,
;;;351                      thread->number_mask,
;;;352                      thread->high_mask));
;;;353    #endif
;;;354    
;;;355        /* remove thread from ready list */
;;;356        rt_list_remove(&(thread->tlist));
00000a  f1040014          ADD      r0,r4,#0x14
00000e  e9d02100          LDRD     r2,r1,[r0,#0]
000012  6051              STR      r1,[r2,#4]
000014  e9d01200          LDRD     r1,r2,[r0,#0]
000018  6011              STR      r1,[r2,#0]
00001a  6040              STR      r0,[r0,#4]
00001c  6000              STR      r0,[r0,#0]
00001e  bf00              NOP      
;;;357        if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
000020  f8941035          LDRB     r1,[r4,#0x35]
000024  4a09              LDR      r2,|L7.76|
000026  eb0200c1          ADD      r0,r2,r1,LSL #3
00002a  6801              LDR      r1,[r0,#0]
00002c  4281              CMP      r1,r0
00002e  d101              BNE      |L7.52|
000030  2101              MOVS     r1,#1
000032  e000              B        |L7.54|
                  |L7.52|
000034  2100              MOVS     r1,#0
                  |L7.54|
000036  b129              CBZ      r1,|L7.68|
;;;358        {
;;;359    #if RT_THREAD_PRIORITY_MAX > 32
;;;360            rt_thread_ready_table[thread->number] &= ~thread->high_mask;
;;;361            if (rt_thread_ready_table[thread->number] == 0)
;;;362            {
;;;363                rt_thread_ready_priority_group &= ~thread->number_mask;
;;;364            }
;;;365    #else
;;;366            rt_thread_ready_priority_group &= ~thread->number_mask;
000038  4805              LDR      r0,|L7.80|
00003a  6ba1              LDR      r1,[r4,#0x38]
00003c  6800              LDR      r0,[r0,#0]  ; rt_thread_ready_priority_group
00003e  4388              BICS     r0,r0,r1
000040  4903              LDR      r1,|L7.80|
000042  6008              STR      r0,[r1,#0]  ; rt_thread_ready_priority_group
                  |L7.68|
;;;367    #endif
;;;368        }
;;;369    
;;;370        /* enable interrupt */
;;;371        rt_hw_interrupt_enable(temp);
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       rt_hw_interrupt_enable
;;;372    }
00004a  bd70              POP      {r4-r6,pc}
;;;373    
                          ENDP

                  |L7.76|
                          DCD      rt_thread_priority_table
                  |L7.80|
                          DCD      rt_thread_ready_priority_group

                          AREA ||i.rt_system_scheduler_init||, CODE, READONLY, ALIGN=2

                  rt_system_scheduler_init PROC
;;;119     */
;;;120    void rt_system_scheduler_init(void)
000000  b510              PUSH     {r4,lr}
;;;121    {
;;;122        register rt_base_t offset;
;;;123    
;;;124        rt_scheduler_lock_nest = 0;
000002  2000              MOVS     r0,#0
000004  490b              LDR      r1,|L8.52|
000006  8008              STRH     r0,[r1,#0]
;;;125    
;;;126        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
;;;127                                          RT_THREAD_PRIORITY_MAX));
;;;128    
;;;129        for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
000008  2400              MOVS     r4,#0
00000a  e005              B        |L8.24|
                  |L8.12|
;;;130        {
;;;131            rt_list_init(&rt_thread_priority_table[offset]);
00000c  490a              LDR      r1,|L8.56|
00000e  eb0100c4          ADD      r0,r1,r4,LSL #3
000012  f7fffffe          BL       rt_list_init
000016  1c64              ADDS     r4,r4,#1              ;129
                  |L8.24|
000018  2c20              CMP      r4,#0x20              ;129
00001a  dbf7              BLT      |L8.12|
;;;132        }
;;;133    
;;;134        rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
00001c  201f              MOVS     r0,#0x1f
00001e  4907              LDR      r1,|L8.60|
000020  7008              STRB     r0,[r1,#0]
;;;135        rt_current_thread = RT_NULL;
000022  2000              MOVS     r0,#0
000024  4906              LDR      r1,|L8.64|
000026  6008              STR      r0,[r1,#0]  ; rt_current_thread
;;;136    
;;;137        /* initialize ready priority group */
;;;138        rt_thread_ready_priority_group = 0;
000028  4906              LDR      r1,|L8.68|
00002a  6008              STR      r0,[r1,#0]  ; rt_thread_ready_priority_group
;;;139    
;;;140    #if RT_THREAD_PRIORITY_MAX > 32
;;;141        /* initialize ready table */
;;;142        rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
;;;143    #endif
;;;144    
;;;145        /* initialize thread defunct */
;;;146        rt_list_init(&rt_thread_defunct);
00002c  4806              LDR      r0,|L8.72|
00002e  f7fffffe          BL       rt_list_init
;;;147    }
000032  bd10              POP      {r4,pc}
;;;148    
                          ENDP

                  |L8.52|
                          DCD      rt_scheduler_lock_nest
                  |L8.56|
                          DCD      rt_thread_priority_table
                  |L8.60|
                          DCD      rt_current_priority
                  |L8.64|
                          DCD      rt_current_thread
                  |L8.68|
                          DCD      rt_thread_ready_priority_group
                  |L8.72|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_system_scheduler_start||, CODE, READONLY, ALIGN=2

                  rt_system_scheduler_start PROC
;;;153     */
;;;154    void rt_system_scheduler_start(void)
000000  b570              PUSH     {r4-r6,lr}
;;;155    {
;;;156        register struct rt_thread *to_thread;
;;;157        register rt_ubase_t highest_ready_priority;
;;;158    
;;;159    #if RT_THREAD_PRIORITY_MAX > 32
;;;160        register rt_ubase_t number;
;;;161    
;;;162        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
;;;163        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
;;;164    #else
;;;165        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
000002  4808              LDR      r0,|L9.36|
000004  6800              LDR      r0,[r0,#0]  ; rt_thread_ready_priority_group
000006  f7fffffe          BL       __rt_ffs
00000a  1e45              SUBS     r5,r0,#1
;;;166    #endif
;;;167    
;;;168        /* get switch to thread */
;;;169        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
00000c  4806              LDR      r0,|L9.40|
00000e  f8500035          LDR      r0,[r0,r5,LSL #3]
000012  f1a00414          SUB      r4,r0,#0x14
;;;170                                  struct rt_thread,
;;;171                                  tlist);
;;;172    
;;;173        rt_current_thread = to_thread;
000016  4805              LDR      r0,|L9.44|
000018  6004              STR      r4,[r0,#0]  ; rt_current_thread
;;;174    
;;;175        /* switch to new thread */
;;;176        rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
00001a  f104001c          ADD      r0,r4,#0x1c
00001e  f7fffffe          BL       rt_hw_context_switch_to
;;;177    
;;;178        /* never come back */
;;;179    }
000022  bd70              POP      {r4-r6,pc}
;;;180    
                          ENDP

                  |L9.36|
                          DCD      rt_thread_ready_priority_group
                  |L9.40|
                          DCD      rt_thread_priority_table
                  |L9.44|
                          DCD      rt_current_thread

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rt_thread_priority_table
                          %        256

                          AREA ||.data||, DATA, ALIGN=2

                  rt_scheduler_lock_nest
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  rt_current_thread
                          DCD      0x00000000
                  rt_current_priority
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  rt_thread_ready_priority_group
                          DCD      0x00000000
                  rt_thread_defunct
                          %        8
